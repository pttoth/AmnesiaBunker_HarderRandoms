#include "interfaces/UserModule_Interface.hps"
#include "interfaces/UsersHandler_Interface.hps"
#include "custom/modules/ModuleInterfaces_Custom.hps"
#include "base/InputHandler_Types.hps"
#include "custom/helpers/helper_imgui_options.hps"
#include "custom/helpers/helper_modules_custom.hps"
#include "custom/helpers/helper_menu.hps"
#include "helpers/helper_imgui.hps"
#include "helpers/helper_game.hps"
#include "helpers/helper_audio.hps"
#include "helpers/helper_modules.hps"
#include "helpers/helper_effects.hps"
#include "helpers/helper_input.hps"
#include "custom/helpers/helper_items.hps"
#include "base/AchievementHandler_Types.hps"
#include "helpers/helper_map.hps"

class cSaveSlot
{
	int mlId;
	array<cSaveFile> mvSlotSaveFiles;
	bool mbExpanded = true;
}

class cSaveFile
{
	tWString msSaveName;
	tString msSaveDate;
	tWString msSaveFile;
	tWString msSaveSuffix;
	int mlGameMode;
}

enum eMainMenuButtonID
{
	eMainMenuButtonID_Continue,
	eMainMenuButtonID_NewGame,
	eMainMenuButtonID_LoadGame,
	eMainMenuButtonID_CustomStories,
	eMainMenuButtonID_Options,
	eMainMenuButtonID_DisplayDifficultySettings,
	eMainMenuButtonID_TrainingGrounds,
	eMainMenuButtonID_ReturnToGame,
	eMainMenuButtonID_SaveAndExit,
	eMainMenuButtonID_Gamma,
	eMainMenuButtonID_QuitToMenu,
	eMainMenuButtonID_QuitToDesktop,
};

enum ePreMenuPhase
{
	ePreMenuPhase_Init,
	ePreMenuPhase_None,
	ePreMenuPhase_FrictionalLogo,
	ePreMenuPhase_FmodLogo,
	ePreMenuPhase_PressToContinue,
	ePreMenuPhase_Gamma,
	ePreMenuPhase_FinalFade,
	ePreMenuPhase_Done,
	ePreMenuPhase_Welcome,
};

enum eMainMenuGroup
{
	eMainMenuGroup_Main,
	eMainMenuGroup_SaveSlotSelection,
	eMainMenuGroup_LoadGame,
	eMainMenuGroup_Options,
	eMainMenuGroup_Options_Game,
	eMainMenuGroup_Options_NewGame_Gameplay,
	eMainMenuGroup_Options_Controls,
	eMainMenuGroup_Options_KeyboardMouse,
	eMainMenuGroup_Options_Keybind,
	eMainMenuGroup_Options_Gamepad,
	eMainMenuGroup_Options_Display,
	eMainMenuGroup_Options_Graphics,
	eMainMenuGroup_Options_Display_Gamma,
	eMainMenuGroup_Options_Audio,
	eMainMenuGroup_Options_Accessibility,
	eMainMenuGroup_Options_Accessibility_Game,
	eMainMenuGroup_Options_Accessibility_Input,
	eMainMenuGroup_Options_Audio_Subtitles,
	eMainMenuGroup_Options_Video,
	eMainMenuGroup_Options_Video_Display,
	eMainMenuGroup_Options_Video_PostEffect,
	eMainMenuGroup_Options_Video_World,
	eMainMenuGroup_Options_Video_Gamma,
	eMainMenuGroup_Options_Input,
	eMainMenuGroup_Options_Input_Keybind,
	eMainMenuGroup_Options_Input_Mouse,
	eMainMenuGroup_Options_Input_GamepadMapping,
	eMainMenuGroup_Options_Gameplay,
	eMainMenuGroup_Options_Debug,
	eMainMenuGroup_CustomStories,
	eMainMenuGroup_GameModes,
	eMainMenuGroup_DisplayDifficultySettings,
	eMainMenuGroup_NewGame_Gamma,
	
	eMainMenuGroup_None,
	eMainMenuGroup_LastEnum,
};

enum eGraphicSettings
{
	eGraphicSettings_Low,
	eGraphicSettings_Medium,
	eGraphicSettings_High,
	eGraphicSettings_LastEnum,
};

//-------------------------------------------------------------//
// Data for menu, values based on 1280x720 resolution
//-------------------------------------------------------------//

const cVector2f kScreenCenter = cVector2f(512, 384); // Virtual size: 1024x768

const cVector2f kMainMenuButtonPos = cVector2f(180, 320);
const cVector2f kTitlePos = cVector2f(40, 65);
const cVector2f kTitleSize = cVector2f(380, 207);

//-----------------------------------------

const float kBaseMenuHeight = 100.f;
const float kMenuItemHeight = gfFontSize_MainMenu + 4;

const cVector2f kOptionsButtonPos = cVector2f(100, 280);
const cVector2f kOptionsBgPos = cVector2f(kOptionsButtonPos.x-46, kOptionsButtonPos.y-15);
const cVector2f kOptionsBgSize = cVector2f(183, 280);
const cVector2f kOptionsBgSizePS4 = cVector2f(183, 245);

const cVector2f kOptionsVideoBgSize = cVector2f(680, kBaseMenuHeight+kMenuItemHeight*5.f);

const cVector2f kOptionsGameplayButtonPos = cVector2f(100, 280);
const cVector2f kOptionsGameplayBgPos = cVector2f(kOptionsGameplayButtonPos.x-46, kOptionsGameplayButtonPos.y-15);
const cVector2f kOptionsGameplayBgSize = cVector2f(280, 255);
const cVector2f kOptionsGameplayPS4BgSize = cVector2f(280, 255);

const cVector2f kOptionsControlsButtonPos = cVector2f(100, 280);
const cVector2f kOptionsControlsBgPos = cVector2f(kOptionsControlsButtonPos.x-46, kOptionsControlsButtonPos.y-15);
const cVector2f kOptionsControlsBgSize = cVector2f(280, 430);
const cVector2f kOptionsControlsPS4BgSize = cVector2f(280, 245);

const cVector2f kOptionsDisplayButtonPos = cVector2f(100, 280);
const cVector2f kOptionsDisplayBgPos = cVector2f(kOptionsDisplayButtonPos.x-46, kOptionsDisplayButtonPos.y-15);
const cVector2f kOptionsDisplayBgSize = cVector2f(280, 460);

const cVector2f kOptionsGraphicsButtonPos = cVector2f(100, 120);
const cVector2f kOptionsGraphicsBgPos = cVector2f(kOptionsGraphicsButtonPos.x-46, kOptionsGraphicsButtonPos.y-15);
const cVector2f kOptionsGraphicsBgSize = cVector2f(300, 680);

const cVector2f kOptionsAudioButtonPos = cVector2f(100, 320);
const cVector2f kOptionsAudioBgPos = cVector2f(kOptionsAudioButtonPos.x-46, kOptionsAudioButtonPos.y-15);
const cVector2f kOptionsAudioBgSize = cVector2f(300, 220);
const cVector2f kOptionsAudioBgSizePS4 = cVector2f(300, 240);

const cVector2f kOptionsSubtitlesBgSize = cVector2f(340, 328);

const cVector2f kOptionsDebugButtonPos = cVector2f(100, 180);
const cVector2f kOptionsDebugBgPos = cVector2f(kOptionsDebugButtonPos.x-46, kOptionsDebugButtonPos.y-15);
const cVector2f kOptionsDebugBgSize = cVector2f(430, 520);

const cVector2f kOptionsVideoPostEffectBgSize = cVector2f(680, kBaseMenuHeight+kMenuItemHeight*4.f);
const cVector2f kOptionsVideoWorldBgSize = cVector2f(680, kBaseMenuHeight+kMenuItemHeight*8.f);
const cVector2f kOptionsVideoDisplayBgSize = cVector2f(680, kBaseMenuHeight+kMenuItemHeight*7.f);
const cVector2f kOptionsVideoGammaBgSize = cVector2f(680, kBaseMenuHeight+kMenuItemHeight*1.f);
const cVector2f kOptionsBgBorderSize = cVector2f(680, 42.5);
const cVector2f kInputBgSize = cVector2f(680, kBaseMenuHeight+kMenuItemHeight*3.f);
const cVector2f kInputGamepadBgSize = cVector2f(680, kBaseMenuHeight+kMenuItemHeight*4.f);
const cVector2f kInputPS4BgSize = cVector2f(680, 220);
const cVector2f kKeybindWindowBgSize = cVector2f(680, 380);
const cVector2f kOptionsMappingBgSize = cVector2f(820, 370);

const cVector2f kOptionsAccessibilityButtonPos = cVector2f(100, 280);
const cVector2f kOptionsAccessibilityBgPos = cVector2f(kOptionsAccessibilityButtonPos.x-46, kOptionsAccessibilityButtonPos.y-15);
const cVector2f kOptionsAccessibilityBgSize = cVector2f(280, 460);

const cVector2f kBackMargin = cVector2f(0,20);

const cVector2f kGammaBgSize = cVector2f(680, 220);

const cVector2f kOptionMenu_KeybindBgPos = cVector2f(350, 335);
const cVector2f kOptionMenu_KeybindBgSize = cVector2f(550, 35);
const cVector2f kOptionMenu_KeybindBgBorderSize = cVector2f(550, 42.5);
const cVector2f kOptionMenu_PressXPos = cVector2f(250, 345);

//-----------------------------------------

////////////////
// LOAD GAME

const cVector2f kLoadButtonPos = cVector2f(100, 150);
const cVector2f kLoadBgPos = cVector2f(kLoadButtonPos.x-46, kLoadButtonPos.y-15);
const cVector2f kLoadBgSize = cVector2f(400, 352);
const cVector2f kLoadFramePos = cVector2f(kLoadBgPos.x+36, kLoadBgPos.y+30);
const cVector2f kLoadFrameSize = cVector2f(450, 320);
const cVector2f kLoadScrollPos = cVector2f(kLoadFrameSize.x + 20, kLoadFramePos.y);	
const cVector2f kLoadScrollSize = cVector2f(14, kLoadFrameSize.y);	// Full size of the scroll area
const cVector2f kLoadSlotsPos = cVector2f(210, 265);				// Text inside frame
const cVector2f kLoadSlotsTimestampPos = cVector2f(kLoadFramePos.x+kLoadFrameSize.x-28, kLoadSlotsPos.y);	// Right aligned
const float kLoadSlotsFontSize = 28;
const float kLoadSlotsSpacing = 26;

//-----------------------------------------

////////////////
// KEYBINDINGS

const cVector2f kKeybindBgPos = cVector2f(kOptionsBgPos.x, kOptionsBgPos.y-128);
const cVector2f kKeybindBgSize = cVector2f(420, 520);
const cVector2f kKeybindFramePos = cVector2f(kKeybindBgPos.x+30, kKeybindBgPos.y+30);
const cVector2f kKeybindButtonPos = cVector2f(kKeybindBgPos.x+40, kKeybindBgPos.y+36);
const cVector2f kKeybindSlotsPos = cVector2f(kKeybindFramePos.x+12, kKeybindFramePos.y+12);
const float kKeybindSpacing = 32;

//-----------------------------------------

const cVector2f kMappingSize = cVector2f(768, 480);
const cVector2f kMappingSize_PS4 = cVector2f(918, 480);

const cVector2f kMappingPos = kOptionsButtonPos+cVector2f(0,-100);
const cVector2f kMappingPos_PS4 = kOptionsButtonPos+cVector2f(175,-45);

const cVector2f kGamepadPresetSize = cVector2f(640, 320);
const cVector2f kGamepadPresetSize_PS4 = cVector2f(472, 297);

const float kMappingGfxHeightMul = 0.115f;
const float kMappingGfxHeightMul_PS4 = 0.12f;

const float kMappingGamepadAlpha = 0.3f;
const float kMappingGamepadAlpha_PS4 = 0.8f;

const cVector2f kMappingArrowPosRight = cVector2f(130+130, 400-160);
const cVector2f kMappingArrowPosLeft = cVector2f(180+640+30, 400-160);

const cVector2f kMappingButtonPosRight = cVector2f(-1024+180+130, 260-160);
const cVector2f kMappingButtonPosLeft = cVector2f(180+680, 260-160);

const cVector2f kMappingArrowSize = cVector2f(32, 64);
const cVector2f kMappingButtonSize = cVector2f(1024, 320);

//-----------------------------------------

float gfContinueGameFadeOutTime = 6.f;

//-----------------------------------------

const cColor kSelectedColor = cColor(1.0 / 255.0, 1);
const cColor kDeselectedColor = cColor(1, 1);
const cColor kDisabledColor = cColor(100.0 / 255.0, 1);

//-----------------------------------------

const float gfMenuMainAlphaMax = 0.75;
const float gfTransisionFadeSpeed = 6.f;

//-----------------------------------------

class cBindableAction
{
	cBindableAction(){}
	cBindableAction(tString asAction, bool abAnalog = false)
	{
		msAction = asAction;
		mbAnalog = abAnalog;
	}

	tString msAction;
	bool mbAnalog;
};

//-----------------------------------------

class cGamepadControl
{

}

class cGamepadProfileLayoutData
{
	cVector3f mvReferencePos;
	cVector2f mvFrameSize;
	cVector2f mvControllerSize;
	float mfGfxHeight;
	float mfControllerAlpha;
	float mfEntrySeparation;

	cImGuiGfx mGfxController;
	array<cVector3f> mvControlGroupPositions;
	array<cColor> mvButtonColors;
}

//-----------------------------------------

///////////////
// MODS MENU
const bool gbCustomStoriesEnabled = true;

const cVector2f kModsBgSize = cVector2f(720, 575);
const cVector2f kModsBgPos = cVector2f(kOptionsBgPos.x - 70, kOptionsBgPos.y-210);
const float kModsSlotsSpacing = 26;
const int kMaxModsToShow = 14;

class cModEntryListState
{
	int mlListSize;
	int mlFirstVisibleEntryIndex;
	int mlFocusedEntryRelativeIndex;
	int mlLastVisibleEntryIndex;

	int GetFocusedEntryIndex() { return mlFirstVisibleEntryIndex + mlFocusedEntryRelativeIndex - 1; }
}

//-----------------------------------------

const cVector2f kOptionsGameModesBgSize = cVector2f(220, 400);
const cVector2f kOptionsDisplayDifficultySettingsBgSize = cVector2f(1100, 310);

//-----------------------------------------

const cVector2f kSaveSlotSelectionSpacing = cVector2f(256, 0);
const cVector2f kSaveGameEntrySpacing = cVector2f(0, 40);
const cVector2f kSaveSlotSelectionPos = cVector2f(115, 290);
const cVector2f kSaveSlotSelectionBgSize = cVector2f(600, 310);

//-----------------------------------------

const float gfGameModeSettings_FixedDistanceBetweenNameAndWidget = 400;

//-----------------------------------------

const tString[] gsSubtitlePreview_Henri = { "HenriClement", "Voices_global", "notes_diaryclement_part_2_001_henriclement_003" };
const tString[] gsSubtitlePreview_Lambert = { "AugustinLambert", "Voices_trenches", "comments_dialogue_takecover_001_augustinlambert_001" };
const tString[] gsSubtitlePreview_ClosedCaption = { "GeneralClosedCaptions", "Stalker_Break" };
	
//-----------------------------------------

/////////////////////////////////////////
// Last Time Playing Screen
class cLastTimeOnGameScreen
{
	cLastTimeOnGameScreen()
	{
		CleanUp();
	}
	
	void LoadingStarted()
	{
		mbLoading_Started = true;
	}
	void Start(const tString &in asEntry)
	{
		if(IsActive()) return;
		
		msEntry = asEntry;
		if(msEntry.length()>0)
		{
			msText = cLux_Translate("LastTimeOnGameText", asEntry);
			if(msText.length()==0)
			{
				msEntry = "";
			}
			else
			{
				@mpScriptImGui = cLux_CreateScriptImGui("LastTimeOnGame", true);
				
				cImGuiGfx defPointer();
				defPointer.mColor = cColor(0.0f,0.0f);
				
				mpScriptImGui.mpImGui.SetDefaultMouse(defPointer);
				mpScriptImGui.mpImGui.SetDefaultFont(cImGuiFont("default_small.fnt", cVector2f(17) ));
				mpScriptImGui.mpImGui.SetShowMouse(false);
				
				mbFontSizeNeedsAdjust = true;
				mfFontHeight = 26.0f;
				
				cVector2f vAspect = cGraphics_GetLowLevel().GetScreenSizeFloat();
				float fAspect = vAspect.x/vAspect.y;
																  							  
				//21:9
				if (fAspect >= 2.38f && fAspect < 2.42f)
				{
					mfFontHeight = 38.0f;
				}
									
				LoadScreen_SetForceBackground(true);
				
				mpScriptImGui.mpImGui.AddTimer("Enable", 0.5f);
			}
		}
		
		if(IsActive()==false)
		{
			cLux_GetSaveHandler().ContinueLoading(true);
					
			LoadScreen_SetForceBackground(false);
			
			CleanUp();
		}
	}
	
	void CleanUp()
	{
		msText = "";
		@mpScriptImGui = null;
		
		mbLoading_Started = false;
		mbLoading_LoadHeaderDone = false;
		mbLoading_LoadGameDone = false;
		mbLoading_LoadScreenHidden = false;
		mbDismiss = false;
		LoadScreen_SetForceBackground(false);
	}
	
	bool IsActive()
	{
		return mpScriptImGui !is null;
	}
	
	void Update(float afTimeStep)
	{
		if(mbLoading_Started==false)
			return;
			
		if(mbLoading_LoadHeaderDone==false)
		{
			mbLoading_LoadHeaderDone = cLux_GetSaveHandler().IsDoneLoadingHeader();
			if(mbLoading_LoadHeaderDone)
			{
				Start(cScript_GetGlobalVarString("LastTimeOnGameText"));
			}
		}
		
		if(IsActive()==false) return;
		
		cImGui @mpImGui = mpScriptImGui.mpImGui;
		
		////////////////////////////////////////////
		// So timers and stuff work
		mpImGui.Begin(afTimeStep);
		{
			////////////////////////////////////////
			// Check flags
			if(mbLoading_LoadGameDone==false)
			{
				mbLoading_LoadGameDone = cLux_GetSaveHandler().IsDoneLoadingSavedGame();
				
				if(mbLoading_LoadGameDone)
				{
					//cLux_AddDebugMessage("Saved game is done loading - waiting for loadscreen to go");
					
					//cLux_SetGamePaused(true);
				}
			}
			else if(mbLoading_LoadScreenHidden==false)
			{
				mbLoading_LoadScreenHidden = LoadScreen_IsVisible()==false;
								
				if(mbLoading_LoadScreenHidden)
				{
					//cLux_AddDebugMessage("Loadscreen gone - prompting to continue");
					
					mpImGui.SetStateFloat("PromptAlpha", 0.0f);
					mpImGui.FadeStateFloat("PromptAlpha", 1.0f, 0.5f);
				}					
			}
			else if(mbDismiss==false)
			{
				tString sKeyPress = cLux_GetInputHandler().GetLatestKeyPressed();
				if(sKeyPress.length()!=0)
				{
					mbDismiss = true;
					
					//cLux_AddDebugMessage("Dismissing");
					
					// Start fadeout
					mpImGui.FadeStateFloat("Alpha", 0.0, 0.25f);
					
					cLux_GetSaveHandler().StartLoadedGame();
					//cLux_SetGamePaused(false);
					
					cSoundEntry @pEntry = @cSound_GetEntry("loadscreen_background");
					if(pEntry !is null)
						pEntry.FadeOut(1.0f/3.0f);
				}
			}
			
			////////////////////////////////////
			// Check timers
			if(mpImGui.TimerOver("Enable"))
			{
				mpImGui.SetStateFloat("Alpha", 0.0f);
				mpImGui.FadeStateFloat("Alpha", 1.0f, 1.0f);
				Music_StopAll(2.0f);
                Sound_Stop("MenuBGNoise",2.0f);
				cSound_PlayGuiStream("loadscreen_background", true, 0.15f, cVector3f(0,0,0), eSoundEntryType_Safe);
				//cSound_GetEntry("loadscreen_background").FadeIn(0.15f, 1.0f/3.0f);
				//Music_PlayExt("loadscreen_background", true, 0.15f, 1.0f, 3.0f, 0.0f, eMusicPrio_BgAmb, true);
			}
			
			/////////////////////////////////////
			// Check fadings
			if(mpImGui.FadeOver("Alpha"))
			{
				if(mbDismiss)
				{
					CleanUp();
					return;
				}
				else
				{
					cLux_GetSaveHandler().ContinueLoading(false);
				}
			}
			
			/////////////////////////////////////////
			// Draw the screen
			{
				float fZ = 415.0f;
				float fBGZ = 401.15f;   // 400.9f is LoadHandler black bg, 401.1f is whatever and 401.5f is brain icon
				
				float fAlpha = mpImGui.GetStateFloat("Alpha");
								
				mpImGui.SetModColorMul(cColor(1,fAlpha));
				
				// Bottom layer : black
				cImGuiGfx gfxBlack;
				gfxBlack.mColor = cColor(0,1);
				mpImGui.DoImage(gfxBlack, ImGui_FullScreenPos(10.0f), ImGui_FullScreenSize());
				
				// Bottom layer overlay: loading screen background
				cImGuiGfx gfxBG("loadscreen_backdrop.dds", eImGuiGfx_Texture);
				cVector2f vGfxBGSize = GetRatioCorrectSizeByNrmWidth(gfxBG, 1.0f);
				
				mpImGui.SetAlignment(eImGuiAlign_CenterCenter);
				mpImGui.DoImage(gfxBG, NrmPos(0.5f, 0.5f, fBGZ), vGfxBGSize);
				
				// Last time played screenshot
				cImGuiGfx gfxScreenshot(msEntry, eImGuiGfx_Texture);
				cVector3f vGfxScreenshotPos = NrmPos(0.25f, 1.0f/7.0f, fZ);
				cVector2f vGfxScreenshotSize = GetRatioCorrectSizeByNrmWidth(gfxScreenshot, 0.5f);
				
				mpImGui.SetAlignment(eImGuiAlign_TopLeft);
				mpImGui.DoImage(gfxScreenshot, vGfxScreenshotPos, vGfxScreenshotSize);
				
				// Set loading bar position
				cLux_LoadScreenSetBarPosAndSize(cVector2f(vGfxScreenshotPos.x, vGfxScreenshotPos.y + vGfxScreenshotSize.y - 4.2f), cVector2f(vGfxScreenshotSize.x, 4.2f));

				cVector3f vLinePos = vGfxScreenshotPos;
				vLinePos.y += vGfxScreenshotSize.y + 15.0f;
				
				// Text data and setup
				cImGuiTextFrameData textFrameData;
				textFrameData.mbUseBackgroundGfx = false;
				textFrameData.mFont.SetFile(FontHandler_GetFont(eFontType_MainMenu, 56));
				textFrameData.mFont.mvSize = cVector2f(mfFontHeight);
				textFrameData.mFont.mColor = cColor(1,1);
				
				cVector3f vTextFramePos = vLinePos + cVector3f(15.0f,0,0);
				cVector2f vTextFrameSize(vGfxScreenshotPos.x + vGfxScreenshotSize.x - vTextFramePos.x, NrmSize(0.0f, 0.95f).y-vLinePos.y);
				
				if(mbFontSizeNeedsAdjust)
				{
					mbFontSizeNeedsAdjust = false;
					
					array<tWString> vLines;
					GetFontWordWrapRowsW(textFrameData.mFont, 1.0f, msText, vTextFrameSize.x, vLines);
					
					lNumMaxLines = int(cMath_Abs(vTextFrameSize.y/(mfFontHeight)));
					lNumLinesInText = vLines.length();
					
					if(lNumLinesInText>lNumMaxLines)
					{
						float fHeightIntervalStart = 0.0f;
						float fHeightIntervalEnd = mfFontHeight;
						float fHeightIntervalMid;
												
						while(lNumLinesInText!=lNumMaxLines)
						{
							fHeightIntervalMid = (fHeightIntervalStart+fHeightIntervalEnd)*0.5f;
							mfFontHeight = fHeightIntervalMid;
							
							textFrameData.mFont.mvSize = cVector2f(mfFontHeight);
							
							GetFontWordWrapRowsW(textFrameData.mFont, 1.0f, msText, vTextFrameSize.x, vLines);
						
							lNumMaxLines = int(cMath_Abs(vTextFrameSize.y/(mfFontHeight)));
							lNumLinesInText = vLines.length();
							
							if(lNumLinesInText<lNumMaxLines)
								fHeightIntervalStart = fHeightIntervalMid;
							else
								fHeightIntervalEnd = fHeightIntervalMid;
						}
					}
				}
				
				float fLineHeight = vTextFrameSize.y*0.65f;
				
				// Vertical line
				mpImGui.SetAlignment(eImGuiAlign_TopLeft);
				mpImGui.DrawLine(cVector2f(vLinePos.x, vLinePos.y+5.0f), cVector2f(vLinePos.x, vLinePos.y + fLineHeight), fZ, 5.0f, cColor(1, fAlpha));
								
				// Text frame
				mpImGui.DoTextFrame(msText, cVector2f(0), 0, 0, textFrameData, vTextFramePos, vTextFrameSize);
				
				if(mbLoading_LoadScreenHidden)
				{
					float fPromptAlpha = mpImGui.GetStateFloat("PromptAlpha");
					mpImGui.SetModColorMul(cColor(1,fAlpha*fPromptAlpha));
					
					cImGuiLabelData labelData;
					labelData.mFont.SetFile("sansation_medium.fnt");
					labelData.mFont.mvSize = cVector2f(28, 28);
					labelData.mFont.mColor = cColor(1,1);
					labelData.mFontAlign = eFontAlign_Center;
									
					gfxBlack.mColor.a = 0.75f;
					mpImGui.SetAlignment(eImGuiAlign_CenterCenter);
					mpImGui.DoImage(gfxBlack, NrmPos(0.5f, 0.5f, fZ+9.5f), NrmSize(1.0f, 0.0f) + cVector2f(0, labelData.mFont.mvSize.y*4.0f));
					
					mpImGui.DoLabel(cLux_Translate("LoadScreen", "PressToStart"), labelData, NrmPos(0.5f, 0.5f, fZ+10.0f));
				}
			}
		}
		mpImGui.End();
	}
	
	cVector3f NrmPos(float afX, float afY, float afZ)
	{
		cVector2f vOffset = mpScriptImGui.mpImGui.GetSet().GetVirtualSizeOffset();
		cVector2f vNrmSize = NrmSize(afX, afY);
		
		return cVector3f(vNrmSize.x-vOffset.x, vNrmSize.y-vOffset.y, afZ);
	}
	
	cVector2f NrmSize(float afX, float afY)
	{
		cVector2f vSize = mpScriptImGui.mpImGui.GetSet().GetVirtualSize();
		vSize.x *= afX;
		vSize.y *= afY;
		
		return vSize;
	}
	
	cVector2f GetRatioCorrectSizeByWidth(const cImGuiGfx &in aGfx, float afWidth)
	{
		cVector2f vGfxSize = mpScriptImGui.mpImGui.GetGfxSize(aGfx);
		if (vGfxSize.x==0)
		{
			vGfxSize.x=1;
			vGfxSize.y=1;
		}
		
		float fRatio = vGfxSize.y/vGfxSize.x;
		
		return cVector2f(afWidth, afWidth*fRatio);
	}

	cVector2f GetRatioCorrectSizeByNrmWidth(const cImGuiGfx &in aGfx, float afWidth)
	{
		return GetRatioCorrectSizeByWidth(aGfx, afWidth*mpScriptImGui.mpImGui.GetCurrentGroupSize().x);
	}

	cVector2f GetRatioCorrectSizeByHeight(const cImGuiGfx &in aGfx, float afHeight)
	{
		cVector2f vGfxSize = mpScriptImGui.mpImGui.GetGfxSize(aGfx);
		if (vGfxSize.x==0)
		{
			vGfxSize.x=1;
			vGfxSize.y=1;
		}
		
		float fRatio = vGfxSize.y/vGfxSize.x;
		
		return cVector2f(afHeight/fRatio, afHeight);
	}
	
	cLuxScriptImGui @mpScriptImGui;
	tString msEntry;
	tWString msText;
	
	bool mbFontSizeNeedsAdjust;
	float mfFontHeight;
	uint lNumMaxLines;
	uint lNumLinesInText;
		
	bool mbLoading_Started;
	bool mbLoading_LoadHeaderDone;
	bool mbLoading_LoadGameDone;
	bool mbLoading_LoadScreenHidden;
	bool mbDismiss;
};

cLastTimeOnGameScreen gLastTimeOnGameScreen;

//-----------------------------------------

///////////////////////////////
// Game Mode Screen
const int glCustomGameModeSettingsMaxInPage = 11;

enum eCustomSettingsChangesWillBeLost
{
	eCustomSettingsChangesWillBeLost_Default,
	eCustomSettingsChangesWillBeLost_BackBtn,
	eCustomSettingsChangesWillBeLost_Randomize,
	eCustomSettingsChangesWillBeLost_None
}

//-----------------------------------------

bool gbFirstRun = true;
float mfMenuMusicVol = 0.35f;
float mfMenuCompMusicVol = 0.6f;

class cScrMenuHandler : iScrUserModule, iScrUserModule_Interface, iScrMenuHandler_Interface
{
	
	//------------------------------------------------------------
	
	/////////////////////////////////////////
	// INIT
	/////////////////////////////////////////
	
	//------------------------------------------------------------
	
	void Init()
	{
		mBaseObj.SetScriptableIsSaved(false);
		
		////////////////////////////////////
		// Options background
		cColor topCol(0.6f, 1.0f);
		/*mGfxFrame.mGfxCornerTopRight = cImGuiGfx("menu_corner_tr.tga");
		mGfxFrame.mGfxBorderTop = cImGuiGfx("menu_border_top.tga");
		mGfxFrame.mGfxCornerTopLeft = cImGuiGfx("menu_corner_tl.tga");
		mGfxFrame.mGfxBorderLeft = cImGuiGfx("menu_border_left.tga");
		mGfxFrame.mGfxBorderRight = cImGuiGfx("menu_border_right.tga");
		mGfxFrame.mGfxCornerBottomLeft = cImGuiGfx("menu_corner_bl.tga");
		mGfxFrame.mGfxCornerBottomRight = cImGuiGfx("menu_corner_br.tga");
		mGfxFrame.mGfxBorderBottom = cImGuiGfx("menu_border_bottom.tga");
		mGfxFrame.mGfxBackground.mColor = cColor(5.0f/255.0f, 60.0f/255.0f, 72.0f/255.0f, 0.25f);
		
		mGfxFrame.mColorCornerTopLeft = topCol;
		mGfxFrame.mColorCornerTopRight = topCol;*/
	}
	
	//------------------------------------------------------------
	
	void LoadUserConfig()
	{
		//////////////////////////////////////////
		// Setup multi select options
		@mpConfig = cLux_GetUserConfig();
		@mpKeyConfig = cLux_GetKeyConfig();

		//////////////////////////////////////////
		// Load config
		mbShowPreMenu = mpConfig.GetBool("Main", "ShowPreMenu", true);
		mbFirstGameStart = mpConfig.GetBool("Main", "FirstGameStart", (mbShowPreMenu) ? true : false);
		Log("[MenuHandler] LoadUserConfig mbFirstGameStart = " + mbFirstGameStart + "\n");
		
		cConfigFile@ pStatsFile = cLux_GetStatsConfig();
		mbGameCompletedOnce = mpConfig.GetBool("Game", "GameCompletedOnce", false) || pStatsFile.GetBool("Game", "GameCompletedOnce", false);
		/////////////////////////////////////
		// We're moving this over to the stats config. make sure it doesn't break people's game.
		if (mbGameCompletedOnce && pStatsFile.GetBool("Game", "GameCompletedOnce", false)==false)
			pStatsFile.SetBool("Game", "GameCompletedOnce", true);
			
		mbGameCompletedMsgSeen = pStatsFile.GetBool("Game", "NewGamePlusMsgSeen", false);
	}
	
	//------------------------------------------------------------
	
	void SaveUserConfig()
	{
	}
	//------------------------------------------------------------
	
	/////////////////////////////////////////
	// INTERFACE
	/////////////////////////////////////////
	
	//------------------------------------------------------------
	
	void EnablePauseMenu(bool abX)
	{
		if(LoadScreen_IsVisible()) return;
	
		mbPauseMenuEnabled = abX;

		if(mbPauseMenuEnabled == false)
		{
			SetMenuActive(false);
		}
		else
		{
			tString sMapDisplayName = cLux_GetCurrentMap().GetDisplayNameEntry();
			if (sMapDisplayName != "main-menu")
			{
			GameStats_Save();
				cLux_AddDebugMessage("[MenuHandler] [EnablePauseMenu] Save Game Stats! Current Map: " +  sMapDisplayName);
			}
		}
	}

	void ShowMainMenu(bool abX)
	{
		SetMenuActive(abX);
		mbMainMenuActive = abX;
		cLux_SetGamePaused(false, false, false, false);
		
		cLux_AddDebugMessage("Show menu: "+abX);

		if(abX)
		{
			Sound_CreateAtEntity("MenuBGNoise", "special_fx/frontend/main_menu_bg", "Player", 6.0f, false, 1.0f);

			////////////////////////////////
			// Variable setup
			mbPremenuActive = (mbShowPreMenu || Platform_IsConsole()) && gbFirstRun;
			mbClearTimersNextFrame = true;

			// Clear suffix in main menu
			cLux_GetSaveHandler().SetSaveSuffix(cString_To16Char(""));

			if(mbPremenuActive)
			{
				mPreMenuPhase = ePreMenuPhase_Init;
				mlPreMenuState=0;
				mbInitPreMenu=true;
				
				mbBackgroundShowTitle = false;
				mfBackgroundTitleAlpha=0;
				
				mbMouseVisible = false;
				mbShowPressX = Platform_IsConsole() && Platform_IsStreaming() == false;
				gbFirstRun = false;
				
				if(cLux_ScriptDebugOn())
				{
					//gbFirstRun = true;
				}
				
				mfMainAlpha =0;
			}
			else
			{
				mbBackgroundShowTitle = true;
				mfBackgroundTitleAlpha=0;

				mbMouseVisible = true;
				mbShowPressX = false;

				mfMainAlpha = gfMenuMainAlphaMax;
			}

			if(mbShowPreMenu)
			{
				tString sLang = mpConfig.GetString("Main", "StartLanguage", cLux_GetDefaultGameLanguage());
				if((sLang == "english" || sLang == "english.lang") == false)
				{
					// TO DO: We discussed having subs on for every language
					mpConfig.SetBool("Sound", "ShowSubtitles", true);
				}
				else
				{
					// Set it to false if english
					mpConfig.SetBool("Sound", "ShowSubtitles", mpConfig.GetBool("Sound", "ShowSubtitles", false));
					
				}
			}

			mbBackgroundTitleSounds = true;
			
			/////////////
			//Music
			if(mbPauseMenuEnabled==false && mbPremenuActive==false)
			{
				//Music_PlayExt("Menu_Music", true, mfMenuMusicVol, 1.0f, 6.0f, 0.0f, eMusicPrio_OverrideAll, false);
				cLux_AddTodoMessage("Sound: Menu background noise");
				Sound_CreateAtEntity("MenuBGNoise", "special_fx/frontend/main_menu_bg", "Player", 6.0f, false, 1.0f);
			}
				
						
			/////////////
			// If save files have not been checked, focus is set when that happens
			if(mbHasSaveFiles)
				msFocusNextFrame = mbCanContinue ? "Continue" : "NewGame";
		}
	}
	
	//------------------------------------------------------- 
	
	bool mbStartFocusNotSet = false;
	
	void SetMenuActive(bool abX)
	{
		//Log("****************\n****************\n SET MENU ACTIVE: "+ abX + "\n");
		cLux_SetGamePaused(abX, true, true, true);
		mbMenuActive = abX;

		if(mbMenuActive == false)
		{
			/////////////
			// Restore mouse input
			cLux_GetGuiHandler().SetGameHudInputFocus(false);
		}
		else
		{
			cLux_GetGuiHandler().SetGameHudInputFocus(true);
		}
		
		mbShowGameCompleted = false;
		mbShowGameCompleted_02 = false;
		mbShowGameCompleted_03 = false;
		mbShowRestartWarning = false;
		mbShowApplyChanges = false;
		mbShowApplyKeyChanges = false;
		mbShowReset = false;
		mbShowExit = false;
		mbShowPlayGo = false;
		mbShowNewGame = false;
		mbShowSkipIntro = false;
		mbShowCustomSettingsChangesWillBeLost = false;
		mlCustomSettingsChangesWillBeLost = eCustomSettingsChangesWillBeLost_None;
		mbShowOverwriteSaveSlot = false;
		mbShowLoadGame = false;
		mbShowDuplicateKeys = false;
		mbShowPressX = false;
		mbPremenuActive = false;
		mbHasSaveFiles = false;
		mbShowNewGamePlusPopUpMsg = false;
		mbShowNewGamePlusSettingPopUp = false;
		mlActionToBind= 0;

		if(abX)
		{
			tString sMapDisplayName = cLux_GetCurrentMap().GetDisplayNameEntry();
			if (sMapDisplayName != "main-menu")
			{
				GameStats_Save();
				cLux_AddDebugMessage("[MenuHandler] [SetMenuActive] Save Game Stats! Current Map: " +  sMapDisplayName);
			}
			
			mbClearTimersNextFrame = true;
			msFocusNextFrame = "ReturnToGame";
		
			mlClickedPauseMenuButton = -1;
			mlClickedMainMenuButton = -1;

			mCurrentGroup = eMainMenuGroup_Main;
		}
	}
	
	//------------------------------------------------------- 
	
	bool GetMenuActive()
	{
		return mbMenuActive;
	}
	
	//------------------------------------------------------- 
	
	bool GetMainMenuVisible()
	{
		return mbMainMenuActive && !mbPremenuActive;
	}
	
	//------------------------------------------------------- 
		
	void GameOver()
	{
		mbGameOver = true;
		EnablePauseMenu(false);
		ShowMainMenu(true);
	}
	
	//------------------------------------------------------- 
	
	void SetMainMenuSketchbookSketch(const tString& in asSketch)
	{
		/*msMenuSketchbookSketch = asSketch;
		
		mpConfig.SetString("Game", "MenuSketchbookSketch", asSketch);
		mpConfig.Save();*/
	}
	
	//------------------------------------------------------- 
	
	void SetMainMenuGhoulPhase(int alPhase)
	{
		//TODO: Nuke this. 
	}
	
	//------------------------------------------------------- 
	
	void SetMainMenuItemsPhase(eMainMenuPhase_Items aPhase)
	{
		//TODO: Nuke this too. 
	}
	
	void SetSaveLoadEnabled(bool abX)
	{
		cLux_AddDebugMessage("SetSaveLoadEnabled "+abX);
		mbSaveLoadEnabled = abX;
	}

	//------------------------------------------------------------
	
	/////////////////////////////////////////
	//MAP LOADING
	/////////////////////////////////////////
	
	//------------------------------------------------------------
	
	void Initiate(cLuxMap @apMap)
	{
		mbMainMenuActive = false;
		mbPauseMenuEnabled = true;
		msSelectedAudioButton = "Volume";
		msSelectedVideoButton = "Resolution";
		msSelectedInputButton = "Keybind";
		msSelectedInputMouseButton = "MouseSens";
		msSelectedInputGamepadButton = "GamepadMapping";
		msSelectedOptionsButton = "Options_Game";
		msSelectedDebugButton = "Profiler";
		msSelectedPauseMenuButton = "ReturnToGame";
		msSelectedGammaButton = "Gamma";
		msSelectedVideoWorldButton ="TextureQuality"; 
		msSelectedDisplayButton ="Resolution";
		msSelectedGraphicsButton ="Graphics";
		msSelectedGameplayButton = "Language";
		msSelectedVideoGammaButton = "Gamma";
		msSelectedAccessibilityButton = "HearingAid";
		msSelectedAccessibilityGameButton = "AimAssist";
		msSelectedAccessibilityInputButton = "PhysicsInteractionMode";
		msFocusNextFrame = "";
	
		mfFadeOut = 0.0f;

		if(apMap.GetName() == "main_menu")
		{
			mfFadeIn = 1.0;
		}

		mbMenuActive = false;

		//////////////////////////////////////////
		// Setup multi select options
		@mpConfig = cLux_GetUserConfig();
		@mpKeyConfig = cLux_GetKeyConfig();

		//////////////////////////////////////////
		// Load config
		mbShowPreMenu = mpConfig.GetBool("Main", "ShowPreMenu", true);
		mbFirstGameStart = mpConfig.GetBool("Main", "FirstGameStart", (mbShowPreMenu) ? true : false);
		Log("[MenuHandler] Initiate mbFirstGameStart = " + mbFirstGameStart + "\n");
		
		cConfigFile@ pStatsFile = cLux_GetStatsConfig();
		mbGameCompletedOnce = mpConfig.GetBool("Game", "GameCompletedOnce", false) || pStatsFile.GetBool("Game", "GameCompletedOnce", false);
		mbGameCompletedMsgSeen = pStatsFile.GetBool("Game", "NewGamePlusMsgSeen", false);
		mbNewGamePlus = mbGameCompletedOnce;
		
		//////////////////////////////////////////
		// Setup resolutions
		mvResolutionValues.resize(0);
		mvResolutionSizes.resize(0);
		array<int> vBits;
		mvRefresh.resize(0);

		cSystem_GetAvailableVideoModes(mvResolutionSizes, vBits, mvRefresh, 32, 15, true);

		for(uint i = 0; i < mvResolutionSizes.size(); ++i)
		{
			mvResolutionValues.push_back(""+mvResolutionSizes[i].x + "x"+mvResolutionSizes[i].y);
		}
		
		mlCurrentResolution = GetCurrentResolution();
		
		//////////////////////////////////////////
		// Setup custom refresh rates to pick from
		array<int> kvRefreshRates = { 15,30,60,120 };
		mvRefresh = kvRefreshRates;
		mvRefreshValues.resize(0);

		for(uint i = 0; i < mvRefresh.size(); ++i)
		{
			mvRefreshValues.push_back(""+mvRefresh[i] + " FPS");
		}

		if(mvLangFiles.size() == 0)
		{
			//////////////
			// Get lang files
			mvLangFiles.push_back("brazilian_portuguese");
			mvLangFiles.push_back("english");
			mvLangFiles.push_back("french");
			mvLangFiles.push_back("german");
			mvLangFiles.push_back("italian");
			mvLangFiles.push_back("russian");
			mvLangFiles.push_back("spanish");

			//if(Platform_IsConsole() == false)
				mvLangFiles.push_back("simplified_chinese");
		}

		/////////////////////
		// Actions
		array<cBindableAction> vActions = 
		{
			cBindableAction("Forward"),
			cBindableAction("Backward"),
			cBindableAction("Left"),
			cBindableAction("Right"),
			cBindableAction("Jump"),
			cBindableAction("Crouch"),
			cBindableAction("Run"),
			cBindableAction("LeanRight"),
			cBindableAction("LeanLeft"),
			cBindableAction("Interact"),
			cBindableAction("InteractCancel"),
			cBindableAction("InteractRotate"),
			cBindableAction("Flashlight"),
			cBindableAction("CheckAmmo"),
			cBindableAction("GasMask"),
			cBindableAction("Throw"),
			cBindableAction("OpenInventory"),
			cBindableAction("ShowText"),
			cBindableAction("AimGun"),
			cBindableAction("HolsterEquip")
		};

		mvActions = vActions;
		
		array<cBindableAction> vGamepadActions = 
		{
			cBindableAction("GamepadMove", true),
			cBindableAction("GamepadLook", true),
			cBindableAction("Jump"),
			cBindableAction("Crouch"),
			cBindableAction("Run"),
			cBindableAction("OpenInventory"),
			cBindableAction("Interact"),
			cBindableAction("Flashlight"),
			cBindableAction("InteractCancel"),
			cBindableAction("AnalogLean"),
			cBindableAction("Throw"),
			cBindableAction("GamepadRotateUp"),
			cBindableAction("GamepadRotateDown"),
			cBindableAction("GamepadRotateLeft"),
			cBindableAction("GamepadRotateRight"),
			cBindableAction("MenuConfirm"),
			cBindableAction("MenuCancel"),
			cBindableAction("MenuUp"),
			cBindableAction("MenuDown"),
			cBindableAction("MenuLeft"),
			cBindableAction("MenuRight"),
			cBindableAction("MenuScrollUp"),
			cBindableAction("MenuScrollDown"),
			cBindableAction("GamepadBack"),
			cBindableAction("OpenMenu")
		};
		mvGamepadActions = vGamepadActions;

		mbInitiated = true;
		cLux_AddDebugMessage("[MainMenuModule] Successfully Initiated");
	}

	void OnMapEnter(cLuxMap @apMap)
	{
		Initiate(apMap);
		mbSavingGame = false;
		
		GameDifficulty_GetSettingsDisplayData(mvCustomSettings_Ids, mvCustomSettings_Names, mvCustomSettings_ControlTypes, mvCustomSettings_ValueList, mvReliesOn_SettingID, mvReliesOn_DisablingValueIDs, mvCustomSettings_Active);
			
		Achievement_CheckPlatinum();
	}

	void OnMapLeave(cLuxMap @apMap)
	{
		mbPauseMenuEnabled = true;
		mbShowPressX = false;
		mbPremenuActive = false;
		mbSavingGame = false;
	}
	
	//------------------------------------------------------------
	
	void PreloadData(cLuxMap@ apMap)
	{
		//////////////////////////
		// Preload textures
		ImGui_PreloadImage("startmenu_title_1k.dds", eImGuiGfx_Texture);
		ImGui_PreloadImage("startmenu_bg.dds", eImGuiGfx_Texture);
		ImGui_PreloadImage("startmenu_vignette.dds", eImGuiGfx_Texture);
		
		ImGui_PreloadImage(Platform_IsPlayStation() ? "startmenu_button_x" : "startmenu_button_xbox_A", eImGuiGfx_Image); 
		ImGui_PreloadImage(Platform_IsPlayStation() ? "startmenu_button_circle" : "startmenu_button_xbox_B", eImGuiGfx_Image);
		ImGui_PreloadImage("startmenu_button_direction2", eImGuiGfx_Image);
	}
	
	void CreateWorldEntities(cLuxMap @apMap)
	{
	
	}
	void DestroyWorldEntities(cLuxMap @apMap)
	{
	
	}
	
	//------------------------------------------------------------
	
	/////////////////////////////////////////
	// GENERAL
	/////////////////////////////////////////
	
	//------------------------------------------------------------
	
	void OnEnterContainer(const tString&in asOldContainer)
	{
	
	}
	void OnLeaveContainer(const tString&in asNewContainer)
	{
	
	}
	
	//------------------------------------------------------------
	
	void Update(float afTimeStep)
	{
	}
	
	void PostUpdate(float afTimeStep)
	{
	}
	
	void Reset()
	{
	}
	void VariableUpdate(float afDeltaTime)
	{
	}

	//------------------------------------------------------------
	
	/////////////////////////////////////////
	// ACTIONS
	/////////////////////////////////////////
	
	//------------------------------------------------------------
	
	void OnGui(float afTimeStep)
	{
		//cLux_AddDebugMessage("SELECTED: "+msSelectedOptionsButton);
		if(mbInitiated == false && cLux_GetCurrentMap() !is null)
		{
			Initiate(cLux_GetCurrentMap());
		}

		if(mbClearTimersNextFrame)
		{
			///////////////
			// Make sure timers arent saved
			ImGui_StopTimer("NewGameTimer");
			ImGui_StopTimer("ExitToMainMenu");
			ImGui_StopTimer("ExitGame");
			ImGui_StopTimer("TrainingGrounds");

			mbClearTimersNextFrame = false;
		}
		
		///////////////////////////////////
		// Display ScriptDebug ON message, to ease confusion
		if(cLux_ScriptDebugOn() && cLux_HideDebugOutputOn()==false)
		{
			cVector3f vPos;
			vPos.x = -cLux_GetHudVirtualOffset().x;
			vPos.y = -cLux_GetHudVirtualOffset().y;
			vPos.z = 0.0f;
			vPos.z = 0;
			
			ImGui_SetTransCategory("");
			
			ImGui_GroupBegin(vPos, ImGui_GetSize());
				
			cImGuiLabelData labelData;
			labelData.mColorBase = cColor(1.0f,0.3f,1.0f);
			ImGui_DoLabelExt("ScriptDebug ON", labelData, cVector3f(5.0f,ImGui_GetSize().y-20.0f,100.0f), -1,1.0f);
			ImGui_GroupEnd();
		}

		if(cLux_GetCurrentMap() !is null)
		{
			//////////////////////////////////
			// Check for load save error
			tString sError;
			if(cLux_GetSaveHandler().HasLoadError(sError))
			{
				msLoadSaveError = sError;
				mbProfileError = false;
				LoadScreen_SetForceBackground(false);
			
				if(mbMenuActive == false) 
				{
					if(mbMainMenuActive)
						ShowMainMenu(true);
					else
						SetMenuActive(true);
				}

				if(msLoadSaveError == "NoSpace")
					msLoadSaveError = ""; //solved on a OS level
				
				if(msLoadSaveError == "PlayGo")
				{
					mbShowPlayGo = true;
					msLoadSaveError = "";
				}
			}

			if(cLux_HasConfigLoadError(sError))
			{
				msLoadSaveError = sError;
				mbProfileError = true;
			
				if(mbMenuActive == false) 
				{
					if(mbMainMenuActive)
						ShowMainMenu(true);
					else
						SetMenuActive(true);
				}
			}
		}
		
		//////////////////////////////////////
		// Last time playing screen handling
		gLastTimeOnGameScreen.Update(afTimeStep);
		
		if(gLastTimeOnGameScreen.IsActive() || mbMenuActive == false) 
			return;

		if(mbHasSaveFiles == false)
		{
			cLux_AddDebugMessage("[Menu Handler] Checking for save files...");
			mvSaveSlots.resize(0);
			for (int i=0; i<3; i++)
			{
				cSaveSlot saveSlot;
				saveSlot.mlId = i+1;
				mvSaveSlots.push_back(saveSlot);
			}
			
			mvSaveNames.resize(0);
			mvSaveDates.resize(0);
			mvSaveFiles.resize(0);
			mvSaveSuffix.resize(0);
			mvSaveModeSuffix.resize(0);

			array<tWString> vTempSuffix;
			
			/////////////////////////
			// Check save files, (happens once)
			if(cLux_GetSaveHandler().GetSaveFiles(mvSaveNames, mvSaveDates, mvSaveFiles, vTempSuffix))
			{
				mbHasSaveFiles = true;

				// Process suffix
				for(int i = 0; i < vTempSuffix.size(); ++i)
				{
					array<tWString> vSuffixArray;
					cString_GetStringVecW(vTempSuffix[i], vSuffixArray, cString_To16Char("-"));

					if(vSuffixArray.size() > 1)
					{
						mvSaveSuffix.push_back(vSuffixArray[0]);
						mvSaveModeSuffix.push_back(vSuffixArray[1]);
					}
					else
					{
						mvSaveSuffix.push_back(vTempSuffix[i]);
						mvSaveModeSuffix.push_back(cString_To16Char(""));
					}
				}
				
				cLux_AddDebugMessage("[Menu Handler] " + mvSaveFiles.size() + " save files found in total.");
				
				mbCanContinue = mvSaveFiles.size() > 0;
				
				if(mbCanContinue)
				{
					cLux_AddDebugMessage("[Menu Handler] Start grouping save files in save slots.");
					
					for(uint i = 0; i < mvSaveFiles.size(); ++i)
					{
						//////////////////////
						// Ignore checkPoints
						if(cString_GetFirstStringPosW(mvSaveNames[i], tWString("CheckPoint")) != -1)
						{
							for(int j = i + 1; j < mvSaveFiles.size(); ++j)
							{
								mvSaveFiles[j-1] = mvSaveFiles[j];
								mvSaveDates[j-1] = mvSaveDates[j];
								mvSaveNames[j-1] = mvSaveNames[j];	
								mvSaveSuffix[j-1] = mvSaveSuffix[j];
								mvSaveModeSuffix[j-1] = mvSaveModeSuffix[j];
							}
					
							mvSaveFiles.resize(mvSaveFiles.size()-1);
							mvSaveDates.resize(mvSaveDates.size()-1);
							mvSaveNames.resize(mvSaveNames.size()-1);
							mvSaveSuffix.resize(mvSaveSuffix.size()-1);
							mvSaveModeSuffix.resize(mvSaveModeSuffix.size()-1);
							
							//////////////
							// Skip adding into a save slot
							continue;
						}
						
						/////////////////////////////////
						// Group save files under save slots. This is only to display them properly in the loading menu.
						// TODO: Ideally the rest of the loading saves system should work based on these per save slot arrays too. Good to do so if time but not a prio. 
						int lSuffix = cString_GetNumericSuffixIntW(mvSaveSuffix[i]);
						
						/////////////////////////
						// Create a save file reference
						cSaveFile saveFile;
						saveFile.msSaveName = mvSaveNames[i];
						saveFile.msSaveDate = mvSaveDates[i];
						saveFile.msSaveFile = mvSaveFiles[i];
						saveFile.msSaveSuffix = mvSaveSuffix[i];
						saveFile.mlGameMode = mvSaveModeSuffix[i].length() > 0 ? cString_GetNumericSuffixIntW(mvSaveModeSuffix[i]) : 1;
						
						/////////////////////////
						// Check if a save slot with the related ID already exists to add the save file in it
						//bool bAddNewSaveSlot = true;
						for(uint k = 0; k < mvSaveSlots.size(); ++k)
						{
							cSaveSlot@ pSaveSlot = mvSaveSlots[k];
							if (pSaveSlot is null) continue;
							if (lSuffix != pSaveSlot.mlId) continue;
							
							pSaveSlot.mvSlotSaveFiles.push_back(saveFile);
							//bAddNewSaveSlot = false;
							cLux_AddDebugMessage("[Menu Handler] Save File " + cString_To8Char(mvSaveFiles[i]) + " was added to existing save slot with ID " + pSaveSlot.mlId);
							break;
						}
						
						//////////////////////////
						// Else add a new save slot and add the save ereference in it
						/*if (bAddNewSaveSlot)
						{
							cSaveSlot saveSlot;
							saveSlot.mlId = lSuffix;
							saveSlot.mvSlotSaveFiles.push_back(saveFile);
							mvSaveSlots.push_back(saveSlot);
							cLux_AddDebugMessage("[Menu Handler] A new save slot with ID " + saveSlot.mlId + " was created and the save file: " + cString_To8Char(mvSaveFiles[i]) + " was added in it");
						}*/
					}


					array<tWString> vSuffixArray;
					cString_GetStringVecW(cLux_GetSaveHandler().GetSaveSuffix(), vSuffixArray, cString_To16Char("-"));
					cLux_AddDebugMessage("Save suffix: ");
					cLux_AddDebugMessage(cString_To8Char(cLux_GetSaveHandler().GetSaveSuffix()));

					if(vSuffixArray.size() > 1)
					{
						// HAS SAVE SUFFIX = PAUSE MENU

						mlSelectedSaveSlot = cString_GetNumericSuffixIntW(vSuffixArray[0]);
						mlSelectedGameMode = cString_GetNumericSuffixIntW(vSuffixArray[1]);
						
						mbCanContinue = false;
						
						int lSuffix = mlSelectedSaveSlot;

						for(uint k = 0; k < mvSaveSlots.size(); ++k)
						{
							cSaveSlot@ pSaveSlot = mvSaveSlots[k];
							if (pSaveSlot is null) continue;
							if (lSuffix != pSaveSlot.mlId) continue;
							if(pSaveSlot.mvSlotSaveFiles.size() == 0) continue;
							
							mbCanContinue = true;
							msContinueFile = pSaveSlot.mvSlotSaveFiles[0].msSaveFile;
							
							break;
						}
					}
					else
					{
						// NO SAVE SUFFIX = MAIN MENU
						msContinueFile = mvSaveFiles[0];
						mlSelectedSaveSlot = cString_GetNumericSuffixIntW(mvSaveSuffix[0]);
						mlSelectedGameMode = cString_GetNumericSuffixIntW(mvSaveModeSuffix[0]);
					}
				}

				cLux_AddDebugMessage("ContinueFile: " + cString_To8Char(msContinueFile));
				cLux_AddDebugMessage("SelectedSaveSlot: " + mlSelectedSaveSlot);
				cLux_AddDebugMessage("SelectedGameMode: " + mlSelectedGameMode);

				//////////////////
				// Set ui focus here
				msFocusNextFrame = mbCanContinue ? "Continue" : "NewGame";

			}
			
			////////////////////////////////////////
			// Don't let menu continue until saves have been checked
			else
			{
				return;
			}
		}
		
		/////////////////////////
		// Show game completed msg
		if (mbPremenuActive==false && mbGameCompletedOnce && mbGameCompletedMsgSeen==false)
		{
			mbShowGameCompleted = true;
			msFocusNextFrame = "Next";
		}
		
		//////////////////////////////////
		// Main alpha
		if(mbPremenuActive)
			mfMainAlpha = cMath_IncreaseTo(mfMainAlpha, afTimeStep*0.5f, 0.0f);
		else
			mfMainAlpha = cMath_IncreaseTo(mfMainAlpha, afTimeStep*0.5f, gfMenuMainAlphaMax);

		/////////////////////////////////////
		//Renders a in game mouse pointer.
		cImGuiGfx mouseGfx("imgui_pointer_normal.tga");
		mouseGfx.mColor = cColor_White;
		if(ImGui_GetMouseVisible() && mbMouseVisible)
			ImGui_DoMouse(mouseGfx, cVector3f_Zero, cVector2f(27, 36));
		
		/////////////////////////////////////
		//Setup Properties
		cGuiSet@ pSet = cLux_GetCurrentImGui().GetSet();
		mvSize = pSet.GetVirtualSize();
		mvOffset = pSet.GetVirtualSizeOffset();
		mvAspectRatio = cGraphics_GetLowLevel().GetScreenSizeFloat();
		mvAspectRatio /= mvAspectRatio.y;
		mlActionHorizontal = 0;
				
		ImGui_SetTransCategory("Menu");

		@mpConfig = cLux_GetUserConfig();
		@mpKeyConfig = cLux_GetKeyConfig();
		
		if (mbPauseSoundDelay)
		{
			ImGui_AddTimer("PauseSfx", 0.05f);
			mbPauseSoundDelay = false;
		}
		
		if(ImGui_TimerOver("PauseSfx")) 
		{
			Sound_PlayGui("special_fx/frontend/pause", 1.0f, eSoundEntryType_Gui);
		}
		
		
		/////////////////////////////////////
		//Set frame focus
		if(msFocusNextFrame != "")
		{
			//////////
			// Setup focus when changing groups
			ImGui_SetFocus(msFocusNextFrame);
			msFocusNextFrame = "";
		}
		
		/////////////////////////////////////
		// MainMenu-Button Press Check
		if(mbMenuButtonPressed && mbPremenuActive == false && mbShowPressX == false)
		{
			mbMenuButtonPressed = false;
			if(mCurrentGroup == eMainMenuGroup_Main 
				&& ((mbShowApplyChanges || mbShowApplyKeyChanges || mbShowDuplicateKeys || mbShowReset
				||  mbShowRestartWarning || mbShowExit || mbShowPlayGo || mbShowNewGame || mbShowGameCompleted 
				|| mbShowGameCompleted_02 || mbShowGameCompleted_03 || mbShowSkipIntro || mbShowCustomSettingsChangesWillBeLost 
				|| mbShowOverwriteSaveSlot || mbShowNewGamePlusPopUpMsg || mbShowLoadGame || mbShowNewGamePlusSettingPopUp
				|| mbShowSelectedModDialog || mfKeepDisplaySetting > 0 || mlActionToBind > 0) == false))
			{
				///////////////
				// Disable menu
				if(mbMainMenuActive == false)
				{
					SetMenuActive(false);
					return;
				}
			}
			//////////////////////
			// Map menu button to back button
			else
			{
				cLux_GetCurrentImGui().SendAction(eImGuiAction_Cancel, true, true);
			}
		}
		mbMenuButtonPressed = false;
		
		//////////////////////////////////////////////
		// Message box
		if(	mbShowApplyChanges || mbShowDuplicateKeys || 
			mbShowApplyKeyChanges || mbShowReset || 
			mbShowRestartWarning || mbShowExit || mbShowPlayGo ||
			mbShowNewGame || mbShowSkipIntro || mbShowCustomSettingsChangesWillBeLost || mbShowOverwriteSaveSlot 
			|| mbShowLoadGame || mbShowSelectedModDialog || mbShowNewGamePlusPopUpMsg || mbShowNewGamePlusSettingPopUp ||
			mbShowDetectSettings || mbShowGameCompleted ||  mbShowGameCompleted_02 || mbShowGameCompleted_03 || 
			mfKeepDisplaySetting > 0 || mlActionToBind > 0 || 
			(msLoadSaveError.length() > 0 && mbPremenuActive == false))
		{
			////////////////
			// Display message box and disable input for any other widgets
			ShowMessageBoxes();
			ImGui_SetModUseInput(false); 
		}
		///////////////
		// Catch left and right input
		else
		{
			float fStartingTimer = 0.35f;
			float fFinalTimer = 0.25;
			float fTimerReductionFactor = 0.8f;
			
			{
				if(ImGui_ActionTriggered(eImGuiAction_Right, true))
				{
					mlActionHorizontal++;
					
					ImGui_SetStateFloat("HoriPressTimer", fStartingTimer);
					ImGui_AddTimer("RightPressed", fStartingTimer);
				}
							
				if(ImGui_ActionTriggered(eImGuiAction_Left, true))
				{
					mlActionHorizontal--;
					
					ImGui_SetStateFloat("HoriPressTimer", fStartingTimer);
					ImGui_AddTimer("LeftPressed", fStartingTimer);
				}
			}
			
			if(ImGui_TimerExists("RightPressed"))
			{
				if(ImGui_ActionIsDown(eImGuiAction_Right)==false)
				{
					ImGui_StopTimer("RightPressed");
				}
				else
				{
					if(ImGui_TimerOver("RightPressed"))
					{
						mlActionHorizontal++;
						
						float fTimer = ImGui_GetStateFloat("HoriPressTimer");
						fTimer *= fTimerReductionFactor;
						if(fTimer<fFinalTimer)
							fTimer = fFinalTimer;

						ImGui_SetStateFloat("HoriPressTimer", fTimer);
						ImGui_AddTimer("RightPressed", fTimer);
					}
				}
			}
			
			if(ImGui_TimerExists("LeftPressed"))
			{
				if(ImGui_ActionIsDown(eImGuiAction_Left)==false)
					ImGui_StopTimer("LeftPressed");
				else
				{
					if(ImGui_TimerOver("LeftPressed"))
					{
						mlActionHorizontal--;
						
						float fTimer = ImGui_GetStateFloat("HoriPressTimer");
						fTimer *= fTimerReductionFactor;
						if(fTimer<fFinalTimer)
							fTimer = fFinalTimer;

						ImGui_SetStateFloat("HoriPressTimer", fTimer);
						
						ImGui_AddTimer("LeftPressed", fTimer);
					}
				}
			}
			
			ImGui_SetModUseInput(true); 
		}

		///////////////
		// Applying key config might cause actions to fire again, so ignore them
		if(mlIgnoreInput > 0)
		{
			mlIgnoreInput--;
			ImGui_SetModUseInput(false);
			ImGui_ActionTriggered(eImGuiAction_Cancel, true);
		}
		
		///////////////////////////
		// Draw game Logo
		if(mbMainMenuActive)
		{
			//////////////////////////////////////
			// Title alpha
			if(mbBackgroundShowTitle)
			{
				mfAlphaEasingValue = cMath_IncreaseTo(mfAlphaEasingValue,0.01f,1);
				mfBackgroundTitleAlpha = cMath_Easing(eEasing_SineInOut, mfAlphaEasingValue, 0, 1);
			}
			else
			{
				mfAlphaEasingValue = cMath_IncreaseTo(mfAlphaEasingValue,0.05f,0);
				mfBackgroundTitleAlpha = cMath_Easing(eEasing_SineInOut, mfAlphaEasingValue, 0, 1);
			}
			
			/////////////////////////////////////
			//Title
			if(mfBackgroundTitleAlpha>0)
			{
				cImGuiGfx gfxMainTitle("startmenu_title_1k.dds", eImGuiGfx_Texture);
				cColor colorMul1(1, mfBackgroundTitleAlpha);
				cColor titleCol1 = ImGui_GetStateColor("TitleColor", cColor(1.0, 1.0));	
				ImGui_DrawGfx(gfxMainTitle, OptionMenu_GetTopLeftOffset(kTitlePos, -20), OptionMenu_GetScaledSize(kTitleSize), titleCol1*colorMul1);
			}

			/////////////////////////////////////
			//Mod flag
			if(cLux_GetModHandler().GetIsRunningMod())
			{
				cImGuiLabelData txtLabel;
				txtLabel.mbUseBackgroundGfx = false;
				txtLabel.mFont.mvSize = 18;
				txtLabel.mFont.mColor = cColor(1.0, mfTransitionAlpha) * gOptionMenu_ModColor;
				txtLabel.mFont.SetFile(FontHandler_GetFont(eFontType_MainMenu_InfoBox, 56));
				txtLabel.mFontAlign = eFontAlign_Right;
				tString sCurrentCat = ImGui_GetTransCategory();

				cVector2f vOffset(-20, 20);

				tWString sAccountName = cLux_GetUsersHandler().GetCurrentUser();
				if (sAccountName.length() > 0)
				{
					vOffset.y += 28 + 10;
				}

				ImGui_SetTransCategory("");
				ImGui_DoLabelExt("Running modded game", txtLabel, OptionMenu_GetTopRightOffset(vOffset, 20), 1.f);
				ImGui_SetTransCategory(sCurrentCat);
			}
		}
		
		///////////////////////////////////////////////////////
		// Fade screen and execute action
		if(	ImGui_TimerExists("NewGameTimer") || 
			ImGui_TimerExists("Continue") ||
			ImGui_TimerExists("TrainingGrounds") ||
			ImGui_TimerExists("LoadGame") ||
			ImGui_TimerExists("ExitToMainMenu") ||
			ImGui_TimerExists("ExitGame"))
		{
			/////////////
			// Fade to black
			if(ImGui_TimerExists("ExitGame"))
				mfFadeOut += afTimeStep / mfExitGameFadeLength;
			else
				mfFadeOut += afTimeStep / mfFadeLength;
			
			if(mfFadeOut>1) mfFadeOut=1;
				
			cImGuiGfx gfx;
			ImGui_DrawGfx(gfx, ImGui_FullScreenPos(40.0), ImGui_FullScreenSize(), cColor(0, mfFadeOut));
			ImGui_SetModUseInput(false); 

			///////////////////////////
			// Action: New Game
			if(ImGui_TimerOver("NewGameTimer"))
			{
				ImGui_StopTimer("NewGameTimer");
				//mbWelcomeScreen = true;
				//SetMenuActive(false);
				//mbGameOver = false;
				//msPreviousSaveLoaded = "";
				StartNewGame();
				
				return;
			}
			
			///////////////////////////
			// Action: Continue
			if(ImGui_TimerOver("Continue"))
			{
				ImGui_StopTimer("Continue");
				StartSavedGameLoad(msContinueFile);
				
				return;
			}
			
			///////////////////////////
			// Action: Training Grounds
			if(ImGui_TimerOver("TrainingGrounds"))
			{
				ImGui_StopTimer("TrainingGrounds");
				cLux_StartMap("training_grounds.hpm");
				
				cLux_GetEffectHandler().FadeOut(0.0);
					
				return;
			}

			///////////////////////////
			// Action: Load Game
			if(ImGui_TimerOver("LoadGame"))
			{
				ImGui_StopTimer("LoadGame");
				StartSavedGameLoad(msSaveFileToLoad);
								
				return;
			}
			
			///////////////////////////
			// Action: Exit To Main menu
			if(ImGui_TimerOver("ExitToMainMenu"))
			{
					
				ImGui_StopTimer("ExitToMainMenu");
				mbGameOver = false;
				cLux_GetEffectHandler().FadeOut(0.0);
				
				cLux_StartMap(cLux_GetMainMenuFile());
				msPreviousSaveLoaded = "";
				
				UpdateMainMenuStage();
				
				SetMenuActive(false);
				cLux_LoadScreenSetOneShotSolidColorBackground();
				
				return;
			}
			
			if(ImGui_TimerOver("ExitGame"))
			{			
				ImGui_StopTimer("ExitGame");
				mbGameOver = false;
				cLux_GetEffectHandler().FadeOut(0.0);
				
				UpdateMainMenuStage();
				
				SetMenuActive(false);
				cLux_Exit();
				
				return;
			}
		}
		/////////////
		// Set focus back to this set!
		else
		{
			if(cLux_GetGuiHandler().GetGameHudInputFocus() == false)
			{
				cLux_GetGuiHandler().SetGameHudInputFocus(true);
			}
		}
		
		/////////////
		// Fade to black
		if(mfFadeIn > 0.0f)
		{
			mfFadeIn -= afTimeStep / mfFadeLength;
			cImGuiGfx gfx;
			ImGui_DrawGfx(gfx, ImGui_FullScreenPos(40.0), ImGui_FullScreenSize(), cColor(0, mfFadeIn));
		}
		
		if(mbPremenuActive==false)
			OptionMenu_SetModColor(cColor(1, mfMainAlpha));
			
		//cLux_AddDebugMessage("TARGET: "+mTargetGroup+" CURR: "+mCurrentGroup);
		/////////////////////
		// Do title fading and parallax
		switch(mTargetGroup)
		{
			case eMainMenuGroup_Main:
			{
				if (mbPremenuActive == false/* || mPreMenuPhase == ePreMenuPhase_FinalFade*/)
					mbBackgroundShowTitle = true;
					
				//mbParallax = false;
				break;
			}
			case eMainMenuGroup_SaveSlotSelection:
			case eMainMenuGroup_GameModes:
			case eMainMenuGroup_DisplayDifficultySettings:
			case eMainMenuGroup_LoadGame:
			case eMainMenuGroup_CustomStories:
			case eMainMenuGroup_Options:
			{
				mbBackgroundShowTitle = false;
				//mbParallax = true;
				break;
			}
		}
		
		/////////////
		// Draw current state
		switch(mCurrentGroup)
		{
			////////////////
			// Main menu
			case eMainMenuGroup_Main:
			{
				if(mbMainMenuActive)
				{
					////////////
					// Gamma correction pre menu
					if(mbPremenuActive) 
					{
						GuiPreMenu(afTimeStep);
					}
					else if (mbWelcomeScreen)
					{
						GuiWelcomeMessages();
					}
					/////////////
					// Main menu
					else
					{
						GuiMainMenuSelection();
					}
				}
				////////////////
				// Pause menu
				else
				{
					GuiPauseMenuSelection();
				}
				break;
			}
			//////////////
			// StartGame
			case eMainMenuGroup_SaveSlotSelection:
			{
				GuiSaveSlotSelection(); break;
			}
			//////////////
			// GameModes
			case eMainMenuGroup_GameModes:
			{
				GuiGameModeSelection(afTimeStep);
				break;
			}
			//////////////
			// GameModes
			case eMainMenuGroup_DisplayDifficultySettings:
			{
				GuiDisplayDifficultySettings();
				break;
			}
			//////////////
			// LoadGame
			case eMainMenuGroup_LoadGame:
			{
				GuiLoadGame(); break;
			}
			//////////////
			// Options
			case eMainMenuGroup_Options:
			{
				//ImGui_AddTimer("TransitionOut", 1);
				GuiOptions(); break;
			}
			//////////////
			// Options - Game
			case eMainMenuGroup_Options_Game:
			{
				//ImGui_AddTimer("TransitionOut", 1);
				GuiOptionsGameplay(); break;
			}
			case eMainMenuGroup_Options_NewGame_Gameplay:
			{
				//ImGui_AddTimer("TransitionOut", 1);
				GuiOptionsGameplay(); break;
			}
			//////////////
			// Options - Controls
			case eMainMenuGroup_Options_Controls:
			{
				GuiOptionsControls(); break;
			}
			//////////////
			// Keybind
			case eMainMenuGroup_Options_Keybind:
			{
				GuiOptionsInputKeybind(); break;
			}
			//////////////
			// Options - Display
			case eMainMenuGroup_Options_Display:
			{
				GuiOptionsDisplay(); break;
			}
			//////////////
			// Options - Graphics
			case eMainMenuGroup_Options_Graphics:
			{
				GuiOptionsGraphics(); break;
			}
			//////////////
			// Options - Gamma
			case eMainMenuGroup_Options_Display_Gamma:
			{
				GuiOptionsGamma(); break;
			}
			//////////////
			// Options - Audio
			case eMainMenuGroup_Options_Audio:
			{
				GuiOptionsAudio(); break;
			}			
			//////////////
			// Keybind
			case eMainMenuGroup_Options_Input_Keybind:
			{
				GuiOptionsInputKeybind(); break;
			}
			//////////////
			// Mouse input Options
			case eMainMenuGroup_Options_Input_Mouse:
			{
				//GuiOptionsInputMouse(); break;
			}			
			//////////////
			// Gamepad mapping
			case eMainMenuGroup_Options_Input_GamepadMapping:
			{
				GuiOptionsInputGamepadPresets_New(); break;
			}
			//////////////
			// Gameplay Options
			case eMainMenuGroup_Options_Gameplay:
			{
				GuiOptionsGameplay(); break;
			}
			//////////////
			// Gamma Video Options
			case eMainMenuGroup_Options_Video_Gamma:
			{
				GuiOptionsGamma(); break;
			}
			//////////////
			// Subtitle Options
			case eMainMenuGroup_Options_Audio_Subtitles:
			{
				GuiOptionsSubtitles(); break;
			}
			//////////////
			// Debug Options
			case eMainMenuGroup_Options_Debug:
			{
				GuiOptionsDebug(); break;
			}
			////////////////
			// Custom Stories
			case eMainMenuGroup_CustomStories:
			{
				GuiCustomStories_V2();break;
			}
			//////////////
			// New Game Gamma
			case eMainMenuGroup_NewGame_Gamma:
			{
				GuiOptionsGamma(); break;
			}
			////////////////
			// Accessibilty 
			case eMainMenuGroup_Options_Accessibility:
			{
				GuiOptionsAccessibility(); break;
			}
			////////////////////
			// Accessibilty Game
			case eMainMenuGroup_Options_Accessibility_Game:
			{
				GuiOptionsAccessibilityGame(); break;
			}
			////////////////////
			// Accessibilty Input
			case eMainMenuGroup_Options_Accessibility_Input:
			{
				GuiOptionsAccessibilityInput(); break;
			}
		}
		
		OptionMenu_SetModColor(cColor(1, 1));
		OptionMenu_ResetExtraWidth();
		
		ImGui_SetTransCategory("");
	}
	
	//-------------------------------------------------------
	
	void UpdateMainMenuStage()
	{
		cConfigFile@ pStatsConfig = cLux_GetStatsConfig();
		if (pStatsConfig !is null)
		{
			int lStage = Blackboard_GetStalkerEscalation();
			pStatsConfig.SetInt("Game", "MainMenuStage", lStage);
			pStatsConfig.Save();
		}
	}
	
	//-------------------------------------------------------
	
	void DoBackground(float afWidth, float afAlphaMul=1.f, float afVignetteAlphaMul=1.f)
	{
		//////////////
		// Background 
		float fAlphaNrm = cMath_Clamp(mfMainAlpha / gfMenuMainAlphaMax, 0.f, 1.f); // So it follows the global alpha
		cImGuiGfx gfxBkg("startmenu_bg", eImGuiGfx_Texture);
		cVector2f vSize = cVector2f(afWidth+75, 1000);
		cColor bgColor = cColor(0.0, afAlphaMul * fAlphaNrm) * gOptionMenu_ModColor;
		ImGui_DrawGfx(gfxBkg, OptionMenu_GetTopLeftOffset(cVector2f(-75,-200), -22), OptionMenu_GetScaledSize(vSize), bgColor);

		///////////////
		// Vignette
		cVector3f vBgCenter = cVector3f(kScreenCenter.x, kScreenCenter.y,0);
		cVector3f vFgCenter = cVector3f(kScreenCenter.x, kScreenCenter.y,0);
		cVector2f vScaledSize = cVector2f(2000,768);	// Image scale locked on virtual hud height (3640x1540) (correct calculation should be 1815 :S)
		cVector2f vOuterOffset = cVector2f(200,50);		// Area the image is drawn outside of screen (200x100) - A BIT OF A MAGIC NUMBER
		cVector2f vSizeVignette = vScaledSize + vOuterOffset;
		cImGuiGfx gfxBkgVignette("startmenu_vignette.dds", eImGuiGfx_Texture);
		gfxBkgVignette.mColor = cColor(0, afVignetteAlphaMul * fAlphaNrm);
		ImGui_DrawAlignedGfx(gfxBkgVignette, cVector3f(vBgCenter.x,vBgCenter.y,-10), eImGuiAlign_CenterCenter, vSizeVignette);
		cVector3f vLeftVignetteBorder = cVector3f(vBgCenter.x - vSizeVignette.x*0.5f, vBgCenter.y-vSizeVignette.y*0.5f, -30);
		cVector3f vRightVignetteBorder = cVector3f(vBgCenter.x + vSizeVignette.x*0.5f, vBgCenter.y-vSizeVignette.y*0.5f, -30);
		cVector2f vRightVignetteFillerSize = OptionMenu_GetScaledSize(cVector2f(2100-vRightVignetteBorder.x,vScaledSize.y));
		//cVector2f vRealRightVignetteBorder = OptionMenu_GetOffsetPosHelper(cVector2f(vRightVignetteBorder.x, vRightVignetteBorder.y));
		ImGui_DrawAlignedGfx(cImGuiGfx(), vLeftVignetteBorder, eImGuiAlign_TopRight, vRightVignetteFillerSize, gfxBkgVignette.mColor);		
		ImGui_DrawAlignedGfx(cImGuiGfx(), vRightVignetteBorder, eImGuiAlign_TopLeft, vRightVignetteFillerSize, gfxBkgVignette.mColor);		
	}
	
	//-------------------------------------------------------
	
	void StartNewGame()
	{
		/////////////////
		// Clear the selected save slot if used
		for(uint i = 0; i < mvSaveFiles.size(); ++i)
		{
			int lSuffix = cString_GetNumericSuffixIntW(mvSaveSuffix[i]);
			if (lSuffix == mlSelectedSaveSlot)
				cLux_GetSaveHandler().DeleteSaveFile(mvSaveFiles[i]);
		}
		
		///////////
		// Set save slot
		tWString sSuffixName = cString_To16Char("slot" + mlSelectedSaveSlot + "-" + "difficulty" + mlSelectedGameMode);
		
		cLux_GetSaveHandler().SetSaveSuffix(sSuffixName);
		
		///////////////////////
		// Set and clear the game stat emtries
		GameStats_ResetAllEntries(true);
		
		cLux_AddDebugMessage("[MainMenu] [StartNewGame] Selected save suffix is: " + mlSelectedSaveSlot);
		
		SetMenuActive(false);
		cLux_LoadScreenSetOneShotSolidColorBackground();
		mbGameOver = false;
		mbWelcomeScreen = false;
		msPreviousSaveLoaded = "";
		
		MainMenu_SetPhase_Items(eMainMenuPhase_Items_None);
		MainMenu_Sketchbook_SetSketch("loadscreen_1aa");
		MainMenu_SetPhase_Ghoul(0);
		
		Sketchbook_OnNewGame();
		
		cLux_SetGameDifficulty(mlSelectedGameMode);
		GameDifficulty_SwitchSettingsPresetTo(mlSelectedGameMode);
		
		tString sNewGameStartMap = "";
		
		if(cLux_GetModHandler().GetIsRunningMod()==false)
		{
			sNewGameStartMap = cLux_GetStartMapFile("Main");
			if (mbGameCompletedOnce && mbNewGameSkipIntro)
			{
				sNewGameStartMap = cLux_GetStartMapFile("PostIntro");
			}
		}
		
		Achievement_CheckPlatinum();
		
		// Keep the difficulty settings data as a local var here or it'll be lost when starting a new game. 
		array<int> vDifficultySettingValueIDs = GameDifficulty_GetSettingsSelectedValueIDs();
		bool bInitialPlaythroughConditions = mbNewGamePlus == false;
		
		cLux_StartNewGame(sNewGameStartMap);
		
		// New game done. Recover the difficulty data
		GameDifficulty_SetSettingsSelectedValueIDs(vDifficultySettingValueIDs, true);
		GameDifficulty_SetInitialPlaythroughConditions(bInitialPlaythroughConditions);
		
		Item_OnNewGame();
	}
	
	//-------------------------------------------------------
	
	void StartSavedGameLoad(const tWString &in asFile)
	{
		Achievement_CheckPlatinum();
		
		//////////////////
		// Set save slots
		mlPreviouslySelectedSaveSlot = mlSelectedSaveSlot;
		tWString sSuffixName = cString_To16Char("slot" + mlSelectedSaveSlot + "-" + "difficulty" + mlSelectedGameMode);
		cLux_GetSaveHandler().SetSaveSuffix(sSuffixName);
		
		Log("[MenuHandler] [StartSavedGameLoad] SaveFile: " + cString_To8Char(asFile) + " SaveSlot: " + cString_To8Char(sSuffixName));
		
		cLux_LoadScreenSetContinueText("", cResources_Translate("LoadGame", "LoadingHint"), "");

		mbGameOver = false;
		cLux_GetSaveHandler().DelayedLoadGameFromFile(asFile, "", "", true, true);
		msPreviousSaveLoaded = asFile;
		LoadScreen_SetForceBackground(true);
		SetMenuActive(false);
		cLux_LoadScreenSetOneShotSolidColorBackground();
		
		gLastTimeOnGameScreen.LoadingStarted();
	}
	
	//------------------------------------------------------

	bool mbShowingGammaMenu = false;
	
	//------------------------------------------------------- 
	
	float mfAlphaEasingValue = 0;
	
	//-------------------------------------------------------
	
	void SetGameCompletedOnce(bool abX)
	{
		mbGameCompletedOnce = true;
		mbNewGamePlus = true;
		cConfigFile@ pConfig = cLux_GetStatsConfig();
		if (pConfig is null) return;
		pConfig.SetBool("Game", "GameCompletedOnce", abX);
		pConfig.Save();
	}
	
	//-------------------------------------------------------
	
	bool GetGameCompletedOnce()
	{
		return mbGameCompletedOnce;
	}
	
	//-------------------------------------------------------
	
	uint GetGameModeThatMatchesTheCurrentSettings()
	{
		array<int> vCurrentDifficultySettingValueIDs = GameDifficulty_GetSettingsSelectedValueIDs();

		const uint lDifficultyModesMaxIndx = 6;
		array<int> vDifficultySettingsPreset;

		for (uint i = 0; i < lDifficultyModesMaxIndx; )
		{
			vDifficultySettingsPreset = GameDifficulty_GetValuesSettingByPreset(i);

			if (vCurrentDifficultySettingValueIDs.size() != vDifficultySettingsPreset.size())
			{
				Error("[MainMenu] GetDifficultySettingsEqualToMode failed because the arrays compared are of different lengths.");
				return eGameMode_Custom;
			}

			bool matchFound = true;

			for (uint j = 0; j < vCurrentDifficultySettingValueIDs.size(); j++)
			{
				if (vCurrentDifficultySettingValueIDs[j] != vDifficultySettingsPreset[j])
				{
					matchFound = false;
					break;
				}
			}
			
			///////////////////////////////
			// Match found, return the index
			if (matchFound)
				return i;
			///////////////////////////////
			// No match found, move to the next preset
			else
				i++; 
		}
		
		/////////////////////////////////////////
		// No match found, return eGameMode_Custom
		return eGameMode_Custom;
	}
	
	//-------------------------------------------------------
	
	bool GetCustomDifficultySettingsChanged()
	{
		array<int> vDifficultySettingValueIDs = GameDifficulty_GetSettingsSelectedValueIDs();
		if (mvInitialCustomDifficultySettingValueIDs.size() != vDifficultySettingValueIDs.size())
		{
			Error("Failed to check settings state: Prev values size: " + mvInitialCustomDifficultySettingValueIDs.size() + ", new values size: " + vDifficultySettingValueIDs.size());
			return false;
		}
		
		for(int i=0; i<vDifficultySettingValueIDs.size(); ++i)
		{
			int l1 = mvInitialCustomDifficultySettingValueIDs[i];
			int l2 = vDifficultySettingValueIDs[i];
			if (l1 != l2) return true;
		}
		
		return false;
	}
	
	//-------------------------------------------------------
	
	void GuiGameModeSelection(float afTimeStep)
	{
		GuiPauseDarkOverlay();
		
		ImGui_SetTransCategory("Menu");
		
		const cVector2l vResolution = cVector2l(mpConfig.GetInt("Screen", "Width", 1280), mpConfig.GetInt("Screen", "Height", 720));
		const cVector2l vScreenRatio = GetScreenRatio(vResolution.x, vResolution.y);
		const bool bIsSquareScreen = vScreenRatio == cVector2l(4,3) || vScreenRatio == cVector2l(5,4);
		const float fSquareScreenXOffset = 70.f;
		
		array<tString> vGameModeValues = {"Easy", "Normal", "Hard"};
		bool bShowCustomSettings = mbGameCompletedOnce && mbNewGamePlus;
		
		if (bShowCustomSettings)
		{
			vGameModeValues.push_back("ShellShock");
			vGameModeValues.push_back("Custom");
		}
		
		vGameModeValues.push_back("VeryEasy");
			
		array<tString> vMenuItems = {"DifficultyMode"};
		
		/////////////////////////////////////////
		// Put all collected settings names inside an array regardless of whether they are drawn or not for scrolling later on.
		array<tString> vAllCustomGameSettings;
		const int lAllCustomSettingsCount = mvCustomSettings_Names.size();
		
		for(int i=0; i<lAllCustomSettingsCount; i++)
		{
			vAllCustomGameSettings.push_back(mvCustomSettings_Names[i]);
		}
			
		////////////////////////////////
		// If the game is completed once add the custom settings buttons in.
		const bool bWithinRange = lAllCustomSettingsCount <= glCustomGameModeSettingsMaxInPage;
		int lListedCustomSettingsCount = 0;
		
		vMenuItems.push_back("NewGamePlusSetting");
		
		if (mbGameCompletedOnce)
		{			
			if (mbNewGamePlus)
			{
				int lListingSize = bWithinRange ? lAllCustomSettingsCount : glCustomGameModeSettingsMaxInPage + mlCustomGameModeSettingsOffset;
				int lListingStart = bWithinRange ? 0 : mlCustomGameModeSettingsOffset;
				
				for (int i=lListingStart; i<lListingSize; i++)
				{
					vMenuItems.push_back(vAllCustomGameSettings[i]);
					lListedCustomSettingsCount++;
				}
			}
		}
		
		/////////////////
		// List new game plus button
		if (mbShowNewGamePlusButton && bShowCustomSettings==false)
			vMenuItems.push_back("NewGamePlusCodeButton");
		
		///////////////
		// List the randomize button
		if (bShowCustomSettings)
			vMenuItems.push_back("RandomizeSettings");
		
		//////////////////////
		// Add continue and back buttons
		vMenuItems.push_back("Continue");
		
		if (cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false)
			vMenuItems.push_back("Back");
		
		///////////////
		// Setup page
		for (int i=0; i<mvCustomSettings_Names.size(); i++)
		{
			OptionMenu_UpdateButtonWidth(mvCustomSettings_Names[i]);
		}
		
		OptionMenu_UpdateToggleExtraWidth();
		OptionMenu_UpdateMultiSelectionExtraWidth(vGameModeValues);
		if (bShowCustomSettings)
		{
			for (int i=0; i<mvCustomSettings_ValueList.size(); ++i)
			{
				OptionMenu_UpdateMultiSelectionExtraWidth(mvCustomSettings_ValueList[i]);
			}
		}
		
		OptionMenu_AlignExtraButtonWidth();
		
		cVector2f vGameModesMenuPos = bShowCustomSettings ? kOptionsBgPos + cVector2f(0,-175) : kOptionsBgPos;
		cVector2f vGameModesMenuSize = kOptionsGameModesBgSize + cVector2f(gfOptionsMenu_ExtraWidth_MultiSelect + gfGameModeSettings_FixedDistanceBetweenNameAndWidget, 0);
		if (bIsSquareScreen)
			vGameModesMenuSize.x-= fSquareScreenXOffset;
		cVector2f vRightAnchor = cVector2f(vGameModesMenuPos.x + vGameModesMenuSize.x, 0);
		const float fBgExtraWidth = bShowCustomSettings ? 220.f : 100.f;
		DoBackground(vRightAnchor.x + fBgExtraWidth);
		
		OptionMenu_SectionTitle("NewGame", vGameModesMenuPos + cVector2f(40,-40), 1.f, mfTransitionAlpha);
		
		mlFirstItemId = 0;
		mlCurrentItemId = mlFirstItemId;
		OptionMenu_SetOutOfLimit(vMenuItems.length());
		
		float fInfoBoxPosOffset = bShowCustomSettings ? 170 : 50;
		cVector3f vInfoBoxPos = OptionMenu_GetTopLeftOffset(cVector2f(vGameModesMenuPos.x + vGameModesMenuSize.x + fInfoBoxPosOffset),0);
		if (bIsSquareScreen)
			vInfoBoxPos.x -= 90;
		cVector2f vSettingsPos = bShowCustomSettings ? kOptionsButtonPos + cVector2f(0,-175) : kOptionsButtonPos;
		if (bIsSquareScreen)
			vSettingsPos.x -= fSquareScreenXOffset;
		
		//////////////////////////////
		// Go directly to the "Continue" button if confirm is pressed while the "DifficultyMode" button is selected
		bool bActionTaken = false;
		if (ImGui_ActionTriggered(eImGuiAction_Confirm) && cLux_GetInputHandler().GetGamepadWasLastDeviceUsed() && msSelectedGameModesBtn=="DifficultyMode")
		{
			mlActionHorizontal = 0;
			msFocusNextFrame = "Continue";
			bActionTaken = true;
		}
		
		//////////////////////////////////////////////////////////////////////
		// Fixed game modes selection
		
		tString sToolTip = "";
		if (bShowCustomSettings)
		{
			switch (mlSelectedGameMode)
			{
				case eGameMode_VeryEasy: sToolTip = "VeryEasyModeDesc"; break;
				case eGameMode_Easy: sToolTip = "EasyModeDesc"; break;
				case eGameMode_Normal: sToolTip = "NormalModeDesc"; break;
				case eGameMode_Hard: sToolTip = "HardModeDesc"; break;
				case eGameMode_UltraHard: sToolTip = "ShellShockDesc"; break;
				case eGameMode_Custom: sToolTip = "CustomModeDesc"; break;
			}
		}
		
		// Hack to make sure 'Very Easy' can be selected
		int lCurrentValue = mlSelectedGameMode;
		if (lCurrentValue == eGameMode_VeryEasy)
			lCurrentValue = vGameModeValues.size() - 1;
		
		uint lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], vSettingsPos, mlCurrentItemId, msSelectedGameModesBtn, vGameModeValues, lCurrentValue, false, mlActionHorizontal, "Menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha, false, false, true, sToolTip, cString_To16Char(""), true);
		
		// 'Very Easy' hack continued
		if (lNewValue == vGameModeValues.size() - 1)
			lNewValue = eGameMode_VeryEasy;
		
		if(mlSelectedGameMode != lNewValue && bActionTaken==false)
		{
			bool bSwitchingAwayFromCustomMode = mlSelectedGameMode == eGameMode_Custom && lNewValue != eGameMode_Custom;
			
			//////////////////////////
			// Throw warning msg
			if (bSwitchingAwayFromCustomMode && GetCustomDifficultySettingsChanged())
			{
				mlNewGameModeToUse = lNewValue;
				mbShowCustomSettingsChangesWillBeLost = true;
				mlCustomSettingsChangesWillBeLost = eCustomSettingsChangesWillBeLost_Default;
				msFocusNextFrame = "No";
			}
			/////////////////////////
			// Switch to a new mode directly
			else 
			{
				mlSelectedGameMode = lNewValue;
				GameDifficulty_SwitchSettingsPresetTo(mlSelectedGameMode);
				
				///////////////////////////////////////////
				// Keep teh initial custom settings to compare later for any changes
				if (mlSelectedGameMode == eGameMode_Custom)
				{
					mvInitialCustomDifficultySettingValueIDs.resize(0);
					mvInitialCustomDifficultySettingValueIDs = GameDifficulty_GetSettingsSelectedValueIDs();
				}
			}
		}

		msSelectedGameModesBtn = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGameModesBtn);
		mlCurrentItemId++;
		
		///////////////////////////////////////////
		// Initial playthrough conditions
		bool bAllowNewGamePlus = mbGameCompletedOnce;
		tString sNewGamePlusInfoBoxText = mbNewGamePlus ? "NewGamePlusSetting_InfoAlt" : "";
		bool bNewNewGamePlusValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], vSettingsPos, mlCurrentItemId, msSelectedGameModesBtn, mbNewGamePlus, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha, false, bAllowNewGamePlus, sNewGamePlusInfoBoxText, cString_To16Char(""), true);		
		if (bAllowNewGamePlus && bNewNewGamePlusValue != mbNewGamePlus)
		{
			///////////////////////////////////////////////////
			// Should we switch to another game mode?
			// Throw warning msg about settings about to get lost
			if (mlSelectedGameMode == eGameMode_Custom && bNewNewGamePlusValue == false)
			{
				if (GetCustomDifficultySettingsChanged())
				{
					mbToggleNewGamePlus = true;
					mlNewGameModeToUse = eGameMode_Normal;
					mbShowCustomSettingsChangesWillBeLost = true;
					mlCustomSettingsChangesWillBeLost = eCustomSettingsChangesWillBeLost_Default;
					msFocusNextFrame = "No";
				}
				else
				{
					mlSelectedGameMode = eGameMode_Normal;
					GameDifficulty_SwitchSettingsPresetTo(mlSelectedGameMode);
					mbNewGamePlus = bNewNewGamePlusValue;
				}
			}
			else
			{
				if (mlSelectedGameMode == eGameMode_UltraHard)
				{
					mlSelectedGameMode = eGameMode_Normal;
					GameDifficulty_SwitchSettingsPresetTo(mlSelectedGameMode);
				}
				mbNewGamePlus = bNewNewGamePlusValue;
			}
		}
		else if (bAllowNewGamePlus == false && bNewNewGamePlusValue)
		{
			mbShowNewGamePlusSettingPopUp = true;
			msFocusNextFrame = "Ok";
		}
					
		msSelectedGameModesBtn = OptionMenu_UpdateFocus(vMenuItems[mlCurrentItemId], msSelectedGameModesBtn);
		mlCurrentItemId++;		
		
		////////////////////
		// Separation line
		float fLineHeight = 83;
		float fLineWidthMul = mbNewGamePlus == false ? 1.f : 1.1f;
		cVector2f vBasePos = vGameModesMenuPos;
		if (bIsSquareScreen)
			vBasePos.x -= fSquareScreenXOffset;
		ImGui_DrawGfx(cImGuiGfx(), OptionMenu_GetTopLeftOffset(vBasePos + cVector2f(35, fLineHeight), 0.01), OptionMenu_GetScaledSize(cVector2f(vGameModesMenuSize.x * fLineWidthMul,2)), cColor(1, mfTransitionAlpha) * gOptionMenu_ModColor * 0.5);
		
		////////////////////////
		// Description label
		if (mbGameCompletedOnce==false || mbNewGamePlus == false)
		{
			cImGuiTextFrameData txtData;
			txtData.mbUseBackgroundGfx = false;
			txtData.mFont.mvSize = 23;
			txtData.mFont.mColor = cColor(1.0, mfTransitionAlpha) * gOptionMenu_ModColor;
			txtData.mFont.SetFile(FontHandler_GetFont(eFontType_MainMenu_InfoBox, 56));
			cVector2f vTxtFramePos =  vSettingsPos + cVector2f(0, fLineHeight);
			cVector2f vTxtFrameSize = cVector2f(vGameModesMenuSize.x * 1, vGameModesMenuSize.y);
			tString sDescTxt = "NormalModeDesc";
			
			if (mlSelectedGameMode == eGameMode_VeryEasy)
				sDescTxt = "VeryEasyModeDesc";
			else if (mlSelectedGameMode == eGameMode_Easy)
				sDescTxt = "EasyModeDesc";
			else if (mlSelectedGameMode == eGameMode_Hard)
				sDescTxt = "HardModeDesc";
			else if (mlSelectedGameMode == eGameMode_UltraHard)
				sDescTxt = "ShellShockDesc";
			
			txtData.mFont.mColor = cColor(0.6, mfTransitionAlpha) * gOptionMenu_ModColor;
			ImGui_DoTextFrameExt(sDescTxt, cVector2f(0), 6.f, 0.f, txtData, OptionMenu_GetTopLeftOffset(vTxtFramePos, 0.5), OptionMenu_GetScaledSize(vTxtFrameSize));
			ImGui_SetTransCategory("Menu");
		}
		
		//////////////////////////////////////////////////////////////////////
		// CUCSTOM SETTINGS
		if (bShowCustomSettings && lListedCustomSettingsCount > 0)
		{
			////////////////
			// Draw lower seperation line gfx
			ImGui_DrawGfx(cImGuiGfx(), OptionMenu_GetTopLeftOffset(vBasePos + cVector2f(35, 450.0), 0.01), OptionMenu_GetScaledSize(cVector2f(vGameModesMenuSize.x * 1.1,2)), cColor(1, mfTransitionAlpha) * gOptionMenu_ModColor * 0.5);
			
			////////////////////////////////////////
			// Draw custom settings controls list
			cVector2f vCustomGameSettingsPos = vSettingsPos + cVector2f(0, 10);
			
			
			////////////////////////////////////////
			// Floats and Ints
			for(int i=0; i<lListedCustomSettingsCount; i++)
			{
				uint lIdx = i + mlCustomGameModeSettingsOffset;
				int lType = mvCustomSettings_ControlTypes[lIdx];
				int lID = mvCustomSettings_Ids[lIdx];
				int lReliesOn_SettingID = mvReliesOn_SettingID[lIdx];
				//int lReliesOn_DisablingValueID = mvReliesOn_DisablingValueID[lIdx];
				array<int> vReliesOn_DisablingValueIDs = mvReliesOn_DisablingValueIDs[lIdx];
				tString sName = mvCustomSettings_Names[lIdx];
				array<tString>@ vValues = mvCustomSettings_ValueList[lIdx];
				bool bActive = mvCustomSettings_Active[lIdx];
				
				
				//bool bDisabled = GameDifficulty_GetSettingSelectedValueIdByID(lReliesOn_SettingID) == lReliesOn_DisablingValueID || bActive==false;
				
				//////////////////////////
				// Is the setting active?
				bool bDisabled = false;
				for(int i=0; i<vReliesOn_DisablingValueIDs.size(); ++i)
				{
					const int lCurrValueID = GameDifficulty_GetSettingSelectedValueIdByID(lReliesOn_SettingID);
					const int lDisablingValueID = vReliesOn_DisablingValueIDs[i];
					//cLux_AddDebugMessage("lCurrValueID " + lCurrValueID + ", lDisablingValueID " + lDisablingValueID);
					if (lCurrValueID == lDisablingValueID)
					{
						bDisabled = true;
						break;
					}
				}
				
				if (bDisabled==false && bActive==false)
					bDisabled = true;
				
				
				tWString sSupportingModes = cString_To16Char("");
				if (mlSelectedGameMode == eGameMode_Custom)
				{
					array<int> vSettingDifficulty = GameDifficulty_GetAllDifficultyPresetsSupportingSettingByID(lID);
					int lModeCount = vSettingDifficulty.size();
					for (int i=0; i<lModeCount; ++i)
					{
						tString sMode;
						int lMode = vSettingDifficulty[i];
						if (lMode == eGameMode_VeryEasy)
							sMode = "VeryEasy";
						else if (lMode == eGameMode_Easy)
							sMode = "Easy";
						else if (lMode == eGameMode_Normal)
							sMode = "Normal";
						else if (lMode == eGameMode_Hard)
							sMode = "Hard";
						else if (lMode == eGameMode_UltraHard)
							sMode = "ShellShock";
							
						tWString swMode = ImGui_Translate(sMode);
						if (i>0) sSupportingModes += ", ";
						sSupportingModes += swMode;
						//cLux_AddDebugMessage("" + lMode);
					}
					
					if (lModeCount>0)
						sSupportingModes = "(" + sSupportingModes + ")";
				}
					
				if (lType == eDifficultySettingControlType_Slider)
				{
					int lCurrValueID = GameDifficulty_GetSettingSelectedValueIdByID(lID);
					tString sSelectedValueName = GameDifficulty_GetSettingValueNameByID(lID);
					int lNewValueID = OptionMenu_ButtonOptionsMultiSelectSlider(vMenuItems[mlCurrentItemId-mlFirstItemId], vCustomGameSettingsPos, mlCurrentItemId, msSelectedGameModesBtn, vValues, lCurrValueID, mlActionHorizontal, sSelectedValueName, "Menu", vRightAnchor, vInfoBoxPos, mfTransitionAlpha, true, !bDisabled, "", sSupportingModes, true);
					if (lCurrValueID != lNewValueID)
					{
						mvInitialCustomDifficultySettingValueIDs.resize(0);
						mvInitialCustomDifficultySettingValueIDs = GameDifficulty_GetSettingsSelectedValueIDs();
						GameDifficulty_SetSettingValueIdByID(lID, lNewValueID);
						mlSelectedGameMode = GetGameModeThatMatchesTheCurrentSettings();
						mbRandomizedOnce = false;
					}
				}
				else if (lType == eDifficultySettingControlType_Switch)
				{
					int lCurrValueID = GameDifficulty_GetSettingSelectedValueIdByID(lID);
					int lNewValueID = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], vCustomGameSettingsPos, mlCurrentItemId, msSelectedGameModesBtn, vValues, lCurrValueID, false, mlActionHorizontal, "Menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha, false, true, !bDisabled, "", sSupportingModes, true);
					
					if (lCurrValueID != lNewValueID)
					{
						mvInitialCustomDifficultySettingValueIDs.resize(0);
						mvInitialCustomDifficultySettingValueIDs = GameDifficulty_GetSettingsSelectedValueIDs();
						GameDifficulty_SetSettingValueIdByID(lID, lNewValueID);
						mlSelectedGameMode = GetGameModeThatMatchesTheCurrentSettings();
						mbRandomizedOnce = false;
					}
				}
				////////////////////////////////////////
				// Bools
				else
				{
					bool bCurrValue = GameDifficulty_GetSettingValueByID_Bool(lID);
					bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], vCustomGameSettingsPos, mlCurrentItemId, msSelectedGameModesBtn, bCurrValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha, true, !bDisabled, "", sSupportingModes, true);
					if(bNewValue != bCurrValue)
					{
						mvInitialCustomDifficultySettingValueIDs.resize(0);
						mvInitialCustomDifficultySettingValueIDs = GameDifficulty_GetSettingsSelectedValueIDs();
						int lNewValueID = bNewValue == true ? 1 : 0;
						GameDifficulty_SetSettingValueIdByID(lID, lNewValueID);
						mlSelectedGameMode = GetGameModeThatMatchesTheCurrentSettings();
						mbRandomizedOnce = false;
					}
				}
				
				msSelectedGameModesBtn = OptionMenu_UpdateFocus(vMenuItems[mlCurrentItemId], msSelectedGameModesBtn);
				mlCurrentItemId++;
			}
			
			///////////////////////
			// Check if we should scroll instead of select the nest item
			int lMaxScrollOffset = lAllCustomSettingsCount - glCustomGameModeSettingsMaxInPage;
			int lMinScrollOffset = 0;
			
			bool bReachedFirstItemInCurrentList = vMenuItems[2] == msSelectedGameModesBtn; 
			bool bReachedLastItemInCurrentList = vMenuItems[lListedCustomSettingsCount+1] == msSelectedGameModesBtn; 
			
			bool bCanScrollUp = mlCustomGameModeSettingsOffset > lMinScrollOffset;
			bool bCanScrollDown = mlCustomGameModeSettingsOffset < lMaxScrollOffset;
			
			bool bShouldScrollUp = bWithinRange ? false : bReachedFirstItemInCurrentList && bCanScrollUp;
			bool bShouldScrollDown = bWithinRange ? false : bReachedLastItemInCurrentList && bCanScrollDown;
			
			//cLux_AddDebugMessage("msSelectedGameModesBtn " + msSelectedGameModesBtn);
			//cLux_AddDebugMessage("bShouldScrollUp " + bShouldScrollUp);
			//cLux_AddDebugMessage("bShouldScrollDown " + bShouldScrollDown);
			
			if (ImGui_ActionIsDown(eImGuiAction_Up, false))		mfCustomSettingsInputCount_Up += afTimeStep;
			else												mfCustomSettingsInputCount_Up = 0.f;
			if (ImGui_ActionIsDown(eImGuiAction_Down, false))	mfCustomSettingsInputCount_Down += afTimeStep;
			else												mfCustomSettingsInputCount_Down = 0.f;	
			
			if (bWithinRange==false)
			{
				/////////////////////////
				// Catch input
				int lActionVertical = 0;
				bool bMouseDown = ImGui_ActionIsDown(eImGuiAction_MouseLeft, false);
				
				if (bShouldScrollUp)
				{
					bool bUpTriggered = ImGui_ActionTriggered(eImGuiAction_Up, false);					
					if (bUpTriggered || mfCustomSettingsInputCount_Up > 0.3f)
					{
						lActionVertical--;
						ImGui_SetFocus(vMenuItems[2]);
						
						if (bUpTriggered)
							cLux_GetCurrentImGui().SetMoveRepeatAction(eImGuiAction_Up);
					}
				}
				else if (bShouldScrollDown)
				{	
					bool bDownTriggered = ImGui_ActionTriggered(eImGuiAction_Down, false);					
					if (bDownTriggered || mfCustomSettingsInputCount_Down > 0.3f)
					{
						lActionVertical++;		
						ImGui_SetFocus(vMenuItems[lListedCustomSettingsCount + 1]);
						
						if (bDownTriggered)
							cLux_GetCurrentImGui().SetMoveRepeatAction(eImGuiAction_Down);
					}
				}					

				if (ImGui_ActionTriggered(eImGuiAction_ScrollUp, false))
				{
					lActionVertical -= 2;
				}
				else if (ImGui_ActionTriggered(eImGuiAction_ScrollDown, false))
				{
					lActionVertical += 2;
				}	
			 
				//////////////
				// Scrolling
				if(lActionVertical != 0 && mbShowCustomSettingsChangesWillBeLost==false)
				{
					///////////////
					// Scroll up
					if (lActionVertical < 0)
						mlCustomGameModeSettingsOffset = (lActionVertical==-1) ? cMath_Max(mlCustomGameModeSettingsOffset-1, 0) : cMath_Max(mlCustomGameModeSettingsOffset-2, 0);
					
					////////////////
					// Scroll down
					else
						mlCustomGameModeSettingsOffset = (lActionVertical==1) ? cMath_Min(mlCustomGameModeSettingsOffset+1, lMaxScrollOffset) : cMath_Min(mlCustomGameModeSettingsOffset+2, lMaxScrollOffset);
				}
				
				float fCustomGameSettingsTotalCount = lAllCustomSettingsCount;
				float fPadding = mbScrollingCustomGameSettings ? 10000 : 5;
				cVector2f vMenuScrollPos = cVector2f(vBasePos.x + vGameModesMenuSize.x + 150, vCustomGameSettingsPos.y+58);
				if (bIsSquareScreen)
					vMenuScrollPos.x += fSquareScreenXOffset * 0.9;
				cVector2f vMenuScrollSize = cVector2f(14, vGameModesMenuSize.y * 0.9);
				cVector2f vMouseScrollMin = vMenuScrollPos - cVector2f(fPadding, 0);
				cVector2f vMouseScrollMax = vMenuScrollPos + vMenuScrollSize + cVector2f(fPadding, 0);
				float fMouseScrollY = OptionMenu_GetMouseInside(vMouseScrollMin, vMouseScrollMax).y;
				
				//////////////////////
				// Mouse touching scroll, check if button pressed
				if(fMouseScrollY != -1.0 && bMouseDown)
				{
					mlCustomGameModeSettingsOffset = cMath_RoundToInt((fCustomGameSettingsTotalCount - glCustomGameModeSettingsMaxInPage) * fMouseScrollY);
					mbScrollingCustomGameSettings = true;
				}
				
				/////////////////////////////////////
				// Stopped scrolling
				if(bMouseDown == false)
					mbScrollingCustomGameSettings = false;
				
				/////////////
				// Do offset
				mlCustomGameModeSettingsOffset = cMath_Clamp(mlCustomGameModeSettingsOffset, 0, fCustomGameSettingsTotalCount - glCustomGameModeSettingsMaxInPage);
				
				int lOldOffset = mlCustomGameModeSettingsOffset;
				int lDiff = (mlCustomGameModeSettingsOffset - lOldOffset);
				
				if(mlCustomGameModeSettingsOffset >= 0 && mlCustomGameModeSettingsOffset < glCustomGameModeSettingsMaxInPage && lDiff != 0)
				{
					mlCustomGameModeSettingsOffset = cMath_Clamp(mlCustomGameModeSettingsOffset + lDiff, 0, fCustomGameSettingsTotalCount - glCustomGameModeSettingsMaxInPage);
				}

				float fScaleY = 0.45;
				float fPosY = mlCustomGameModeSettingsOffset / (fCustomGameSettingsTotalCount - glCustomGameModeSettingsMaxInPage);
				
				ImGui_DrawGfx(cImGuiGfx(), OptionMenu_GetTopLeftOffset(vMenuScrollPos + cVector2f(-2,0), 0.01), OptionMenu_GetScaledSize(cVector2f(1,vMenuScrollSize.y)), cColor(1, mfTransitionAlpha) * gOptionMenu_ModColor);
				
				cImGuiGfx gfxKeybindsScrollBar = cImGuiGfx("startmenu_scrollbar.tga", eImGuiGfx_Texture);
				gfxKeybindsScrollBar.mColor = cColor(1,mfTransitionAlpha) * gOptionMenu_ModColor;
			
				cColor scrollBarColor = (fMouseScrollY == -1.0f && mbScrollingCustomGameSettings == false) ? cColor(1,mfTransitionAlpha * 0.8) : gHoverColor * cColor(1,mfTransitionAlpha);
				ImGui_DrawGfx(gfxKeybindsScrollBar, OptionMenu_GetTopLeftOffset(vMenuScrollPos + vMenuScrollSize * cVector2f(0, (1.0 - fScaleY) * fPosY), 0.01), OptionMenu_GetScaledSize(vMenuScrollSize * cVector2f(1, fScaleY)), scrollBarColor);
			}
			
			//////////////////////////////////////////////////////////////////////////////////
			// Randomize Button
			if (bShowCustomSettings)
			{
				const tString sLabel = "RandomizeSettings";
				bool bSelected = msSelectedGameModesBtn == sLabel;
				cVector2f vPos = cVector2f(vCustomGameSettingsPos.x, 545);
				
				cImGuiButtonData buttonData = ImGui_GetDefaultButton();
				buttonData.mbUseBackgroundGfx = false;
				buttonData.mbUseInFocusGfx = false;
				buttonData.mbUseTriggeredGfx = false;
				buttonData.mFont.SetFile(FontHandler_GetFont(eFontType_MainMenu,72));
				buttonData.mFont.mvSize = 20;
				buttonData.mFontAlign = eFontAlign_Left;
				buttonData.mFont.mColor =  cColor(1.0, mfTransitionAlpha) * gOptionMenu_ModColor;
				
				if (bSelected)
					buttonData.mFont.mColor = gHoverColor * cColor(1, mfTransitionAlpha);
				
				cVector3f vButtonPos = OptionMenu_GetTopLeftOffset(vPos, 1.0);
				
				if (ImGui_DoButtonExt(sLabel, sLabel, buttonData, vButtonPos, OptionMenu_GetScaledSize(cVector2f(256, 40))))
				{
					//////////////////////////
					// Throw warning msg
					if (mlSelectedGameMode == eGameMode_Custom && GetCustomDifficultySettingsChanged() && mbRandomizedOnce == false)
					{
						mlNewGameModeToUse = lNewValue;
						mbShowCustomSettingsChangesWillBeLost = true;
						mlCustomSettingsChangesWillBeLost = eCustomSettingsChangesWillBeLost_Randomize;
						msFocusNextFrame = "No";
					}
					///////////////
					// or randomize directly
					else
					{
						RandomizeCustomDifficultySettings();
					}
					
					/////////////
					// Common behaviors
					Sound_PlayGui("special_fx/frontend/frontend_menu_select", 1.0f, eSoundEntryType_Gui);
				}
				
				////////////////
				// InfoBox
				if (bSelected)
				{
					cVector3f vInfoPos = OptionMenu_GetTopLeftOffset(vPos + cVector2f(0,0), 0) + OptionMenu_GetTopLeftOffset( cVector2f(42,0));
					OptionMenu_InfoBox("", vInfoPos, cVector2f(300,200), "RandomizeSettings_Info", mfTransitionAlpha);
				}
			
				msSelectedGameModesBtn = OptionMenu_UpdateFocus(vMenuItems[mlCurrentItemId], msSelectedGameModesBtn);
				++mlCurrentItemId;
			}
		}
		
		//////////////////////////////////////////////////////////////////////////////////
		// New Game Plus Button
		if (mbShowNewGamePlusButton && mbGameCompletedOnce==false)
		{
			const tString sLabel = "NewGamePlusCodeButton";
			bool bSelected = msSelectedGameModesBtn == sLabel;
			cVector2f vPos = cVector2f(100,550);
			
			cImGuiButtonData buttonData = ImGui_GetDefaultButton();
			buttonData.mbUseBackgroundGfx = false;
			buttonData.mbUseInFocusGfx = false;
			buttonData.mbUseTriggeredGfx = false;
			buttonData.mFont.SetFile(FontHandler_GetFont(eFontType_MainMenu,72));
			buttonData.mFont.mvSize = 20;
			buttonData.mFontAlign = eFontAlign_Left;
			buttonData.mFont.mColor =  cColor(1.0, mfTransitionAlpha) * gOptionMenu_ModColor;
			
			if (bSelected)
				buttonData.mFont.mColor = gHoverColor * cColor(1, mfTransitionAlpha);
			
			cVector3f vButtonPos = OptionMenu_GetTopLeftOffset(vPos, 1.0);
			
			if (ImGui_DoButtonExt(sLabel, sLabel, buttonData, vButtonPos, OptionMenu_GetScaledSize(cVector2f(256, 40))))
			{
				mbShowNewGamePlusPopUpMsg = true;
				msFocusNextFrame = "No";
				Sound_PlayGui("special_fx/frontend/frontend_menu_select", 1.0f, eSoundEntryType_Gui);
			}
			
			////////////////
			// InfoBox
			if (bSelected)
			{
				cVector3f vInfoPos = OptionMenu_GetTopLeftOffset(vPos + cVector2f(760,0), 0) + OptionMenu_GetTopLeftOffset( cVector2f(42,0));
				OptionMenu_InfoBox("", vInfoPos, cVector2f(300,200), "NewGamePlusCodeButton_Info", mfTransitionAlpha);
			}
		
			msSelectedGameModesBtn = OptionMenu_UpdateFocus(vMenuItems[mlCurrentItemId], msSelectedGameModesBtn);
			++mlCurrentItemId;
		}
		
		//////////////////////////////////////////////////////////////////////////////////
		// Continue Btn
		if (MainMenu_DoContinueButton(msSelectedGameModesBtn, mfTransitionAlpha))
		{
			mlFirstItemId = 0;
			mlLastInFocus = 0;
			mTargetGroup = eMainMenuGroup_Options_NewGame_Gameplay;
			msSelectedGameplayButton = "Start";
			msTargetFocus = msSelectedGameplayButton;
			mbShowNewGamePlusButton = false;
		}
		
		msSelectedGameModesBtn = OptionMenu_UpdateFocus(vMenuItems[mlCurrentItemId], msSelectedGameModesBtn);
		mlCurrentItemId++;
		
		
		//////////////////////////////////////////////////////////////////////
		// Back Btn
		bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);
		bool bButton = MainMenu_DoBackButton(msSelectedGameModesBtn, mfTransitionAlpha); 
		if(bButton || bGamepad)
		{
			if (mlSelectedGameMode == eGameMode_Custom && GetCustomDifficultySettingsChanged())
			{
				mbShowCustomSettingsChangesWillBeLost = true;
				mlCustomSettingsChangesWillBeLost = eCustomSettingsChangesWillBeLost_BackBtn;
				msFocusNextFrame = "No";
			}
			else
			{
				if (ImGui_TimerExists("TransitionOut") == false)
					ImGui_AddTimer("TransitionOut", 10);
				
				mlFirstItemId = 0;
				mlLastInFocus = mlLastInFocus_SaveSlots;
				mTargetGroup = eMainMenuGroup_SaveSlotSelection;
				msTargetFocus = msSelectedSaveSlotButton;
				mbShowNewGamePlusButton = false;
			}
		}
		
		tString sBtnID = cLux_GetInputHandler().GetGamepadWasLastDeviceUsed() ? "Continue" : "Back";
		msSelectedGameModesBtn = OptionMenu_UpdateFocus(sBtnID, msSelectedGameModesBtn);
		
		//cLux_AddDebugMessage("msSelectedGameModesBtn " + msSelectedGameModesBtn);
		
		if (mbShowCustomSettingsChangesWillBeLost == false)
			GuiHandleTransition(mTargetGroup, msTargetFocus);
		
		// Little hack to make sure save slot selection works when returning to that menu
		if (mCurrentGroup == eMainMenuGroup_SaveSlotSelection)
			mlLastInFocus = mlLastInFocus_SaveSlots;

		//////////////////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
		
		/////////////////////////////////////////////////////
		// NewGame+ cheat button
		if (mbShowNewGamePlusButton==false && mbAnyButtonPressed)
		{
			mfNewGamePlusCheatButtonTime += afTimeStep;
			if (mfNewGamePlusCheatButtonTime > 10.f)
				mbShowNewGamePlusButton = true;
		}
		else if (mfNewGamePlusCheatButtonTime > 0.f)
		{
			mfNewGamePlusCheatButtonTime = 0.f;
		}
	}
	
	//-------------------------------------------------------
	
    int RandomizeInSubInterval( int alSize, int alLowerExclude = 0, int alUpperExclude = 0 )
    {
        int lRand = cMath_RandRectl( 0, alSize-1-alLowerExclude-alUpperExclude );
        return alLowerExclude + lRand;
    }

	void RandomizeCustomDifficultySettings()
	{
		mbRandomizedOnce = true;
		for (int i=0; i<mvCustomSettings_Ids.size(); i++)
		{
			const array<tString> sSettingValues = mvCustomSettings_ValueList[i];
			const int lSettingValueCount = sSettingValues.size();
			const int lSettingID = mvCustomSettings_Ids[i];

            // --------------------------------------------------
            // --------------------------------------------------
            // MOD: NewGamePlus_RandomizationFix
            //   Rigged random values for certain difficulty settings
            //   (also see file: 'config/difficulty_settings.cfg')
            // --------------------------------------------------
            int valueID = RandomizeInSubInterval( lSettingValueCount, 0, 0 );

            switch ( lSettingID )
            {
                case 0:     // GeneratorRunTimePerFuelItem
                    valueID = RandomizeInSubInterval( lSettingValueCount, 0, 1 );   // remove 'Infinite'
                    break;

                case 1:     // DynamoLanternChargeDuration
                    valueID = RandomizeInSubInterval( lSettingValueCount, 0, 0 );
                    break;

                case 2:     // TorchBurnDuration
                    valueID = RandomizeInSubInterval( lSettingValueCount, 0, 1 );   // skip 'Infinite'
                    break;

                case 4:     // ResourceAmount
                    valueID = RandomizeInSubInterval( lSettingValueCount, 0, 0 );
                    break;

                case 25:    // SaveSystem
                    valueID = RandomizeInSubInterval( lSettingValueCount, 0, 0 );
                    break;

                case 26:    // SaveLampLocations
                    valueID = RandomizeInSubInterval( 100, 0, 0 );
                    if( valueID < 15 ){             // 15% - Every Sublevel
                        valueID = 1;
                    }else{                          // 85% - Default (SafeRoom + Tunnels)
                        valueID = 0;
                    }
                    //valueID = 1;                    // force "Every Sublevel"
                    //valueID = 0;                    // force Default

                    break;

                case 6:     // StalkerPresence
                    valueID = RandomizeInSubInterval( lSettingValueCount, 2, 0 );   // remove anything below 'Default'
                    break;

                case 7:     // StalkerReactivity
                    valueID = RandomizeInSubInterval( lSettingValueCount, 2, 0 );   // remove anything below 'Default'
                    break;

                case 8:     // StalkerAggressiveness
                    valueID = RandomizeInSubInterval( lSettingValueCount, 2, 0 );   // remove anything below 'Default'
                    break;

                case 9:     // StalkerRecoverTime
                    valueID = RandomizeInSubInterval( lSettingValueCount, 0, 2 );   // remove anything above 'Default'
                    break;

                case 10:    // StalkerLethality
                    valueID = RandomizeInSubInterval( lSettingValueCount, 1, 0 );   // remove anything below 'Default'
                    break;

                case 12:    // StalkerRetreatBehavior
                    valueID = RandomizeInSubInterval( lSettingValueCount, 0, 0 );
                    break;

                case 11:    // StalkerBulletResistance
                    valueID = RandomizeInSubInterval( lSettingValueCount, 0, 0 );
                    break;

                case 13:    // IncreasedStalkerUnpredictability
                    valueID = RandomizeInSubInterval( 100, 0, 0 );
                    if( valueID < 70 ){             // 70% - Enabled
                        valueID = 1;
                    }else{                          // 30% - Disabled
                        valueID = 0;
                    }
                    break;

                case 14:    // RatsDamage
                    valueID = RandomizeInSubInterval( lSettingValueCount, 0, 0 );
                    break;

                case 15:    // RatsAggressiveness
                    valueID = RandomizeInSubInterval( lSettingValueCount, 0, 0 );
                    break;

                case 16:    // RatCorpseAmount
                    valueID = RandomizeInSubInterval( lSettingValueCount, 0, 0 );
                    break;

                case 33:    // ShotgunnerReactivity
                    valueID = RandomizeInSubInterval( lSettingValueCount, 1, 0 );   // remove anything below 'Default'
                    break;

                case 17:    // ShotgunnerLethality
                    valueID = RandomizeInSubInterval( lSettingValueCount, 2, 0 );   // remove anything below 'Default'
                    break;

                case 18:    // InitialInventorySize
                    // combined weights: 2 + 3 + 1 + 1 = 7
                    valueID = RandomizeInSubInterval( 7, 0, 0 );
                    if( valueID < (0 + 2) ){            //  3 Slots - weight: 2
                        valueID = 0;
                    } else if( valueID < (2 + 3) ){     //  6 Slots - weight: 3
                        valueID = 1;
                    } else if( valueID < (5 + 1) ){     //  9 Slots - weight: 1
                        valueID = 2;
                    } else if( valueID < (6 + 1) ){     // 12 Slots - weight: 1
                        valueID = 3;
                    } else {
                        valueID = 4;                    // 15 Slots - weight: 0
                    }
                    break;

                case 19:    // GamePausedInInventory
                    //valueID = RandomizeInSubInterval( 2, 0, 0 );
                    //valueID = 1;                    // force Enabled
                    valueID = 0;                    // force Disabled
                    break;

                case 20:    // HardcoreHealthSystem
                    valueID = RandomizeInSubInterval( 100, 0, 0 );
                    if( valueID < 70 ){             // 70% - Enabled
                        valueID = 1;
                    }else{                          // 30% - Disabled
                        valueID = 0;
                    }
                    break;

                case 34:    // PlayerHealthRegeneration
                    //valueID = RandomizeInSubInterval( 2, 0, 0 );
                    //valueID = 1;                    // force Enabled
                    valueID = 0;                    // force Disabled
                    break;

                case 21:    // GrenadePlayerDamageRadius
                    // -----------------------------------------------------------------------------
                    // --------- keep original chances, but remove 'Short' (50%-25%-25%) -----------
                    // -----------------------------------------------------------------------------
                    //valueID = RandomizeInSubInterval( lSettingValueCount, 0, 0 );
                    //if( valueID == 0 ){
                    //    valueID = 1;
                    //}

                    // -----------------------------------------------------------------------------
                    // --- even distribution (33% for harder settings, instead of original 25%) ----
                    // -----------------------------------------------------------------------------
                    valueID = RandomizeInSubInterval( lSettingValueCount, 1, 0 );
                    // -----------------------------------------------------------------------------

                    break;
                case 22:    // PlayerDamageFromGasFire
                    // -----------------------------------------------------------------------------
                    // --------- keep original chances, but remove 'Low' (50%-25%-25%) -------------
                    // -----------------------------------------------------------------------------
                    valueID = RandomizeInSubInterval( lSettingValueCount, 0, 0 );
                    if( valueID == 0 ){
                        valueID = 1;
                    }

                    // -----------------------------------------------------------------------------
                    // --- even distribution (33% for harder settings, instead of original 25%) ----
                    // -----------------------------------------------------------------------------
                    //valueID = RandomizeInSubInterval( lSettingValueCount, 1, 0 );
                    // -----------------------------------------------------------------------------

                    break;
                case 27:    // FusesAndFuseBoxes
                    valueID = RandomizeInSubInterval( 100, 0, 0 );
                    if( valueID < 70 ){             // 70% - Enabled
                        valueID = 1;
                    }else{                          // 30% - Disabled
                        valueID = 0;
                    }

                    //valueID = 0;    // force Disabled
                    //valueID = 1;    // force Enabled
                    break;

                case 28:    // InitialPoweredFuseBoxes
                    // combined weights: 3 + 3 + 1 + 1 = 8
                    valueID = RandomizeInSubInterval( 8, 0, 0 );
                    if( valueID < (0 + 3) ){            //  None - weight: 3
                        valueID = 0;
                    } else if( valueID < (3 + 3) ){     //  One  - weight: 3
                        valueID = 1;
                    } else if( valueID < (6 + 1) ){     //  Two  - weight: 1
                        valueID = 2;
                    } else {
                        valueID = 3;                    //  Three - weight: 1
                    }
                    break;

                case 29:    // ReducedSafeRoom
                    valueID = RandomizeInSubInterval( 100, 0, 0 );
                    if( valueID < 85 ){             // 85% - Enabled
                        valueID = 1;
                    }else{                          // 15% - Disabled
                        valueID = 0;
                    }
                    //valueID = 1;    // force Enabled
                    break;
                case 30:    // RevolverInLocker
                    valueID = RandomizeInSubInterval( 100, 0, 0 );
                    if( valueID < 80 ){             // 80% - Enabled
                        valueID = 1;
                    }else{                          // 20% - Disabled
                        valueID = 0;
                    }
                    //valueID = 1;    // force Enabled
                    break;
                case 31:    // RandomizedLockerLocations
                    valueID = RandomizeInSubInterval( 100, 0, 0 );
                    if( valueID < 75 ){             // 75% - Enabled
                        valueID = 1;
                    }else{                          // 25% - Disabled
                        valueID = 0;
                    }
                    //valueID = 1;    // force Enabled
                    break;
                case 35:    // FuelStorageCodeLock
                    valueID = RandomizeInSubInterval( 100, 0, 0 );
                    if( valueID < 85 ){             // 85% - Enabled
                        valueID = 1;
                    }else{                          // 15% - Disabled
                        valueID = 0;
                    }
                    //valueID = 1;    // force Enabled
                    break;

                case 23:    // FireDuration
                    valueID = RandomizeInSubInterval( 3, 0, 0 );
                    break;

                case 24:    // GasDuration
                    valueID = RandomizeInSubInterval( 3, 0, 0 );
                    break;

                default:
                    valueID = cMath_RandRectl(0, lSettingValueCount-1);
                    break;
            }

            const int lRndValueID = valueID;
            // --------------------------------------------------
            //   end of content
            // MOD: NewGamePlus_RandomizationFix
            // --------------------------------------------------
            // --------------------------------------------------


			mvInitialCustomDifficultySettingValueIDs.resize(0);
			mvInitialCustomDifficultySettingValueIDs = GameDifficulty_GetSettingsSelectedValueIDs();
			GameDifficulty_SetSettingValueIdByID(lSettingID, lRndValueID);
			mlSelectedGameMode = GetGameModeThatMatchesTheCurrentSettings();
		}
	}
	
	//-------------------------------------------------------
	
	void GuiDisplayDifficultySettings()
	{
		GuiPauseDarkOverlay();
		ImGui_SetTransCategory("Menu");
		array<tString> vMenuItems = {"Back"};
		
		///////////////////////
		// Check screen ratio
		const cVector2l vResolution = cVector2l(mpConfig.GetInt("Screen", "Width", 1280), mpConfig.GetInt("Screen", "Height", 720));
		const cVector2l vScreenRatio = GetScreenRatio(vResolution.x, vResolution.y);
		bool bIsSquareScreen = vScreenRatio == cVector2l(4,3) || vScreenRatio == cVector2l(5,4) || vScreenRatio == cVector2l(8,5) || vScreenRatio == cVector2l(25,16);
		//cLux_AddDebugMessage("vScreenRatio " + vScreenRatio);
		///////////////////////////////////////////
		// Setup page
		for (int i=0; i<vMenuItems.size(); i++)
		{
			OptionMenu_UpdateButtonWidth(vMenuItems[i]);
		}
		
		OptionMenu_UpdateToggleExtraWidth();
		OptionMenu_AlignExtraButtonWidth();
		
		cVector2f vMenuPos = kOptionsBgPos + cVector2f(0,-160);
		if (bIsSquareScreen)
			vMenuPos.x -= 30;
		cVector2f vMenuSize = kOptionsDisplayDifficultySettingsBgSize + cVector2f(gfOptionsMenu_ExtraWidth, 0);
		cVector2f vRightAnchor = cVector2f(vMenuPos.x + vMenuSize.x, 0);
		DoBackground(vRightAnchor.x);
		
		tWString sTitle = ImGui_Translate("DifficultySettingsTitle");
		sTitle += " (" + ImGui_Translate(GetGameModeNameByID(Game_GetDifficultyMode())) + ")";
		
		OptionMenu_SectionTitle(sTitle, vMenuPos + cVector2f(40,-40), 1.f, mfTransitionAlpha);
		ImGui_DrawGfx(cImGuiGfx(), OptionMenu_GetTopLeftOffset(vMenuPos + cVector2f(25, 10.0), 0.01), OptionMenu_GetScaledSize(cVector2f(vMenuSize.x - 83,2)), cColor(1, mfTransitionAlpha) * gOptionMenu_ModColor * 0.5);
		
		mlFirstItemId = 0;
		mlCurrentItemId = mlFirstItemId;
		OptionMenu_SetOutOfLimit(vMenuItems.length());
		
		//////////////////////////////////////////
		// Draw current settings
		cImGuiLabelData labelData;
		labelData.mFont.SetFile(FontHandler_GetFont(eFontType_MainMenu, 56));
		labelData.mFont.mvSize = bIsSquareScreen ? gfFontSize_MainMenu_Small * 0.7 : gfFontSize_MainMenu_Small;
		
		labelData.mbScrolling = true;
		labelData.mfScrollSpeed = 20.f;
		labelData.mfScrollResetDelay = 1.f;
		labelData.mfScrollStartDelay = 1.f;
		
		const float fLineSpacing = 28.f;
		const float fRowSpacing = bIsSquareScreen ? 440.f : 540.f;
		const float fLineSize = bIsSquareScreen ? 250.f : 350.f;
		const int lRowSize = cMath_RoundToInt(mvCustomSettings_Ids.size() / 2)-1;
		const float fDrawDepth = 20.f;
		const float fLabelSpacing = bIsSquareScreen ? 290.f : 420.f;
			
		for (uint i=0; i<mvCustomSettings_Ids.size(); i++)
		{
			///////////////////////////
			// Draw label
			const tString sName = mvCustomSettings_Names[i];
			const uint lID = mvCustomSettings_Ids[i];
			
			/////////////////////
			// Get 2st row length for positioning the second row
			const bool bIsInSecondRow = (i > lRowSize);
			
			float fX = vMenuPos.x + (bIsSquareScreen ? 0 : 40);
			if (bIsInSecondRow)
				fX += fRowSpacing;
			
			float fY = vMenuPos.y + 25;
			fY += bIsInSecondRow ? ( fLineSpacing * ((i - lRowSize) - 1) ) : (fLineSpacing * i);
			
			labelData.mColorBase = cColor(1.0, mfTransitionAlpha) * gOptionMenu_ModColor;
			//const float fFontWidth = GetFontLengthW(labelData.mFont, 1.f, sName);
			
			const cVector3f vNamePos = OptionMenu_GetTopLeftOffset(cVector2f(fX, fY), fDrawDepth);
			cVector2f vNameSize = OptionMenu_GetScaledSize(cVector2f(fLineSize, -1));
			labelData.mFontAlign = eFontAlign_Left;
			ImGui_DoLabelExt(sName, labelData, vNamePos, vNameSize);
			
			/////////////////////
			// Draw selected value
			const tString sSelectedSettingName = GameDifficulty_GetSettingValueNameByID(lID);
			labelData.mColorBase = cColor(1, 0.75, 0.25, mfTransitionAlpha) * gOptionMenu_ModColor;
			cVector3f vLabelPos = vNamePos;
			labelData.mFontAlign = eFontAlign_Right;
			vLabelPos.x += fLabelSpacing;
			cVector2f vLabelSize = OptionMenu_GetScaledSize(cVector2f(160, -1));
			ImGui_DoLabelExt(sSelectedSettingName, labelData, vLabelPos, vLabelSize);
		}
		
		//////////////////////////////////////////////////////////////////////
		// Back Btn
		bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);
		bool bButton = MainMenu_DoBackButton(msSelectedDisplayDIfficultySettingsBtn, mfTransitionAlpha); 
		if(bButton || bGamepad)
		{
			if (ImGui_TimerExists("TransitionOut") == false)
				ImGui_AddTimer("TransitionOut", 10);
			
			mlFirstItemId = 0;
			mlLastInFocus = 0;
			mTargetGroup = eMainMenuGroup_Main;
			msTargetFocus = msSelectedMainMenuButton;
		}
		
		tString sBtnID = cLux_GetInputHandler().GetGamepadWasLastDeviceUsed() ? "" : "Back";
		msSelectedDisplayDIfficultySettingsBtn = OptionMenu_UpdateFocus(sBtnID, msSelectedDisplayDIfficultySettingsBtn);
		
		GuiHandleTransition(mTargetGroup, msTargetFocus);

		//////////////////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(false, true, cVector2f(0), false);
	}
	
	//-------------------------------------------------------
	
	void GuiSaveSlotSelection()
	{
		GuiPauseDarkOverlay();
		
		ImGui_SetTransCategory("Menu");
		
		array<tString> vMenuItems = {"SaveSlotLabel1", "SaveSlotLabel2", "SaveSlotLabel3"};
		
		if (cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false)
			vMenuItems.push_back("Back");
		
		for (int i=0; i<vMenuItems.length(); i++)
		{
			OptionMenu_UpdateButtonWidth(vMenuItems[i]);
		}
		
		OptionMenu_AlignExtraButtonWidth();
		OptionMenu_UpdateToggleExtraWidth();
		
		cVector2f vSize = kSaveSlotSelectionBgSize + cVector2f(gfOptionsMenu_ExtraWidth, 0);
		cVector2f vRightAnchor = cVector2f(kSaveSlotSelectionPos.x + vSize.x, 0);
		DoBackground(vRightAnchor.x + 100);
		
		////////////////
		// Page Title
		OptionMenu_SectionTitle("SaveSlots", kOptionsBgPos + cVector2f(40,-120), 1.f, mfTransitionAlpha);
		mlCurrentItemId = mlFirstItemId;
		OptionMenu_SetOutOfLimit(vMenuItems.length());
		
		///////////////////////
		// Page description
		cImGuiLabelData txtLabel;
		txtLabel.mbUseBackgroundGfx = false;
		txtLabel.mFont.mvSize = 20;
		txtLabel.mFont.mColor = cColor(1.0, mfTransitionAlpha) * gOptionMenu_ModColor;
		txtLabel.mFont.SetFile(FontHandler_GetFont(eFontType_MainMenu_InfoBox, 56));
		cVector2f vTitlePos = kOptionsBgPos + cVector2f(40, -60);
		ImGui_DoLabelExt("SaveSlot_Desc", txtLabel, OptionMenu_GetTopLeftOffset(vTitlePos, 0.5), 1.f);
		
		/////////////////////
		// Draw the save slots		
		for(int i = 0; i < 3; ++i)
		{
			tWString sSuffixName = cString_To16Char("slot"+(i+1));
			int lGameMode = -1;
			tString sDate = "MM/DD/YYYY";
			tWString sDisplayedName = "";
			
			////////////////////////
			// Check if the slot is used and draw some info about it.
			for(uint j = 0; j<mvSaveFiles.size(); ++j)
			{
				if(mvSaveSuffix[j] == sSuffixName)
				{
					lGameMode = lGameMode = (mvSaveModeSuffix[j].length()>0 ? cString_GetNumericSuffixIntW(mvSaveModeSuffix[j]) : 1);
					int lSep = cString_GetFirstCharPos(mvSaveDates[j],'-');
					sDate = cString_Sub(mvSaveDates[j],0,lSep) + "/" + cString_Sub(mvSaveDates[j],lSep+3);
					sDisplayedName = mvSaveNames[j];

					int lSubPos = cString_GetFirstStringPosW(sDisplayedName, tWString("AutoSave"));
					if(lSubPos>=0)
					{
						sDisplayedName = cString_SubW(sDisplayedName, lSubPos+8, -1);
					}
					break;
				}
			}
			
			bool bSmallFont = false;
			{
				cConfigFile@ pConfig = cLux_GetUserConfig();
				tString sLang = cString_SetFileExt(pConfig.GetString("Main", "StartLanguage", cLux_GetDefaultGameLanguage()), "");
				bSmallFont = (sLang=="brazilian_portuguese") || (sLang=="spanish")  || (sLang=="german") ;
			}
			
			//////////////////
			// Draw save slot button
			tString sSlotName = vMenuItems[i];
			if (OptionMenu_SaveSlot(lGameMode, sSlotName, sDisplayedName, sDate, kSaveSlotSelectionPos + kSaveSlotSelectionSpacing * i, "", sSlotName==msSelectedSaveSlotButton, mfTransitionAlpha, bSmallFont))
			{
				//////////////
				// Contains saves?
				if (lGameMode != -1)
				{
					mlSelectedSaveSlot = i+1;
					
					mbShowOverwriteSaveSlot = true;
					msFocusNextFrame = "No";
					msMessageBoxFocus = "No";
				}
				/////////////////////
				// Empty, start a new game
				else
				{
					mlSelectedSaveSlot = i+1;
					
					mlFirstItemId = 0;
					mlLastInFocus_SaveSlots = mlLastInFocus;
					mlLastInFocus = 0;
					mTargetGroup = eMainMenuGroup_GameModes;
					msSelectedGameModesBtn = "DifficultyMode";
					msTargetFocus = msSelectedGameModesBtn;
					
					//////////////////////////////////
					// Always suggest the normal game mode
					mlSelectedGameMode = eGameMode_Normal;
					GameDifficulty_SwitchSettingsPresetTo(eGameMode_Normal);
					
					if (ImGui_TimerExists("TransitionOut") == false)
						ImGui_AddTimer("TransitionOut", 10);
				}
			}
			
			msSelectedSaveSlotButton = OptionMenu_UpdateFocusCustom(vMenuItems, vMenuItems[mlCurrentItemId], msSelectedSaveSlotButton);
			if (i < 3)
				mlCurrentItemId++;
		}
		
		bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);
		
		/////////////////
		// Back
		{
			bool bButton = MainMenu_DoBackButton(msSelectedSaveSlotButton, mfTransitionAlpha);
			
			if(bButton || bGamepad)
			{
				mlSelectedSaveSlot = mlPreviouslySelectedSaveSlot; //revert save slot selection
				mlSelectedGameMode = mlPrevSelectedGameMode;
				GameDifficulty_SwitchSettingsPresetTo(mlPrevSelectedGameMode);

				cLux_AddDebugMessage("[MainMenu] Reverting save suffix to: " + mlSelectedSaveSlot);
				
				if (ImGui_TimerExists("TransitionOut") == false)
					ImGui_AddTimer("TransitionOut", 10);
				
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				mTargetGroup = eMainMenuGroup_Main;
				msTargetFocus = msSelectedMainMenuButton;
			}
			
			if (cLux_GetInputHandler().GetGamepadWasLastDeviceUsed() == false)
				msSelectedSaveSlotButton = OptionMenu_UpdateFocusCustom(vMenuItems, "Back", msSelectedSaveSlotButton);
		}
		
		//cLux_AddDebugMessage("msSelectedSaveSlotButton " + msSelectedSaveSlotButton);
		
		if (mbShowOverwriteSaveSlot==false)
			GuiHandleTransition(mTargetGroup, msTargetFocus);

		//////////////////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
		
		DoCustomScrollInput(vMenuItems, true);
	}
	
	//-------------------------------------------------------
	
	eMainMenuGroup mTargetGroup;
	tString msTargetFocus;

	void GuiMainMenuSelection()
	{
		int lEntryPos = 0;
	
		///////////////////////////
		// Show current user
		OptionMenu_ShowCurrentUser(true);
		
		///////////////////////////
		// Draw Background
		tString sLang = cLux_GetCurrentLanguage();
		
		float fBGAdd = 0.f;
		if 		(sLang == "french.lang") 				fBGAdd = 50.f;
		else if (sLang == "german.lang") 				fBGAdd = 75.f;
		else if (sLang == "spanish.lang") 				fBGAdd = 50.f;
		else if (sLang == "brazilian_portuguese.lang") 	fBGAdd = 50.f;
		
		DoBackground(kTitleSize.x + 100 + fBGAdd);
		
		/////////////////
		// Continue 
		if (mbSaveLoadEnabled)
		{
			if(mbCanContinue && mbGameOver == false)
			{
				if(OptionMenu_MainMenuButton("Continue", kMainMenuButtonPos, lEntryPos, eMainMenuButtonID_Continue, msSelectedMainMenuButton, mlClickedMainMenuButton, mfTransitionAlpha))
				{
					mlClickedMainMenuButton = eMainMenuButtonID_Continue;
					Sound_Stop("MenuBGNoise", 2.0f);
					Music_StopAll(2.0f);
					//Sound_PlayGui("special_fx/frontend/new_game_sting", 1.0f, eSoundEntryType_Gui);
				}
					
				msSelectedMainMenuButton = OptionMenu_UpdateFocus("Continue", msSelectedMainMenuButton);
			}
			else
			{
				//////////////
				// Not possible to continue, disable it and render it as a label instead
				OptionMenu_MainMenuDisabledButton("Continue", kMainMenuButtonPos, lEntryPos, mfTransitionAlpha/2);
			}
					
			++lEntryPos;
		}
		
		/////////////////
		// New Game 
		{
			if(OptionMenu_MainMenuButton("NewGame", kMainMenuButtonPos, lEntryPos, eMainMenuButtonID_NewGame, msSelectedMainMenuButton, mlClickedMainMenuButton, mfTransitionAlpha))
			{
				mlClickedMainMenuButton = eMainMenuButtonID_NewGame;
			}
			
			msSelectedMainMenuButton = OptionMenu_UpdateFocus("NewGame", msSelectedMainMenuButton);
			
			++lEntryPos;
		}
		
		/////////////////
		// Load Game 
		if (mbSaveLoadEnabled)
		{
			if(mbCanContinue && mvSaveFiles.size() > 0)
			{
				if(OptionMenu_MainMenuButton("LoadGame", kMainMenuButtonPos, lEntryPos, eMainMenuButtonID_LoadGame, msSelectedMainMenuButton, mlClickedMainMenuButton, mfTransitionAlpha))
				{
					mlClickedMainMenuButton = eMainMenuButtonID_LoadGame;
				}
			
				msSelectedMainMenuButton = OptionMenu_UpdateFocus("LoadGame", msSelectedMainMenuButton);
			}
			else
			{
				//////////////
				// No games to load
				OptionMenu_MainMenuDisabledButton("LoadGame", kMainMenuButtonPos, lEntryPos, mfTransitionAlpha/2);
			}
		
			++lEntryPos;
		}
		
		///////////////////////////////
		// Training Grounds
		if (GetGameCompletedOnce())
		{
			if(OptionMenu_MainMenuButton("TrainingGrounds", kMainMenuButtonPos, lEntryPos, eMainMenuButtonID_TrainingGrounds, msSelectedMainMenuButton, mlClickedMainMenuButton, mfTransitionAlpha))
			{
				mlClickedMainMenuButton = eMainMenuButtonID_TrainingGrounds;
			}
			
			msSelectedMainMenuButton = OptionMenu_UpdateFocus("TrainingGrounds", msSelectedMainMenuButton);
			++lEntryPos;
		}
		
		/////////////////
		// Custom stories
		if(gbCustomStoriesEnabled && Platform_IsConsole() == false)
		{
			if(OptionMenu_MainMenuButton("Mods", kMainMenuButtonPos, lEntryPos, eMainMenuButtonID_CustomStories, msSelectedMainMenuButton, mlClickedMainMenuButton, mfTransitionAlpha))
			{
				mlClickedMainMenuButton = eMainMenuButtonID_CustomStories;
			}
		
			msSelectedMainMenuButton = OptionMenu_UpdateFocus("Mods", msSelectedMainMenuButton);
			++lEntryPos;
		}
		
		/////////////////
		// Options
		{
			if(OptionMenu_MainMenuButton("Options", kMainMenuButtonPos, lEntryPos, eMainMenuButtonID_Options, msSelectedMainMenuButton, mlClickedMainMenuButton, mfTransitionAlpha))
			{
				mlClickedMainMenuButton = eMainMenuButtonID_Options;
			}
		
			msSelectedMainMenuButton = OptionMenu_UpdateFocus("Options", msSelectedMainMenuButton);
			
			++lEntryPos;
		}
		
		/////////////////
		// Gamma
		{
			if(OptionMenu_MainMenuButton("Gamma", kMainMenuButtonPos, lEntryPos, eMainMenuButtonID_Gamma, msSelectedMainMenuButton, mlClickedMainMenuButton, mfTransitionAlpha))
			{
				mlClickedMainMenuButton = eMainMenuButtonID_Gamma;
				
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				mTargetGroup = eMainMenuGroup_Options_Display_Gamma;
				msSelectedGammaButton = "Gamma";
				msTargetFocus = msSelectedOptionsButton;
				
				mbShowingGammaMenu = true;
			}

			msSelectedMainMenuButton = OptionMenu_UpdateFocus("Gamma", msSelectedMainMenuButton);
			lEntryPos++;
		}
						
		/////////////////
		// Exit
		if(Platform_IsConsole() == false || Platform_IsStreaming())
		{
			if(OptionMenu_MainMenuButton("Exit", kMainMenuButtonPos, lEntryPos, eMainMenuButtonID_QuitToDesktop, msSelectedMainMenuButton, mlClickedMainMenuButton, mfTransitionAlpha))
			{
				mlClickedMainMenuButton = eMainMenuButtonID_QuitToDesktop;
			}

			msSelectedMainMenuButton = OptionMenu_UpdateFocus("Exit", msSelectedMainMenuButton);
		}
		
		{
			/////////////////
			// After the delay, perform the button click
			if (ImGui_TimerOver("ButtonClicked"))
				ImGui_StopTimer("ButtonClicked");

			switch(mlClickedMainMenuButton)
			{
			case eMainMenuButtonID_Continue: 
				///////////
				// Load the last save
				ImGui_AddTimer("Continue", gfContinueGameFadeOutTime);
				cSound_FadeOutAll(eSoundEntryType_WorldAll, 1.0f / gfContinueGameFadeOutTime, false);
				Music_StopAll(mfFadeLength);
				Sound_Stop("MenuBGNoise", mfFadeLength);
				cLux_GetGuiHandler().SetGameHudInputFocus(false);
				return;

				//break;
			case eMainMenuButtonID_NewGame:
				// New game
				mlPreviouslySelectedSaveSlot = mlSelectedSaveSlot;
				mlPrevSelectedGameMode = mlSelectedGameMode;
				cLux_AddDebugMessage("[MainMenu] Previously selected save suffix is: " + mlPreviouslySelectedSaveSlot);
				
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				mTargetGroup = eMainMenuGroup_SaveSlotSelection;
				
				msSelectedSaveSlotButton = "";
				
				for (int i = 0; i < mvSaveSlots.size(); ++i)
				{
					cSaveSlot@ pSlot = mvSaveSlots[i];
					if (pSlot is null) continue;
					if (pSlot.mvSlotSaveFiles.size() > 0) continue;
					
					msSelectedSaveSlotButton = "SaveSlotLabel" + pSlot.mlId;
					mlLastInFocus = pSlot.mlId - 1;
					break;
				}
					
				if (msSelectedSaveSlotButton == "")
					msSelectedSaveSlotButton = "SaveSlotLabel1";
				
				msTargetFocus = msSelectedSaveSlotButton;
				break;
			case eMainMenuButtonID_LoadGame:
				// Load
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				mTargetGroup = eMainMenuGroup_LoadGame;
				
				for (int i = 0; i < mvSaveSlots.size(); ++i)
				{
					cSaveSlot@ pSlot = mvSaveSlots[i];
					if (pSlot is null) continue;
					if (pSlot.mvSlotSaveFiles.size() == 0) continue;
					
					msSelectedLoadGameButton = "SaveSlotLabel" + pSlot.mlId;
					break;
				}
				
				msTargetFocus = msSelectedLoadGameButton;
				break;
				// Training grounds
			case eMainMenuButtonID_TrainingGrounds:
				ImGui_AddTimer("TrainingGrounds", gfContinueGameFadeOutTime * 0.5f);
				cSound_FadeOutAll(eSoundEntryType_WorldAll, 1.0f / (gfContinueGameFadeOutTime * 0.5f), false);
				Music_StopAll(mfFadeLength);
				Sound_Stop("MenuBGNoise", mfFadeLength);
				cLux_GetGuiHandler().SetGameHudInputFocus(false);
				return;
			case eMainMenuButtonID_Options:
				// Open options and set focus
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				cLux_AddDebugMessage("TARGET GROUP OPTIONS. SELECTED: "+msSelectedOptionsButton);
				mTargetGroup = eMainMenuGroup_Options;
				msTargetFocus = msSelectedOptionsButton;
				break;
			case eMainMenuButtonID_QuitToDesktop:
				// Exit
				mbShowExit = true;
				msFocusNextFrame = "No";
				msMessageBoxFocus = "No";
				break;
			case eMainMenuButtonID_CustomStories:
				// Custom stories
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				mTargetGroup = eMainMenuGroup_CustomStories;
				//mCurrentGroup = eMainMenuGroup_CustomStories;
				msTargetFocus = "Back";
				
				cLux_GetModHandler().CleanUpListing();
				cLux_GetModHandler().PrepareListing();
								
				break;
			}
			
			mlClickedMainMenuButton = -1;
		}
			
		// Transition is skipped in OptionMenu_MainMenuButton
		if (mbShowExit == false)
			GuiHandleTransition(mTargetGroup, msTargetFocus);
		
		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true, false);
	}

	
	//-------------------------------------------------------
	
	void ResetBlur()
	{
		if (mlBlurID > -1)
		{
			Effect_Blur_FadeOut(mlBlurID,0);
			mlBlurID = -1;
		}
	}
	
	//-------------------------------------------------------
	
	void GuiPauseDarkOverlay(float afAlpha=0.2)
	{
		if (cLux_GetGamePaused() == false) return;
		
		//cImGuiGfx blackImage("simple_black.dds", eImGuiGfx_Texture);
		cImGuiGfx blackImage;
		blackImage.mColor = cColor(0,0,0,afAlpha);
		ImGui_DoImage(blackImage, ImGui_FullScreenPos(14.0f), ImGui_FullScreenSize());
	}
	
	//-------------------------------------------------------
	
	void GuiPauseMenuSelection()
	{
		GuiPauseDarkOverlay();
		
		cVector2f vBgSize = (Platform_IsConsole()) ? kOptionsBgSizePS4 : kOptionsBgSize;
		cVector2f vRightAnchor = cVector2f(kOptionsBgPos.x + vBgSize.x, 0);
		DoBackground(vRightAnchor.x + 100);
		
		int lEntryPos = 0;
		/////////////////
		// Return To Game
		{
			if(OptionMenu_MainMenuButton("ReturnToGame", kOptionsButtonPos, lEntryPos, eMainMenuButtonID_ReturnToGame, msSelectedPauseMenuButton, mlClickedPauseMenuButton, mfTransitionAlpha))
			{
				mlClickedPauseMenuButton = eMainMenuButtonID_ReturnToGame;
			}

			msSelectedPauseMenuButton = OptionMenu_UpdateFocus("ReturnToGame", msSelectedPauseMenuButton);
		}
		++lEntryPos;
		
		/////////////////
		// Load Last Save 
		if (mbSaveLoadEnabled == false)
		{
		}
		else
		{
			if(mbCanContinue && mbGameOver==false && Map_IsChanging()==false)
			{
				if(OptionMenu_MainMenuButton("LoadLastSave", kOptionsButtonPos, lEntryPos, eMainMenuButtonID_Continue, msSelectedPauseMenuButton, mlClickedPauseMenuButton, mfTransitionAlpha))
				{
					mlClickedPauseMenuButton = eMainMenuButtonID_Continue;
					//Music_StopAll(1.f);
					//Sound_PlayGui("special_fx/frontend/new_game_sting", 1.0f, eSoundEntryType_Gui);
				}
					
				msSelectedPauseMenuButton = OptionMenu_UpdateFocus("LoadLastSave", msSelectedPauseMenuButton);
			}
			//////////////
			// Not possible to load, disable it and render it as a label instead
			else
			{
				OptionMenu_MainMenuDisabledButton("LoadLastSave", kOptionsButtonPos, lEntryPos, mfTransitionAlpha/2);
			}
			++lEntryPos;
		}
		
		/////////////////
		// Options
		{
			if(OptionMenu_MainMenuButton("Options", kOptionsButtonPos, lEntryPos, eMainMenuButtonID_Options, msSelectedPauseMenuButton, mlClickedPauseMenuButton, mfTransitionAlpha))
			{
				mlClickedPauseMenuButton = eMainMenuButtonID_Options;
			}
		
			msSelectedPauseMenuButton = OptionMenu_UpdateFocus("Options", msSelectedPauseMenuButton);
		}
		++lEntryPos;
		
		///////////////////////
		// Difficulty settings listing
		if (GetGameCompletedOnce())
		{
			if(OptionMenu_MainMenuButton("DisplayDifficultySettings", kOptionsButtonPos, lEntryPos, eMainMenuButtonID_Continue, msSelectedPauseMenuButton, mlClickedPauseMenuButton, mfTransitionAlpha))
			{
				mlClickedPauseMenuButton = eMainMenuButtonID_DisplayDifficultySettings;
			}
			
			msSelectedPauseMenuButton = OptionMenu_UpdateFocus("DisplayDifficultySettings", msSelectedPauseMenuButton);
			++lEntryPos;
		}
		
		/////////////////
		// Quit to Menu
		{
			if(OptionMenu_MainMenuButton("QuitToMainMenu", kOptionsButtonPos, lEntryPos, eMainMenuButtonID_QuitToMenu, msSelectedPauseMenuButton, mlClickedPauseMenuButton, mfTransitionAlpha))
			{
				mlClickedPauseMenuButton = eMainMenuButtonID_QuitToMenu;
			}
			
			msSelectedPauseMenuButton = OptionMenu_UpdateFocus("QuitToMainMenu", msSelectedPauseMenuButton);
			lEntryPos++;
		}
		
		/////////////////
		// Quit to Desktop
		if(Platform_IsConsole() == false || Platform_IsStreaming())
		{
			if(OptionMenu_MainMenuButton("QuitToDesktop", kOptionsButtonPos, lEntryPos, eMainMenuButtonID_QuitToDesktop, msSelectedPauseMenuButton, mlClickedPauseMenuButton, mfTransitionAlpha))
			{
				mlClickedPauseMenuButton = eMainMenuButtonID_QuitToDesktop;
			}

			msSelectedPauseMenuButton = OptionMenu_UpdateFocus("QuitToDesktop", msSelectedPauseMenuButton);
		}

		//////////////
		// Show playgo?
		int64 lETA = 0;
		if(cLux_IsPlayGoReady(lETA) == false && cScript_GetGlobalVarBool("PlayGo"))
		{
			//////////////
			// Display text telling the player that they cant progress yet
			float fPulse = ImGui_FadeOscillateFloat("PlayGoPulse", 1, 0.8f, 1.5);
			cImGuiLabelData labelData;
			labelData.mFont.SetFile(FontHandler_GetFont(eFontType_MainMenu_InfoBox, 56));
			labelData.mFont.mvSize = cVector2f(24, 24);
			labelData.mFont.mColor = cColor(fPulse,fPulse);
			labelData.mFontAlign = eFontAlign_Center;
			
			ImGui_DoLabelExt("PlayGoInstructions",labelData, OptionMenu_GetTopLeftOffset(kOptionsButtonPos - cVector2f(150, 100), 1.0), cVector2f(1000, 32));

			///////////////
			// Time left to progress
			tString sCat = ImGui_GetTransCategory();
			ImGui_SetTransCategory("");

			int64 lSeconds = lETA % 60;
			int64 lMinutes = (lETA / 60) % 60;
			int64 lHour = (lETA / 3600);

			tString sTime;

			if(lHour > 9) sTime += lHour + ":";
			else if(lHour > 0) sTime += "0"+lHour + ":";
			
			if(lMinutes > 9) sTime += lMinutes + ":";
			else if(lMinutes > 0) sTime += "0"+lMinutes + ":";

			if(lSeconds > 9) sTime += lSeconds;
			else if(lSeconds > 0) sTime += "0"+lSeconds;

			ImGui_DoLabelExt(sTime,labelData, OptionMenu_GetTopLeftOffset(kOptionsButtonPos - cVector2f(150, 64), 1.0), cVector2f(1000, 32));
			ImGui_SetTransCategory(sCat);
		}

		if(ImGui_ActionTriggered(eImGuiAction_Cancel, true))
		{
			///////////////
			// Disable menu
			SetMenuActive(false);
			ResetBlur();
			mfTransitionAlpha = 1;
			msSelectedPauseMenuButton = "ReturnToGame";
			return;
		}

		//if(ImGui_TimerOver("ButtonClicked"))
		{
			/////////////////
			// After the delay, perform the button click
			ImGui_StopTimer("ButtonClicked");

			switch(mlClickedPauseMenuButton)
			{
				
			case eMainMenuButtonID_ReturnToGame: 
				// return to game
				SetMenuActive(false);
				ResetBlur();
				mfTransitionAlpha = 1;
				break;
				
			case eMainMenuButtonID_Continue: 
				mbShowLoadGame = true;
				msFocusNextFrame = "No";
				msMessageBoxFocus = "No";
				break;
				
			case eMainMenuButtonID_Options:
				// Options
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				cLux_AddDebugMessage("CURR TARGET: "+mTargetGroup);
				mTargetGroup = eMainMenuGroup_Options;
				cLux_AddDebugMessage("NEW TARGET: "+mTargetGroup);
				msTargetFocus = msSelectedOptionsButton;
				//cLux_AddDebugMessage(msSelectedOptionsButton);
				break;
				
			case eMainMenuButtonID_DisplayDifficultySettings:
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				GameDifficulty_GetSettingsDisplayData(mvCustomSettings_Ids, mvCustomSettings_Names, mvCustomSettings_ControlTypes, mvCustomSettings_ValueList, mvReliesOn_SettingID, mvReliesOn_DisablingValueIDs, mvCustomSettings_Active);
				mTargetGroup = eMainMenuGroup_DisplayDifficultySettings;
				msTargetFocus = msSelectedGameModesBtn;
				break;

			case eMainMenuButtonID_QuitToMenu:
				// Exit to menu
				mbExitToMainMenu = true;
				mbShowExit = true;
				msFocusNextFrame = "No";
				msMessageBoxFocus = "No";
				break;
				
			case eMainMenuButtonID_QuitToDesktop:
				// Exit to desktop
				mbExitToMainMenu = false;
				mbShowExit = true;
				msFocusNextFrame = "No";
				msMessageBoxFocus = "No";
				break;
			}

			mlClickedPauseMenuButton = -1;
		}
		
		if (mbShowExit == false)
			GuiHandleTransition(mTargetGroup, msTargetFocus);
		
		/////////////////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
	}
	
	//-------------------------------------------------------
	
	bool mbExitToMainMenu = false;
	int mlOptionItemId;
	
	void DoOptionsItem(const array<tString> &in avMenuItems, const tString &in asName, eMainMenuGroup aGroup, const tString &in asFocusNextFrame, cVector2f avRightAnchor, cVector3f avInfoBoxPos, float afAlpha, bool abSubMenuButton = false)
	{
		//cLux_AddDebugMessage("SELECTED OPT: "+msSelectedOptionsButton);
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			if(OptionMenu_ButtonOptions(asName, kOptionsButtonPos, mlCurrentItemId, msSelectedOptionsButton, abSubMenuButton, avRightAnchor, avInfoBoxPos, afAlpha))
			{
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				mTargetGroup = aGroup;
				msTargetFocus = asFocusNextFrame;
			}
			msSelectedOptionsButton = OptionMenu_UpdateFocusCustom(avMenuItems, avMenuItems[mlCurrentItemId], msSelectedOptionsButton);
		}
	}
	
	//------------------------------------------------------- 
	
	float mfTransitionAlpha = 1;
	
	int GuiHandleTransition(eMainMenuGroup aTarget = eMainMenuGroup_Main, const tString &in asNextFrame="")
	{
		int lState;
		
		float fFadeMul = (mbMainMenuActive) ? 1 : 2;
		
		if (ImGui_TimerExists("TransitionIn"))
		{
			if (mfTransitionAlpha < 1)
			{
				lState = 1;
				mfTransitionAlpha += gfTransisionFadeSpeed * fFadeMul * cEngine_GetFrameTime();
			}
			else
			{
				mfTransitionAlpha = 1;
				ImGui_StopTimer("TransitionIn");
			}
		}
		else if (ImGui_TimerExists("TransitionOut"))
		{
			if (mfTransitionAlpha > 0)
			{
				if (mfTransitionAlpha == 1) 
				{
					if (Sound_GuiIsPlaying("special_fx/frontend/frontend_menu_change")) Sound_StopGui("special_fx/frontend/frontend_menu_change",0);
					Sound_PlayGui("special_fx/frontend/frontend_menu_change", 1.0f, eSoundEntryType_Gui);
				}
				
				lState = -1;
				mfTransitionAlpha -= gfTransisionFadeSpeed * fFadeMul *  cEngine_GetFrameTime();
			}
			else
			{
				ImGui_StopTimer("TransitionOut");
				
				cLux_AddDebugMessage("GOING TO: "+aTarget);
				mCurrentGroup = aTarget;
				msFocusNextFrame = asNextFrame;
				cLux_AddDebugMessage("NEXT FRAME: "+msFocusNextFrame);
				if (ImGui_TimerExists("TransitionIn") == false)
					ImGui_AddTimer("TransitionIn",10);
			}
		}
		else 
			lState = 0;
		
		return lState;
	}
	
	//------------------------------------------------------- 
	
	void GuiOptions()
	{
		GuiPauseDarkOverlay();
		
		array<tString> vMenuItemsPC = {"Options_Game", "Options_Controls", "Options_Display", "Options_Graphics", "Options_Audio", "Options_Accessibility"};
		array<tString> vMenuItemsPS4 = {"Options_Game", "Options_Controls", "Options_Audio", "Options_Accessibility"};
		array<tString> vMenuItems = (Platform_IsConsole()) ? vMenuItemsPS4 : vMenuItemsPC;
		
		cVector2f vBgSize = (Platform_IsConsole()) ? kOptionsBgSizePS4 : kOptionsBgSize;
		
		//////////
		// Add gamma if not on main menu
		if(mbMainMenuActive == false)
			vMenuItems.insertAt(vMenuItems.size(), "Options_Gamma");

		//////////////
		// Add debug options
		if(cLux_DebugModeOn()) 
			vMenuItems.insertAt(vMenuItems.size(), "DebugOptions");

		if (cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false)
			vMenuItems.push_back("Back");

		cVector2f vRightAnchor = cVector2f(kOptionsBgPos.x + vBgSize.x, 0);
		cVector3f vInfoBoxPos = OptionMenu_GetTopLeftOffset(cVector2f(kOptionsBgPos.x+vBgSize.x-60,0),0);
		
		DoBackground(vRightAnchor.x + 100);
		
		////////////////
		// Title
		OptionMenu_SectionTitle("Options", kOptionsBgPos + cVector2f(40,-40), 1.f, mfTransitionAlpha);
		
		/////////////////////////
		// Handles dynamic scrolling
		mlCurrentItemId = mlFirstItemId;
		OptionMenu_SetOutOfLimit(vMenuItems.length());

		/////////////////
		// Game
		{
			DoOptionsItem(vMenuItems, vMenuItems[mlCurrentItemId-mlFirstItemId], eMainMenuGroup_Options_Game, msSelectedGameplayButton, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			mlCurrentItemId++;
		}
		
		/////////////////
		// Input
		{
			DoOptionsItem(vMenuItems, vMenuItems[mlCurrentItemId-mlFirstItemId], eMainMenuGroup_Options_Controls, msSelectedInputMouseButton, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			mlCurrentItemId++;
		}
		
		/////////////////
		// Display
		if(Platform_IsConsole() == false)
		{
			DoOptionsItem(vMenuItems, vMenuItems[mlCurrentItemId-mlFirstItemId], eMainMenuGroup_Options_Display, msSelectedDisplayButton, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			mlCurrentItemId++;
		}
		
		/////////////////
		// Graphics
		if(Platform_IsConsole() == false)
		{
			DoOptionsItem(vMenuItems, vMenuItems[mlCurrentItemId-mlFirstItemId], eMainMenuGroup_Options_Graphics, msSelectedGraphicsButton, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			mlCurrentItemId++;
		}

		/////////////////
		// Audio
		{
			DoOptionsItem(vMenuItems, vMenuItems[mlCurrentItemId-mlFirstItemId], eMainMenuGroup_Options_Audio, msSelectedAudioButton, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			mlCurrentItemId++;
		}
		
		/////////////////
		// Accessibility
		mbAccessibilityOptionsBackToNewGame = false;
		{
			DoOptionsItem(vMenuItems, vMenuItems[mlCurrentItemId-mlFirstItemId], eMainMenuGroup_Options_Accessibility, msSelectedAccessibilityButton, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			mlCurrentItemId++;
		}
		
		///////////////
		// GAMMA (PS4)
		if(mbMainMenuActive == false)
		{
			DoOptionsItem(vMenuItems, vMenuItems[mlCurrentItemId-mlFirstItemId], eMainMenuGroup_Options_Display_Gamma, msSelectedVideoGammaButton, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			mlCurrentItemId++;
		}

		/////////////////
		// Debug
		if (cLux_DebugModeOn())
		{
			DoOptionsItem(vMenuItems, vMenuItems[mlCurrentItemId-mlFirstItemId], eMainMenuGroup_Options_Debug, msSelectedDebugButton, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			mlCurrentItemId++;
		}
		if (cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false)
			mlCurrentItemId++;
		
		/////////////////
		// BACK BTN
		{
			bool bButton = MainMenu_DoBackButton(msSelectedOptionsButton, mfTransitionAlpha);
			bool bGamepadBack = ImGui_ActionTriggered(eImGuiAction_Cancel, true);
			
			if(bButton || bGamepadBack)
			{
				mlScrollMargin = 2;
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				mlLastInFocusRel = 0;
				mbScrolled = false;
				mbScrollDown = false;
				mbScrollUp = false;
				
				if (ImGui_TimerExists("TransitionOut") == false)
					ImGui_AddTimer("TransitionOut", 10);
				
				mTargetGroup = eMainMenuGroup_Main;
				msTargetFocus = mbMainMenuActive ? msSelectedMainMenuButton : msSelectedPauseMenuButton;
				
				//////////////////////////////
				// Reset menu pos if using the gui btn
				if(bGamepadBack == false)
				{
					OptionMenu_ShowGamepadButtons(true);
					return;
				}
			}
			
			if(mlCurrentItemId >= vMenuItems.size())
				mlCurrentItemId = vMenuItems.size() - 1;

			tString sID = cLux_GetInputHandler().GetGamepadWasLastDeviceUsed() ? vMenuItems[mlCurrentItemId] : "Back";
			msSelectedOptionsButton = OptionMenu_UpdateFocus(sID, msSelectedOptionsButton);
		}
		
		GuiHandleTransition(mTargetGroup, msTargetFocus);
		
		//////////////////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
	}

	//-------------------------------------------------------
	
	void GuiLoadGame()
	{
		GuiPauseDarkOverlay();
		
		ImGui_SetTransCategory("Menu");
		
		array<tString> vMenuItems;
		
		////////////////////
		// No save slots selected. Add save slot buttons in the list to navigate to. 
		if (mlSelectedLoadSlot==-1)
		{
			for(int i=0; i < mvSaveSlots.size(); ++i)
			{
				cSaveSlot@ pSaveSlot = mvSaveSlots[i];
				if (pSaveSlot is null) continue;
				if (pSaveSlot.mvSlotSaveFiles.size()==0) continue;
				
				vMenuItems.push_back("SaveSlotLabel" + cString_ToString(pSaveSlot.mlId, 0));
			}
		}
		
		////////////////////////////////////
		// A save slot is selected. Add save files btns in the list to navigate to.
		else
		{
			cSaveSlot@ pSaveSlot = mvSaveSlots[mlSelectedLoadSlot];
			if (pSaveSlot !is null && pSaveSlot.mvSlotSaveFiles.size()>0)
			{
				for(int i = 0; i < pSaveSlot.mvSlotSaveFiles.size(); ++i)
				{
					cSaveFile@ pSaveFile = pSaveSlot.mvSlotSaveFiles[i];
					if (pSaveFile is null) continue;
					
					tString sSaveGameButtonName = "SaveGame_"+ i;
					vMenuItems.push_back(sSaveGameButtonName);
				}
			}
		}
		
		if (cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false && mlSelectedLoadSlot==-1)
			vMenuItems.push_back("Back");
			
		cVector2f vSize = kSaveSlotSelectionBgSize + cVector2f(gfOptionsMenu_ExtraWidth, 0);
		cVector2f vRightAnchor = cVector2f(kSaveSlotSelectionPos.x + vSize.x, 0);
		DoBackground(vRightAnchor.x + 200);
		
		////////////////
		// Page Title
		OptionMenu_SectionTitle("LoadGame", kOptionsBgPos + cVector2f(40,-120), 1.f, mfTransitionAlpha);
		mlCurrentItemId = 0;
		
		for (int i=0; i<vMenuItems.length(); i++)
		{
			OptionMenu_UpdateButtonWidth(vMenuItems[i]);
		}
		
		OptionMenu_AlignExtraButtonWidth();
		OptionMenu_UpdateToggleExtraWidth();
		
		///////////////////////
		// Draw Save Files
		if (mlSelectedLoadSlot >-1 )
		{
			cSaveSlot@ pSaveSlot = mvSaveSlots[mlSelectedLoadSlot];
			
			if (pSaveSlot !is null && pSaveSlot.mvSlotSaveFiles.size()>0)
			{
				int lSaveFilesCount = pSaveSlot.mvSlotSaveFiles.size();
				for(int i = 0; i < lSaveFilesCount; ++i)
				{
					// early out if too may saves
					if(i >= 3) continue;

					cSaveFile@ pSaveFile = pSaveSlot.mvSlotSaveFiles[i];
					if (pSaveFile is null) continue;
					
					tString sSaveGameButtonName = "SaveGame_"+ i;
					vMenuItems.push_back(sSaveGameButtonName);
					
					/////////////////////////////
					// Get the save file creation date
					tString sDate = "MM/DD/YYYY";
					for(uint j = 0; j<mvSaveFiles.size(); ++j)
					{
						if(mvSaveFiles[j] == pSaveFile.msSaveFile)
						{
							int lSep = cString_GetFirstCharPos(mvSaveDates[j],'-');
							sDate = cString_Sub(mvSaveDates[j],0,lSep) + "/" + cString_Sub(mvSaveDates[j],lSep+3);
							break;
						}
					}
					
					////////////////
					// Draw load btn
					if (OptionMenu_ButtonSaveFile(sSaveGameButtonName, sDate, kSaveSlotSelectionPos + cVector2f(25, 26) + (kSaveSlotSelectionSpacing * mlSelectedLoadSlot) + (kSaveGameEntrySpacing * i), sSaveGameButtonName==msSelectedLoadGameButton, mfTransitionAlpha))
					{
						cLux_AddDebugMessage("Load Game Test" + sSaveGameButtonName);
						msSaveFileToLoad = pSaveFile.msSaveFile;
						mlSelectedSaveSlot = pSaveSlot.mlId;
						mlSelectedLoadButton = i;
						mlSelectedGameMode = pSaveSlot.mvSlotSaveFiles[i].mlGameMode;

						cLux_AddDebugMessage("[MenuHandler] [GuiLoadGame] SaveFile: " + cString_To8Char(msSaveFileToLoad) + " SaveSlot: " + mlSelectedSaveSlot);
						mbShowLoadGame = true;
						msMessageBoxFocus = "No";
						msFocusNextFrame="No";
						cLux_AddDebugMessage("mlCurrentItemId " + mlCurrentItemId);
					}
					
					/////////////////
					// Handle btn selection
					msSelectedLoadGameButton = OptionMenu_UpdateFocusCustom(vMenuItems, vMenuItems[mlCurrentItemId], msSelectedLoadGameButton);
					mlCurrentItemId++;
					
					//////////////////////////
					// Draw highlighted save file info
					if (ImGui_PrevInFocus())
					{
						tWString sSaveFileMapName = pSaveFile.msSaveName;
						int lSubPos = cString_GetFirstStringPosW(sSaveFileMapName, tWString("AutoSave"));
						if(lSubPos >= 0)
							sSaveFileMapName = cString_SubW(sSaveFileMapName, lSubPos+8, -1);
						
						cImGuiGfx gfxSeparatorLine;
						gfxSeparatorLine.mColor = cColor(1,0.5) * gOptionMenu_ModColor;
						ImGui_DoImage(gfxSeparatorLine, OptionMenu_GetTopLeftOffset(kSaveSlotSelectionPos + cVector2f(0, 210)), OptionMenu_GetScaledSize(cVector2f(vRightAnchor.x * 0.5, 1)));
					
						cImGuiLabelData labelData;
						labelData.mFont.SetFile(FontHandler_GetFont(eFontType_MainMenu_InfoBox, 56));
						labelData.mFont.mvSize = gfFontSize_InfoBox;
						labelData.mFontAlign = eFontAlign_Left;
						labelData.mFont.mColor = cColor(1,1) * gOptionMenu_ModColor;
						
						ImGui_SetTransCategory("LoadGame");
						tWString sLocation = ImGui_Translate("Location");
						ImGui_SetTransCategory("Levels");
						tWString sMap = ImGui_Translate(cString_To8Char(sSaveFileMapName));
						tWString sSaveLocation = sLocation + " " + sMap;
						cLux_GetCurrentImGui().DoLabel(sSaveLocation, labelData, OptionMenu_GetTopLeftOffset(kSaveSlotSelectionPos + cVector2f(0, 220)), 0);
						
						//TODO: Get the difficulty mode from suffix when done in the source.
						ImGui_SetTransCategory("LoadGame");
						tWString sMode = ImGui_Translate("Mode");
						tWString sDifficultyMode = sMode + " " + ImGui_Translate(GetGameModeNameByID(pSaveFile.mlGameMode) + "Mode");
						cLux_GetCurrentImGui().DoLabel(sDifficultyMode, labelData, OptionMenu_GetTopLeftOffset(kSaveSlotSelectionPos + cVector2f(0, 240)), 0);
						
						ImGui_SetTransCategory("LoadGame");
						tWString sCreated = ImGui_Translate("Created");
						ImGui_SetTransCategory("");
						tWString sDateCreated = sCreated + " " + sDate;
						cLux_GetCurrentImGui().DoLabel(sDateCreated, labelData, OptionMenu_GetTopLeftOffset(kSaveSlotSelectionPos + cVector2f(0, 260)), 0);
						//ImGui_DoLabelExt(sDate, labelData, OptionMenu_GetTopLeftOffset(kSaveSlotSelectionPos + cVector2f(0, 260)), 0);
					}
				}
			}
		}
		
		
		
		///////////////////////////////////////////////
		// Dummy button to exit the save files focus mode
		if (cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false)
		{
			if (mlSelectedLoadSlot != -1)
			{
				cImGuiButtonData dummyBtn;
				dummyBtn.mbUseBackgroundGfx = false;
				ImGui_SetModUseUIPos(false);
				if (ImGui_DoButtonExt("DummyButton", "", dummyBtn, ImGui_NrmPos(0,0,0), ImGui_NrmSize(1)))
				{
					msSelectedLoadGameButton = "SaveSlotLabel"+(mlSelectedLoadSlot+1);
					//ImGui_SetFocus(msSelectedLoadGameButton);
					msFocusNextFrame = msSelectedLoadGameButton;
					msSelectedLoadGameButton = OptionMenu_UpdateFocus(vMenuItems[mlCurrentItemId], msSelectedLoadGameButton);
					
					mlSelectedLoadSlot = -1;
					Sound_PlayGui("special_fx/frontend/frontend_menu_slider", 1.0f, eSoundEntryType_Gui);
					mlCurrentItemId = 0;
					
					///////////////
					// Show gamepad btns before return;
					OptionMenu_ShowGamepadButtons(true);
					
					if (vMenuItems.size()>0 || cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false)
						DoCustomScrollInput(vMenuItems, true);
						
					return;
				}
				ImGui_SetModUseUIPos(true);
			}
		}
		
		////////////////
		// Draw the save slots
		for(int i = 0; i < mvSaveSlots.size(); ++i)
		{
			cSaveSlot@ pSaveSlot = mvSaveSlots[i];
			if (pSaveSlot is null) continue;
			
			tWString sSuffixName = cString_To16Char("slot" + cString_ToString(pSaveSlot.mlId, 0));
			int lGameMode = -1;
			tString sDate = "MM/DD/YYYY";
			tWString sMapName = "";
			
			////////////////////////
			// Check if the slot is used and draw some info about it.
			for(uint j = 0; j<mvSaveFiles.size(); ++j)
			{
				if(mvSaveSuffix[j] == sSuffixName)
				{
					lGameMode = mvSaveModeSuffix[j].length() > 0 ? cString_GetNumericSuffixIntW(mvSaveModeSuffix[j]) : 1;
					int lSep = cString_GetFirstCharPos(mvSaveDates[j],'-');
					sDate = cString_Sub(mvSaveDates[j],0,lSep) + "/" + cString_Sub(mvSaveDates[j],lSep+3);
					
					sMapName = mvSaveNames[j];
					int lSubPos = cString_GetFirstStringPosW(sMapName, tWString("AutoSave"));
					if(lSubPos>=0)
						sMapName = cString_SubW(sMapName, lSubPos+8, -1);
					
					break;
				}
			}
			
			/////////////////////////
			// Draw save-slot buttons
			bool bDisabledBtn = mlSelectedLoadSlot != -1;
			tString sSlotBtnName = "SaveSlotLabel"+ cString_ToString(pSaveSlot.mlId, 0);
			bool bUsed = lGameMode != -1;
			
			if (OptionMenu_LoadSlot(bDisabledBtn, lGameMode, mlSelectedLoadSlot == i, sSlotBtnName, sMapName, sDate, kSaveSlotSelectionPos + kSaveSlotSelectionSpacing * i, "", sSlotBtnName == msSelectedLoadGameButton, mfTransitionAlpha))
			{
				mlSelectedLoadSlot = bUsed ? i : -1;
				msSelectedLoadGameButton = "SaveGame_0";
				//ImGui_SetFocus(msSelectedLoadGameButton);
				msFocusNextFrame = msSelectedLoadGameButton;
				
				//cLux_AddDebugMessage("[MainMenu] [LoadMenu] Selected Load Slot: " + mlSelectedLoadSlot);
				//cLux_AddDebugMessage("[MainMenu] [LoadMenu] Selected Load Game Button: " + msSelectedLoadGameButton);
				//msSelectedLoadGameButton = OptionMenu_UpdateFocus("SaveGame_0", msSelectedLoadGameButton);
				
				msSelectedLoadGameButton = OptionMenu_UpdateFocusCustom(vMenuItems, vMenuItems[mlCurrentItemId], msSelectedLoadGameButton);
				
				///////////////
				// Show gamepad btns before return;
				OptionMenu_ShowGamepadButtons(true);
					
				if (vMenuItems.size()>0 || cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false)
					DoCustomScrollInput(vMenuItems, true);
				
				return; // refresh btns list
			}
			
			/////////////////
			// Handle btn selection
			if (mlSelectedLoadSlot==-1 && bUsed && mlCurrentItemId <= vMenuItems.size())
			{
				msSelectedLoadGameButton = OptionMenu_UpdateFocusCustom(vMenuItems, vMenuItems[mlCurrentItemId], msSelectedLoadGameButton);
				mlCurrentItemId++;
			}
		}
		
		/////////////////
		// Back
		bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);
		{
			bool bButton = MainMenu_DoBackButton(msSelectedLoadGameButton, mfTransitionAlpha);
			
			if(bButton || bGamepad)
			{
				if (bGamepad)
					Sound_PlayGui("special_fx/frontend/frontend_menu_select", 1.0f, eSoundEntryType_Gui);
				
				if (mlSelectedLoadSlot != -1)
				{
					tString sSlotBtnName = "SaveSlotLabel"+(mlSelectedLoadSlot+1);
					msSelectedLoadGameButton = sSlotBtnName;
					//ImGui_SetFocus(sSlotBtnName);
					msFocusNextFrame = msSelectedLoadGameButton;
					mlSelectedLoadSlot = -1; //no selection
					cLux_AddDebugMessage("[MainMenu] mlSelectedLoadSlot: " + mlSelectedLoadSlot);
				}
				else
				{
					if (ImGui_TimerExists("TransitionOut") == false)
						ImGui_AddTimer("TransitionOut", 10);
					
					mlFirstItemId = 0;
					mlLastInFocus = 0;
					mTargetGroup = eMainMenuGroup_Main;
					msTargetFocus = msSelectedMainMenuButton;
				}
			}
			
			/////////////////
			// Handle btn selection
			if (cLux_GetInputHandler().GetGamepadWasLastDeviceUsed() == false)
				msSelectedLoadGameButton = OptionMenu_UpdateFocusCustom(vMenuItems, "Back", msSelectedLoadGameButton);
		}
		
		if (mbShowOverwriteSaveSlot==false)
			GuiHandleTransition(mTargetGroup, msTargetFocus);

		//////////////////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
		
		if (vMenuItems.size()>0 || cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false)
			DoCustomScrollInput(vMenuItems, true);
		
		//cLux_AddDebugMessage("msSelectedLoadGameButton " + msSelectedLoadGameButton);
	}
	
	//-------------------------------------------------------
	
	/*void GuiLoadGame()
	{
		array<tString> vMenuItems;
		
		cVector2f vRightAnchor = cVector2f(kLoadBgPos.x + kLoadBgSize.x, 0);
		DoBackground(vRightAnchor.x + 100);
		
		mlCurrentItemId = mlFirstItemId;
		float fPadding = mbScrollingSaveList ? 10000 : 5;
		
		////////////////
		// Title
		OptionMenu_SectionTitle("LoadGame", kLoadBgPos + cVector2f(40,-40), 1.f);
		
		/////////////////////////////////
		// Draw Save slots
		for (int i=0; i<mvSaveSlots.size(); i++)
		{
			cSaveSlot@ pSaveSlot = mvSaveSlots[i];
			if (pSaveSlot is null) continue;
			if (pSaveSlot.mvSlotSaveFiles.size()==0) continue;
			
			tWString sSaveSlotLabel = "Save Slot "+(pSaveSlot.mlId);
			tString sDate = pSaveSlot.mvSlotSaveFiles[0].msSaveDate;
			
			tString sSaveSlotButtonName = "SaveSlot_" + mlCurrentItemId;
			vMenuItems.push_back(sSaveSlotButtonName);
			
			cVector2f vPos = kLoadButtonPos + cVector2f(-10, mlCurrentItemId * kLoadSlotsSpacing);
			if (OptionMenu_ButtonSaveSlot(sSaveSlotButtonName, sSaveSlotLabel, sDate, vPos, msSelectedLoadGameButton == sSaveSlotButtonName, pSaveSlot.mbExpanded, mfTransitionAlpha))
			{
				pSaveSlot.mbExpanded = !pSaveSlot.mbExpanded;
			}
			
			msSelectedLoadGameButton = OptionMenu_UpdateFocus(vMenuItems[mlCurrentItemId], msSelectedLoadGameButton);
			mlCurrentItemId++;
			
			/////////////////////////////////
			// Draw Save Games
			if (pSaveSlot.mbExpanded)
			{
				for (int j=0; j<pSaveSlot.mvSlotSaveFiles.size(); j++)
				{
					cSaveFile@ pSaveFile = pSaveSlot.mvSlotSaveFiles[j];
					if (pSaveFile is null) continue;
					
					tWString sSaveGameLabel = pSaveFile.msSaveName;
					int lSubPos = cString_GetFirstStringPosW(sSaveGameLabel, tWString("AutoSave"));
					if(lSubPos >= 0)
						sSaveGameLabel = cString_SubW(sSaveGameLabel, lSubPos+8, -1);
					
					tString sSaveGameButtonName = "SaveGame_"+ mlCurrentItemId;
					vMenuItems.push_back(sSaveGameButtonName);
					
					cVector2f vPos = kLoadButtonPos + cVector2f(0, mlCurrentItemId * kLoadSlotsSpacing);
					if (OptionMenu_ButtonSaveFile(sSaveGameButtonName, sSaveGameLabel, pSaveFile.msSaveDate, vPos, msSelectedLoadGameButton == sSaveGameButtonName, mfTransitionAlpha))
					{
						msSaveFileToLoad = pSaveFile.msSaveFile;
						mlSelectedSaveSlot = pSaveSlot.mlId;
						cLux_AddDebugMessage("[MenuHandler] [GuiLoadGame] SaveFile: " + cString_To8Char(msSaveFileToLoad) + " SaveSlot: " + mlSelectedSaveSlot);
						mbShowLoadGame = true;
						msMessageBoxFocus = "No";
						msFocusNextFrame="No";
						cLux_AddDebugMessage("mlCurrentItemId " + mlCurrentItemId);
					}
					
					msSelectedLoadGameButton = OptionMenu_UpdateFocus(vMenuItems[mlCurrentItemId], msSelectedLoadGameButton);
					mlCurrentItemId++;
					
				}
			}
		}
		
		if (cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false)
			vMenuItems.push_back("Back");
		
		ImGui_DrawGfx(cImGuiGfx(), OptionMenu_GetTopLeftOffset(kLoadFramePos + cVector2f(375,0), 0.01), OptionMenu_GetScaledSize(cVector2f(1,kLoadFrameSize.y)), cColor(1, mfTransitionAlpha) * gOptionMenu_ModColor * 0.5);
		
		/////////////////
		// Back
		{
			bool bButton = MainMenu_DoBackButton(msSelectedLoadGameButton, mfTransitionAlpha);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				
				mTargetGroup = eMainMenuGroup_Main;
				msTargetFocus = msSelectedMainMenuButton;
				
				if (ImGui_TimerExists("TransitionOut") == false)
					ImGui_AddTimer("TransitionOut", 10);
			}
			
			tString sBtnID = cLux_GetInputHandler().GetGamepadWasLastDeviceUsed() ? vMenuItems[vMenuItems.size()-1] : "Back";
			msSelectedLoadGameButton = OptionMenu_UpdateFocus(sBtnID, msSelectedLoadGameButton);
		}
		
		//cLux_AddDebugMessage("msSelectedLoadGameButton " + msSelectedLoadGameButton);
		
		GuiHandleTransition(mTargetGroup, msTargetFocus);

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true, true);
	}*/

	//-------------------------------------------------------

	void GuiOptionsGameplay()
	{
		GuiPauseDarkOverlay();
		
		bool bStartingNewGame = mCurrentGroup == eMainMenuGroup_Options_NewGame_Gameplay;
		
		array<tString> vMenuItems = {"Language", "ShowHints", "GamePausingHints"};
		
		if (bStartingNewGame)
		{
			vMenuItems.pop_front();
			vMenuItems.push_back("Subtitles");
			vMenuItems.push_back("PadVibration");
		}
		else
		{
			vMenuItems.push_back("CrosshairSimple");
			vMenuItems.push_back("HideCrosshair");
			vMenuItems.push_back("LockCodeQuickAccess");
		}
		
		vMenuItems.push_back("Options_AccessibilityOptions");
		
		//////////////////////////
		// Keep these always last
		if (bStartingNewGame)
			vMenuItems.push_back("Start");
		if (cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false)
			vMenuItems.push_back("Back");

		for (int i=0; i<vMenuItems.length(); i++)
		{
			OptionMenu_UpdateButtonWidth(vMenuItems[i]);
		}
		
		tString sLanguage = cLux_GetCurrentLanguage();
		sLanguage = cString_Sub(sLanguage, 0, sLanguage.length() - 5);
		
		OptionMenu_UpdateToggleExtraWidth();
		OptionMenu_UpdateMultiSelectionExtraWidth(array<tString> = {sLanguage }, "Languages");
		OptionMenu_AlignExtraButtonWidth();		
		
		cVector2f vGameplayMenuSize = Platform_IsConsole() ? kOptionsGameplayPS4BgSize : kOptionsGameplayBgSize;
		vGameplayMenuSize += cVector2f(gfOptionsMenu_ExtraWidth+gfOptionsMenu_ExtraWidth_MultiSelect,0);
		
		cVector2f vOptionsMenuSize = kOptionsBgSize + cVector2f(gfOptionsMenu_ExtraWidth,0);
		
		cVector3f vInfoBoxPos = OptionMenu_GetTopLeftOffset(cVector2f(kOptionsGameplayBgPos.x + vGameplayMenuSize.x-40,0),0);
		cVector2f vRightAnchor = cVector2f(kOptionsGameplayBgPos.x + vGameplayMenuSize.x - 40,0);
		
		DoBackground(vRightAnchor.x + 100);
		
		////////////////
		// Title
		cVector2f vTitlePos = bStartingNewGame ? kOptionsBgPos + cVector2f(40,-40) : kOptionsBgPos + cVector2f(40,-40);
		tString sTitle = bStartingNewGame ? "NewGame" : "Gameplay";
		OptionMenu_SectionTitle(sTitle, vTitlePos, 1.f, mfTransitionAlpha);
		
		mlCurrentItemId = mlFirstItemId;
		
		cVector2f vWidgetPos = bStartingNewGame ? kOptionsGameplayButtonPos : kOptionsGameplayButtonPos;
		
		/////////////////////////
		// Handles dynamic scrolling
		OptionMenu_SetOutOfLimit(vMenuItems.length());

		/////////////////
		// LANGUAGE
		if (bStartingNewGame==false)
		{
			if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
			{
				//////////////
				// Draw button and update config
				tString sLang = cString_SetFileExt(mpConfig.GetString("Main", "StartLanguage", cLux_GetDefaultGameLanguage()), "");
				int lValue = 0;

				for(int i = 0; i < mvLangFiles.size(); ++i)
				{
					if(sLang == mvLangFiles[i])
					{
						lValue = i;
						break;
					}
				}
				int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], vWidgetPos, mlCurrentItemId, msSelectedGameplayButton, mvLangFiles, lValue, false, mlActionHorizontal, "Languages", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha, false, false, true, "", cString_To16Char(""), true, false);
				if(lValue != lNewValue)
				{
					mpConfig.SetString("Main", "StartLanguage", cString_SetFileExt(mvLangFiles[lNewValue], "lang"));
					FontHandler_SetLanguage(mvLangFiles[lNewValue]);
					ApplySettings();
				}

				msSelectedGameplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGameplayButton);
			}
			mlCurrentItemId++;
		}
		
		/////////////////
		// Hints
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Gameplay", "ShowHints", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], vWidgetPos, mlCurrentItemId, msSelectedGameplayButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Gameplay", "ShowHints", bNewValue);
				ApplySettings();
			}
			
			msSelectedGameplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGameplayButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Game Pausing Hints
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Gameplay", "GamePausingHints", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], vWidgetPos, mlCurrentItemId, msSelectedGameplayButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Gameplay", "GamePausingHints", bNewValue);
				ApplySettings();
			}

			msSelectedGameplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGameplayButton);
		}
		mlCurrentItemId++;
		
		if (bStartingNewGame == false)
		{
			/////////////////
			// Simple Interaction Icons
			if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
			{
				//////////////
				// Draw button and update config
				bool bValue = mpConfig.GetBool("Gameplay", "CrosshairSimple", false);
				bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], vWidgetPos, mlCurrentItemId, msSelectedGameplayButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
				
				if(bValue != bNewValue)
				{
					mpConfig.SetBool("Gameplay", "CrosshairSimple", bNewValue);
					ApplySettings();
				}
				msSelectedGameplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGameplayButton);
			}
			mlCurrentItemId++;	
				
			/////////////////
			// Hide Crosshair
			if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
			{
				//////////////
				// Draw button and update config
				bool bValue = mpConfig.GetBool("Gameplay", "HideCrosshair", false);
				bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], vWidgetPos, mlCurrentItemId, msSelectedGameplayButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
				
				if(bValue != bNewValue)
				{
					mpConfig.SetBool("Gameplay", "HideCrosshair", bNewValue);
					ApplySettings();
				}
					msSelectedGameplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGameplayButton);
			}
			mlCurrentItemId++;
			
			/////////////////
			// Lock Code Quick Access
			if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
			{
				bool bValue = mpConfig.GetBool("Gameplay", "LockCodeQuickAccess", false);
				bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], vWidgetPos, mlCurrentItemId, msSelectedGameplayButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
				if (bNewValue != bValue)
				{
					mpConfig.SetBool("Gameplay", "LockCodeQuickAccess", bNewValue);
				}
				msSelectedGameplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGameplayButton);
			}
			mlCurrentItemId++;
		}
		
		if (bStartingNewGame)
		{
			/////////////////////
			// Subtitles
			if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
			{
				//////////////
				// Draw button and update config
				bool bValue = mpConfig.GetBool("Sound", "ShowSubtitles", true);
				bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], vWidgetPos, mlCurrentItemId, msSelectedGameplayButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
				
				if(bValue != bNewValue)
				{
					mpConfig.SetBool("Sound", "ShowSubtitles", bNewValue);
					ApplySettings();
				}

				msSelectedGameplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGameplayButton);
			}
			mlCurrentItemId++;
			
			/////////////////////
			// Vibration
			if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
			{
				//////////////
				// Draw button and update config
				bool bValue = mpConfig.GetBool("Input", "Rumble", true);
				bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], vWidgetPos, mlCurrentItemId, msSelectedGameplayButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
				
				if(bValue != bNewValue)
				{
					mpConfig.SetBool("Input", "Rumble", bNewValue);
					ApplySettings();
				}

				msSelectedGameplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGameplayButton);
			}
			
			mlCurrentItemId++;
			
			/////////////////
			// Accessibility
			if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
			{
				if(OptionMenu_ButtonOptions(vMenuItems[mlCurrentItemId-mlFirstItemId], vWidgetPos, mlCurrentItemId, msSelectedGameplayButton, true, vRightAnchor, vInfoBoxPos, mfTransitionAlpha))
				{
					mbAccessibilityOptionsBackToNewGame = true;
					mlFirstItemId = 0;
					mlLastInFocus = 0;
					mPrevGroup = eMainMenuGroup_Options_NewGame_Gameplay;
					mTargetGroup = eMainMenuGroup_Options_Accessibility;
					msTargetFocus = msSelectedAccessibilityButton;
				}
				msSelectedGameplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGameplayButton);
			}
			
			mlCurrentItemId++;
		}
		
		/////////////////////
		// Start Game
		if (bStartingNewGame)
		{
			if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
			{
				if (MainMenu_DoStartButton(msSelectedGameplayButton, mfTransitionAlpha))
				{
					///////////////////////////////
					// Show message box to confirm
					if(mbCanContinue)
					{
						///////////////////
						// Skip intro? 
						if (mbGameCompletedOnce)
							mbShowSkipIntro = true;
						/////////
						// New game?
						else
							mbShowNewGame = true;
						
						msFocusNextFrame = "No";
						msMessageBoxFocus = "No";
					}
					else
					{
						///////////////////
						// Skip intro? 
						if (mbGameCompletedOnce)
						{
							mbShowSkipIntro = true;
						}
						///////////////
						// Start new game directly
						else
						{
							//StartNewGame();
							ImGui_AddTimer("NewGameTimer", mfNewGameFadeLength);
							Sound_PlayGui("special_fx/frontend/new_game_sting", 1.0f, eSoundEntryType_Gui);
							Effect_Rumble_Start(0.5, 0.5, 1.f, 1.f);
							Music_StopAll(2.0f);
						}
					}
				}
				
				msSelectedGameplayButton = OptionMenu_UpdateFocusCustom(vMenuItems, vMenuItems[mlCurrentItemId], msSelectedGameplayButton);
			}
			mlCurrentItemId++;
		}
		
		/////////////////
		// Back
		{
			bool bButton = MainMenu_DoBackButton(msSelectedGameplayButton, mfTransitionAlpha);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				/////////////////////////////////////////////////
				// Enable subtitles if other than english is selected
				tString sLang = mpConfig.GetString("Main", "StartLanguage", cLux_GetDefaultGameLanguage());
				if((sLang == "english" || sLang == "english.lang") == false)
				{
					mpConfig.SetBool("Sound", "ShowSubtitles", true);
				}

				ApplySettings();
				
				if (ImGui_TimerExists("TransitionOut") == false)
					ImGui_AddTimer("TransitionOut", 10);
				
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				
				mTargetGroup = bStartingNewGame ? eMainMenuGroup_GameModes : eMainMenuGroup_Options;
				msTargetFocus = bStartingNewGame ? msSelectedGameModesBtn : msSelectedOptionsButton;
			}
			
			tString sNewgameBtnID = bStartingNewGame ? "Start" : "LockCodeQuickAccess";
			tString sBtnID = cLux_GetInputHandler().GetGamepadWasLastDeviceUsed() ? sNewgameBtnID : "Back";
			msSelectedGameplayButton = OptionMenu_UpdateFocus(sBtnID, msSelectedGameplayButton);
		}
		
		if (mbShowNewGame==false && mbShowSkipIntro==false)
			GuiHandleTransition(mTargetGroup, msTargetFocus);

		//////////////////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
	}
	
	//------------------------------------------------------- 
	
	void GuiOptionsControls()
	{
		GuiPauseDarkOverlay();
		
		array<tString> vMenuItemsPC = {"MouseSens", "InvertMouseY", "SmoothMouse", "Keybind", "GamepadSens", "InvertGamepadY", "PadVibration", "GamepadMapping"};
		array<tString> vMenuItemsPS4 = {"GamepadSens", "InvertGamepadY", "PadVibration", "GamepadMapping"};
		array<tString> vMenuItems = (Platform_IsConsole() && Platform_IsStreaming() == false) ? vMenuItemsPS4 : vMenuItemsPC;
		
		if (cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false)
			vMenuItems.push_back("Back");
		
		for (int i=0; i<vMenuItems.length(); i++)
		{
			if(vMenuItems[i] == "GamepadMapping" || 
				vMenuItems[i] == "Keybind")
				continue;
			OptionMenu_UpdateButtonWidth(vMenuItems[i]);
		}
		
		OptionMenu_UpdateToggleExtraWidth();
		OptionMenu_AlignExtraButtonWidth();

		////////////////////////////////////
		// Options background
		cVector2f vControlsMenuPos = kOptionsControlsBgPos;
		cVector2f vControlsMenuSize = (Platform_IsConsole() && Platform_IsStreaming() == false) ? kOptionsControlsPS4BgSize : kOptionsControlsBgSize;
		vControlsMenuSize += cVector2f(cMath_Min(gfOptionsMenu_ExtraWidth+gfOptionsMenu_ExtraWidth_MultiSelect,620.f),0);
		
		cVector3f vInfoBoxPos = OptionMenu_GetTopLeftOffset(cVector2f(vControlsMenuPos.x+vControlsMenuSize.x-40,0),0);
		cVector2f vRightAnchor = cVector2f(vControlsMenuPos.x+vControlsMenuSize.x-40,0);
		
		DoBackground(vRightAnchor.x + 100);
		
		////////////////
		// Title
		OptionMenu_SectionTitle("Controls", vControlsMenuPos + cVector2f(40,-40), 1.f, mfTransitionAlpha);
		
		mlCurrentItemId = mlFirstItemId;
		
		/////////////////////////
		// Handles dynamic scrolling
		OptionMenu_SetOutOfLimit(vMenuItems.length());
		
		cVector2f vSeparator = cVector2f_Zero;
		if (Platform_IsConsole() == false || Platform_IsStreaming())
		{
			/////////////////
			// Mouse sensitivity
			if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
			{
				float fValue = mpConfig.GetFloat("Input", "MouseSensitivity", 1.0f);
				fValue -= 0.01f;
				fValue /= 4.0f;
				fValue = OptionMenu_ButtonOptionsSlider(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsControlsButtonPos, mlCurrentItemId, msSelectedInputMouseButton, fValue, 0.2f / 4.0f, mlActionHorizontal, "", "", vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
				fValue *= 4.0f;
				fValue += 0.01f;
				mpConfig.SetFloat("Input", "MouseSensitivity", fValue);

				msSelectedInputMouseButton = OptionMenu_UpdateFocusCustom(vMenuItems, vMenuItems[mlCurrentItemId], msSelectedInputMouseButton);
			}
			mlCurrentItemId++;
			
			/////////////////
			// Invert Mouse Y
			if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
			{
				bool bValue = mpConfig.GetBool("Input", "InvertMouse", false);
				bValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsControlsButtonPos, mlCurrentItemId, msSelectedInputMouseButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
				mpConfig.SetBool("Input", "InvertMouse", bValue);

				msSelectedInputMouseButton = OptionMenu_UpdateFocusCustom(vMenuItems, vMenuItems[mlCurrentItemId], msSelectedInputMouseButton);
			}
			mlCurrentItemId++;
			
			/////////////////
			// Smooth mouse
			if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
			{
				bool bValue = mpConfig.GetBool("Input", "SmoothMouse", true);
				bValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsControlsButtonPos, mlCurrentItemId, msSelectedInputMouseButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
				mpConfig.SetBool("Input", "SmoothMouse", bValue);
				msSelectedInputMouseButton = OptionMenu_UpdateFocusCustom(vMenuItems, vMenuItems[mlCurrentItemId], msSelectedInputMouseButton);
			}
			mlCurrentItemId++;
			
			/////////////////
			// Keybindings
			if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
			{
				if(OptionMenu_ButtonOptions(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsControlsButtonPos, mlCurrentItemId, msSelectedInputMouseButton, true, vRightAnchor, vInfoBoxPos, mfTransitionAlpha))
				{
					mlFirstItemId = 0;
					mlLastInFocus = 0;
					
					mPrevGroup = eMainMenuGroup_Options_Controls;
					mTargetGroup = eMainMenuGroup_Options_Input_Keybind;
					msTargetFocus = msSelectedInputMouseButton;
					mbKeybindChanged = false;
					mbBindingGamepad = false;
					mKeyBindBackDest = eMainMenuGroup_Options_Controls;
					msKeyBindBackFocus = msSelectedInputMouseButton;
					
					mpKeyConfig.Save();
				}
				msSelectedInputMouseButton = OptionMenu_UpdateFocusCustom(vMenuItems, vMenuItems[mlCurrentItemId], msSelectedInputMouseButton);
			}
			mlCurrentItemId++;
			
			vSeparator = cVector2f(0,15);
		}
		
		///////////////////////////////
		// Gamepad Sens
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			float fValue = mpConfig.GetFloat("Input", "GamepadSensitivity", 2.0f);
			fValue -= 0.01f;
			fValue /= 5.0f;
			fValue = OptionMenu_ButtonOptionsSlider(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsControlsButtonPos+vSeparator, mlCurrentItemId, msSelectedInputMouseButton, fValue, 0.2f / 4.0f, mlActionHorizontal, "", "", vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			fValue *= 5.0f;
			fValue += 0.01f;
			mpConfig.SetFloat("Input", "GamepadSensitivity", fValue);

			msSelectedInputMouseButton = OptionMenu_UpdateFocusCustom(vMenuItems, vMenuItems[mlCurrentItemId], msSelectedInputMouseButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Invert Pad Y
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			bool bValue = mpConfig.GetBool("Input", "InvertPad", false);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsControlsButtonPos+vSeparator, mlCurrentItemId, msSelectedInputMouseButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			if(bValue != bNewValue) mpConfig.SetBool("Input", "InvertPad", bNewValue);

			msSelectedInputMouseButton = OptionMenu_UpdateFocusCustom(vMenuItems, vMenuItems[mlCurrentItemId], msSelectedInputMouseButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Pad vibration
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			bool bValue = mpConfig.GetBool("Input", "Rumble", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsControlsButtonPos+vSeparator, mlCurrentItemId, msSelectedInputMouseButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			if(bValue != bNewValue) mpConfig.SetBool("Input", "Rumble", bNewValue);

			msSelectedInputMouseButton = OptionMenu_UpdateFocusCustom(vMenuItems, vMenuItems[mlCurrentItemId], msSelectedInputMouseButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Gamepad Presets
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			if(OptionMenu_ButtonOptions(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsControlsButtonPos+vSeparator, mlCurrentItemId, msSelectedInputMouseButton, true, vRightAnchor, vInfoBoxPos, mfTransitionAlpha))
			{
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				
				mPrevGroup = eMainMenuGroup_Options_Controls;
				mTargetGroup = eMainMenuGroup_Options_Input_GamepadMapping;
				mKeyBindBackDest = eMainMenuGroup_Options_Controls;
				msTargetFocus = msSelectedInputMappingButton;
				mpKeyConfig.Save();
			}

			msSelectedInputMouseButton = OptionMenu_UpdateFocusCustom(vMenuItems, vMenuItems[mlCurrentItemId], msSelectedInputMouseButton);
		}
		if (cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false)
			mlCurrentItemId++;
			
		/////////////////
		// Back
		{
			bool bButton = MainMenu_DoBackButton(msSelectedInputMouseButton, mfTransitionAlpha);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				
				mTargetGroup = eMainMenuGroup_Options;
				msTargetFocus = msSelectedOptionsButton;
				
				if (ImGui_TimerExists("TransitionOut") == false)
					ImGui_AddTimer("TransitionOut", 10);

				ApplySettings();

				//////////
				// Reset menu pos
				/*if(bGamepad == false)
				{
					OptionMenu_ShowGamepadButtons(msSelectedInputMouseButton != "Back");
					//msSelectedInputMouseButton = "MouseSens";
					return;
				}*/
			}
			
			tString sID = cLux_GetInputHandler().GetGamepadWasLastDeviceUsed() ? vMenuItems[mlCurrentItemId] : "Back";
			msSelectedInputMouseButton = OptionMenu_UpdateFocus(sID, msSelectedInputMouseButton);
		}
		
		GuiHandleTransition(mTargetGroup, msTargetFocus);

		//////////////////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);

	}
	
	//------------------------------------------------------- 
	
	tString ParseKeybind(tString asBind, bool abAnalog)
	{
		if(asBind.length() > 0)
		{
			int lPos = cString_GetFirstCharPos(asBind, '.');

			if(lPos != -1)
			{
				tString sType = cString_Sub(asBind, 0, lPos);

				if(sType == "Gamepad")
				{
					if(abAnalog)
					{
						tString sAxisNum = cString_Sub(asBind, lPos+8);
						sAxisNum = cString_Sub(sAxisNum, 0, cString_GetFirstCharPos(sAxisNum, '.'));
						int lAxis = cString_ToInt(sAxisNum, 0);

						return "Stick."+(lAxis / 2);
					}
					else
					{
						tString sKey = cString_Sub(asBind, lPos+3);

						return sKey;
					}
				}
				else
				{
					tString sKey = cString_Sub(asBind, lPos+1);

					return sKey;
				}
			}
		}

		return asBind;
	}
	
	//------------------------------------------------------- 
	
	void GuiOptionsInputKeybind()
	{
		GuiPauseDarkOverlay();
		
		////////////////////////////
		// Select which type to bind
		array<cBindableAction> vActions = mbBindingGamepad ? mvGamepadActions : mvActions;
		tString sMain = mbBindingGamepad ? "GamepadPrimary" : "Primary";
		tString sSec = mbBindingGamepad ? "GamepadSecondary" : "Secondary";
		
		int c = 0;
		int lNumBinds = 11;
		
		ImGui_SetTransCategory("Actions"); 
		for(uint i = 0; i < vActions.size(); ++i)
		{
			OptionMenu_UpdateButtonWidth(vActions[i].msAction);	
		}

		for(int i = mlKeybindOffset; i < vActions.size() && c < lNumBinds; ++i)
		{
			tString sBind = vActions[i].msAction;
			tString sPrimary = ParseKeybind(mpKeyConfig.GetString(sBind, sMain, ""), vActions[i].mbAnalog);
			tString sSecondary = ParseKeybind(mpKeyConfig.GetString(sBind, sSec, ""), vActions[i].mbAnalog);
			
			ImGui_SetTransCategory("ButtonNames"); 
			OptionMenu_UpdateKeybindExtraWidth(sPrimary, sSecondary);
		}
		
		////////////////////////////////////
		// Menu positioning
		cVector2f vKeybindMenuSize = kKeybindBgSize;
		vKeybindMenuSize += cVector2f(gfOptionsMenu_ExtraWidth+gfOptionsMenu_ExtraWidth_Keybind,0); // Edit this to minimize space between label and btn
		cVector2f vRightAnchor = cVector2f(kKeybindBgPos.x+vKeybindMenuSize.x-40,0);
		
		cVector2f kKeybindMenuFrameSize = cVector2f(vKeybindMenuSize.x-75, 382);
		cVector2f kKeybindMenuScrollPos = cVector2f(kKeybindBgPos.x+vKeybindMenuSize.x-40, kKeybindButtonPos.y);
		cVector2f kKeybindScrollSize = cVector2f(14, kKeybindMenuFrameSize.y);
		
		cImGuiGfx gfxKeybindsScrollBar = cImGuiGfx("startmenu_scrollbar.tga", eImGuiGfx_Texture);
		gfxKeybindsScrollBar.mColor = cColor(1,mfTransitionAlpha) * gOptionMenu_ModColor;
		
		DoBackground(vRightAnchor.x + 100);
		
		////////////////
		// Title
		cVector2f vMenuPos = kKeybindBgPos + cVector2f(0,25);
		cVector2f vMenuSize = kKeybindBgSize + cVector2f(gfOptionsMenu_ExtraWidth, 0);
		
		ImGui_SetTransCategory("Menu");
		OptionMenu_SectionTitle("Controls", kOptionsControlsBgPos + cVector2f(40,-145), 1.f, mfTransitionAlpha);
		
		ImGui_DrawGfx(cImGuiGfx(), OptionMenu_GetTopLeftOffset(vMenuPos + cVector2f(35, 0.0), 0.01), OptionMenu_GetScaledSize(cVector2f(vMenuSize.x - 55,2)), cColor(1, mfTransitionAlpha) * gOptionMenu_ModColor * 0.5);
		
		////////////////////////
		// Get any duplicates
		array<bool> vDuplicates0;
		array<bool> vDuplicates1;
		bool bHasDuplicates = false;

		for(uint i = 0; i < vActions.size(); ++i)
		{
			/////////////////////////////////
			// Check if this is a duplicate
			bool bDuplicate0 = false;
			bool bDuplicate1 = false;
			
			tString sBind = vActions[i].msAction;
			tString sPrimary = mpKeyConfig.GetString(sBind, sMain, "");
			tString sSecondary = mpKeyConfig.GetString(sBind, sSec, "");
			
			bool bCheck0 = sPrimary.length() != 0;
			bool bCheck1 = sSecondary.length() != 0;

			if(bCheck0 || bCheck1)
			{
				if(sSecondary == sPrimary)
				{
					bDuplicate0 = true;
					bDuplicate1 = true;
				}

				for(uint j = 0; j < vActions.size(); ++j)
				{
					if(i == j) continue;

					sBind = vActions[j].msAction;

					tString sComp0 = mpKeyConfig.GetString(sBind, sMain, "");
					tString sComp1 = mpKeyConfig.GetString(sBind, sSec, "");
					
					if(bCheck0 && (sComp0 == sPrimary || sComp1 == sPrimary)) bDuplicate0 = true;
					if(bCheck1 && (sComp0 == sSecondary || sComp1 == sSecondary)) bDuplicate1 = true;

					if((bCheck0 == false || bDuplicate0) && (bCheck1 == false || bDuplicate1)) break;
				}
			}
			
			vDuplicates0.push_back(bDuplicate0);
			vDuplicates1.push_back(bDuplicate1);
			if(bDuplicate0 || bDuplicate1) bHasDuplicates = true;
		}


		/////////////////////////
		// Catch input
		int lActionVertical = 0;
		bool bMouseDown = false;
		float fPadding = mbScrollingKeybindList ? 10000 : 5;

		if(mlActionToBind == 0 && mbShowApplyKeyChanges == false && mbShowReset == false)
		{
			if(ImGui_ActionTriggered(eImGuiAction_Down, true)) lActionVertical++;
			if(ImGui_ActionTriggered(eImGuiAction_Up, true)) lActionVertical--;
			if(ImGui_ActionTriggered(eImGuiAction_ScrollDown, true) && (mlKeybindOffset + mlSelectedKeybindButton) < vActions.size()-1 && mlSelectedKeybindButton != lNumBinds) lActionVertical+=2;
			if(ImGui_ActionTriggered(eImGuiAction_ScrollUp, true) && (mlKeybindOffset + mlSelectedKeybindButton) > 0 && mlSelectedKeybindButton != lNumBinds) lActionVertical-=2;
			bMouseDown = ImGui_ActionIsDown(eImGuiAction_MouseLeft, false);
		}
		
		/////////////////////////////////
		// Draw a list of all keybinds
		for(int i = mlKeybindOffset; i < vActions.size() && c < lNumBinds; ++i)
		{
			////////////////////////////////////
			// Get action and parse the bind
			tString sBind = vActions[i].msAction;

			tString sPrimary = ParseKeybind(mpKeyConfig.GetString(sBind, sMain, ""), vActions[i].mbAnalog);
			tString sSecondary = ParseKeybind(mpKeyConfig.GetString(sBind, sSec, ""), vActions[i].mbAnalog);

			/////////////////////////////////////////////////////////
			// Draw button, use red color if a duplicate is detected
			cColor color0 = vDuplicates0[i] ? cColor(1, 0, 0, 1) : cColor(0,1);
			cColor color1 = vDuplicates1[i] ? cColor(1, 0, 0, 1) : cColor(0,1);
			bool bDuplicate = vDuplicates0[i] || vDuplicates1[i];
			
			int lFocusChange = 0;
			int lButton = OptionMenu_ButtonKeybind("Bind"+c, sBind, sPrimary, sSecondary, kKeybindSlotsPos + cVector2f(26, c * kKeybindSpacing), mlSelectedKeybindButton == c, mlKeybindFocusSlot, lFocusChange, bDuplicate, vRightAnchor, cVector3f_Zero, mfTransitionAlpha);
			
			if(bMouseDown == false)
			{
				if (lFocusChange > 0)
				{
					mlSelectedKeybindButton = c;
					mlKeybindFocusSlot = lFocusChange-1;
				}
			}

			if(lButton > 0 && mlKeybindFocusSlot > 0)
			{
				if(bMouseDown == false || OptionMenu_GetMouseInside(kKeybindMenuScrollPos - cVector2f(fPadding, 0) + cVector2f(OptionMenu_GetExtraWidth(), 0), 
																	kKeybindMenuScrollPos + kKeybindScrollSize + cVector2f(10000, 0)).y == -1)
				{
					mlActionToBind = i+1;
					msKeybindSlot = mlKeybindFocusSlot == 1 ? sMain : sSec;
					msFocusAfterBind = "Bind"+c + msKeybindSlot;
					msKeybindFirstState = "";
				}
			}
			c++;
		}
		
		//////////////
		// Update focus
		if(lActionVertical != 0)
		{
			//////////
			// Select file
			if (lActionVertical<0)	// Scroll up
			{
				if(lActionVertical==-1)
				{
					if (mlSelectedKeybindButton==lNumBinds+1)	// Back button
					{
						mlSelectedKeybindButton = lNumBinds;
					}
					else if (mlSelectedKeybindButton==lNumBinds)
					{
						mlSelectedKeybindButton = lNumBinds-1;
					}
					else
					{
						mlSelectedKeybindButton--;
						if(mlSelectedKeybindButton < 0)
						{
							if(mlKeybindOffset > 0) 
							{
								mlSelectedKeybindButton = 0;
								mlKeybindOffset--;
							}
							else
							{
								mlSelectedKeybindButton = lNumBinds+1;
							}
						}
					}
				}
				else
				{
					// Scrolling with Wheel
					if(mlKeybindOffset > 0) 
					{
						mlKeybindOffset--;
					}
				}
			}
			else	// Scroll down
			{
				if(lActionVertical==1)
				{
					if (mlSelectedKeybindButton==lNumBinds)
					{
						mlSelectedKeybindButton = lNumBinds+1;
					}
					else if (mlSelectedKeybindButton==lNumBinds+1)	// Back button
					{
						mlSelectedKeybindButton = 0;
					}
					else
					{
						mlSelectedKeybindButton++;
						if(mlSelectedKeybindButton >= cMath_Min(vActions.size(),lNumBinds) )
						{
							if(mlKeybindOffset<vActions.size()-lNumBinds) 
							{
								mlSelectedKeybindButton--;
								mlKeybindOffset++;
							}
							else
							{
								///////////
								// No more files, scroll to back button
								mlSelectedKeybindButton = lNumBinds;
							}
						}
					}
				}
				else
				{
					// Scrolling with Wheel
					if(mlKeybindOffset<vActions.size()-lNumBinds) 
					{
						mlKeybindOffset++;
					}
				}
			}
		}
			
		///////////////////////////////
		// Left right focus
		if(mlActionHorizontal != 0 || lActionVertical!=0)
		{
			int lSum = mlKeybindFocusSlot + mlActionHorizontal;
			mlKeybindFocusSlot = cMath_Clamp(lSum, 1, 2);
			
			if (lSum > 0 && lSum < 3)
				Sound_PlayGui("special_fx/frontend/frontend_menu_focus", 1.0f, eSoundEntryType_Gui);
		}

		////////////////////////////////////////
		// Scroll bar
		if(vActions.size() > lNumBinds)
		{
			//////////////////
			// Update input
			float fFiles = vActions.size();
			int lOldOffset = mlKeybindOffset;
			
			cVector2f vMouseScrollMin = kKeybindMenuScrollPos - cVector2f(fPadding, 0);
			cVector2f vMouseScrollMax = kKeybindMenuScrollPos + kKeybindScrollSize + cVector2f(fPadding, 0);
			float fMouseScrollY = OptionMenu_GetMouseInside(vMouseScrollMin, vMouseScrollMax).y;
			
			//////////////////////
			// Scroll using the srollbar
			if(fMouseScrollY != -1.0 && bMouseDown)
			{
				mlKeybindOffset = cMath_RoundToInt((fFiles-lNumBinds) * fMouseScrollY); // TO DO: Check if numbinds is correct
				mbScrollingKeybindList = true;
			}
			
			/////////////////////////////////////
			// Stopped scrolling
			if(bMouseDown == false)
			{
				mbScrollingKeybindList = false;
			}

			mlKeybindOffset = cMath_Clamp(mlKeybindOffset, 0, vActions.size() - lNumBinds);

			if(mlSelectedKeybindButton >= 0 && mlSelectedKeybindButton < lNumBinds && (mlKeybindOffset - lOldOffset) != 0)
			{
				int lDiff = (mlKeybindOffset - lOldOffset);
				mlSelectedKeybindButton = cMath_Clamp(mlSelectedKeybindButton - lDiff, 0, lNumBinds-1);
			}

			float fScaleY = 1.0 - (fFiles - lNumBinds) / fFiles;
			float fPosY = 0;
			if (fFiles>lNumBinds)
				fPosY = (mlKeybindOffset) / (fFiles-lNumBinds);
			
			cImGuiGfx gfxScrollBarBg;
			ImGui_DrawGfx(gfxScrollBarBg, OptionMenu_GetTopLeftOffset(kKeybindMenuScrollPos + cVector2f(-2,0), 0.01), OptionMenu_GetScaledSize(cVector2f(1,kKeybindScrollSize.y)), cColor(1, mfTransitionAlpha) * gOptionMenu_ModColor);
			
			cColor scrollBarColor = (fMouseScrollY == -1.0f && mbScrollingKeybindList == false) || (mlActionToBind > 0 || mbShowApplyKeyChanges || mbShowReset) ? cColor(1,mfTransitionAlpha * 0.8) : gHoverColor * cColor(1,mfTransitionAlpha);
			ImGui_DrawGfx(gfxKeybindsScrollBar, OptionMenu_GetTopLeftOffset(kKeybindMenuScrollPos + kKeybindScrollSize * cVector2f(0, (1.0 - fScaleY) * fPosY), 0.01), OptionMenu_GetScaledSize(kKeybindScrollSize * cVector2f(1, fScaleY)), scrollBarColor);
		}
		
		///////////////////////////
		// define selected key
		tString sSelected;
		if(mlSelectedKeybindButton < lNumBinds)
		{
			sSelected = ("Bind"+mlSelectedKeybindButton);
		}
		else
		{
			if (cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false)
			{
				if(mlSelectedKeybindButton == lNumBinds)
					sSelected = "ResetToDefault";
				else
					sSelected = "Back";
			}
			else
			{
				sSelected = "ResetToDefault";
			}
		}
		
		////////////////////////////
		// End line
		cVector2f vLineBottomPos = vMenuPos;
		vLineBottomPos.y = kOptionMenu_ButtonSpacing * 7 + kKeybindButtonPos.y + 145;
		ImGui_DrawGfx(cImGuiGfx(), OptionMenu_GetTopLeftOffset(vLineBottomPos + cVector2f(35, 10.0), 0.01), OptionMenu_GetScaledSize(cVector2f(vMenuSize.x - 55,2)), cColor(1, mfTransitionAlpha) * gOptionMenu_ModColor * 0.5);
		
		////////////////////////////
		// Reset to default
		{
			if(OptionMenu_ButtonOptions("ResetToDefault", kKeybindButtonPos + cVector2f(0, 165), 7, sSelected, true, cVector2f_Zero, cVector3f_Zero, mfTransitionAlpha))
			{
				mbShowReset = true;
				msFocusNextFrame = "No";
			}

			if(bMouseDown == false)
			{
				if (ImGui_PrevBecameInFocus())
					mlSelectedKeybindButton = lNumBinds;
			}
		}
		
		/////////////////
		// Back
		{
			bool bButton = MainMenu_DoBackButton(sSelected, mfTransitionAlpha); //OptionMenu_ButtonOptions("Back", kKeybindButtonPos+ cVector2f(0, 100)+kBackMargin, 8, sSelected, true, cVector2f_Zero, cVector3f_Zero, mfTransitionAlpha);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);
			if(bButton || bGamepad)
			{
				if(mbKeybindChanged == false)
				{
					mlFirstItemId = 0;
					mlLastInFocus = 0;
				
					mTargetGroup = mPrevGroup;
					msTargetFocus = msSelectedInputMouseButton;
					
					if (ImGui_TimerExists("TransitionOut") == false)
						ImGui_AddTimer("TransitionOut", 10);
				}
				else
				{
					mbShowDuplicateKeys = bHasDuplicates;
					mbShowApplyKeyChanges = true;
					msFocusNextFrame = "No";
				}

				/////////////////
				// Reset menu pos
				if(bGamepad == false)
				{
					mlSelectedKeybindButton = 0;
				}
				
				OptionMenu_ShowGamepadButtons(true);
				return;
			}

			if(bMouseDown == false && ImGui_PrevBecameInFocus())
				mlSelectedKeybindButton = lNumBinds+1;
		}

		/////////////////////////////////
		// Manual focus since we catch input
		if(mlActionToBind == 0 && mbShowApplyKeyChanges == false && mbShowReset == false)
		{
			if(mlSelectedKeybindButton >= 0 && mlSelectedKeybindButton < lNumBinds)
			{
				if(mlKeybindFocusSlot == 0) msFocusNextFrame = "Bind"+mlSelectedKeybindButton;
				if(mlKeybindFocusSlot == 1) msFocusNextFrame = "Bind"+mlSelectedKeybindButton+"Primary";
				if(mlKeybindFocusSlot == 2) msFocusNextFrame = "Bind"+mlSelectedKeybindButton+"Secondary";
			}
			else
			{
				if (cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false)
				{
					if(mlSelectedKeybindButton == lNumBinds)
						msFocusNextFrame = "ResetToDefault";
					else
						msFocusNextFrame = "Back";
				}
				else
				{
					msFocusNextFrame = "ResetToDefault";
				}
			}
		}
		
		if(mbKeybindChanged == false && mbShowReset == false)
			GuiHandleTransition(mTargetGroup, msTargetFocus);

		/////////////////////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
		
		OptionMenu_ResetExtraWidth();
		
		// END KEYBINDINGS
	}
	
	//-------------------------------------------------------
	
	tString msOldProfile;
	tString msOldPreset;
	
	array<tString> mvProfileValues = { "X360 Controller", "PS4 Controller", "Custom" };
	array<tString> mvPresetValues = { "GamepadPreset1", "GamepadPreset3" };
		
	//------------------------------------------------------- 
	
	void GuiOptionsInputGamepadPresets()
	{
		GuiPauseDarkOverlay();

		// Gamepad Presets are defined in Dev_user_keys.cfg, as well as in the Input Handler 
		eGamepadProfile profile = Input_GetCurrentGamepadProfile();
		
		cVector2f vGamepadPresetMenuPos = kOptionsBgPos+cVector2f(0,-100);
		cVector2f vGamepadPresetMenuSize = (profile==eGamepadProfile_PS4) ? kMappingSize_PS4 : kMappingSize;
		cVector2f vRightAnchor = cVector2f(vGamepadPresetMenuPos.x+468,0);
		
		////////////////
		// Title
		ImGui_SetTransCategory("Menu"); 
		OptionMenu_SectionTitle("Controls", kOptionsControlsBgPos + cVector2f(40,-130), 1.f, mfTransitionAlpha);
		
		DoBackground(vRightAnchor.x + 350);
		
		/////////////////
		// Draw preset
		tString sDefaultProfile = gvGamepadProfileValues[profile];
		tString sDefaultPreset = gvGamepadPresetValues[eGamepadPreset_1];
		
		//tString sProfile = mpKeyConfig.GetString("GamepadMapping", "Profile", sDefaultProfile);
		tString sPreset = mpKeyConfig.GetString("GamepadMapping", "Preset", sDefaultPreset);

		tString sCurrentProfile = cLux_GetInputHandler().GetCurrentGamepadProfile();

		///////////////
		// Validation
		//sProfile = (gvGamepadProfileValues.find(sProfile) == -1) ? sDefaultProfile : sProfile;
		//sProfile = sDefaultProfile;
		sPreset = (gvGamepadPresetValues.find(sPreset) == -1) ? sDefaultPreset : sPreset;

		////////////////
		// Get current selection
		int lId = 0;
		//int lProfileId = 0;
		array<tString> vsProfilePresets;

		for (int i = 0; i < mvPresetValues.length(); i++)
		{
			vsProfilePresets.push_back(sCurrentProfile);
			vsProfilePresets.push_back(mvPresetValues[i]);
		}
		
		mlOptionItemId = 0;
		
		//  0       1       2      3       4      5      6      7      8      9     10     11      12      13      14       15     16      17
		// XBOX, PRESET1, XBOX, PRESET2, XBOX, PRESET3, PS4, PRESET1, PS4, PRESET2, PS4, PRESET3, OTHER, PRESET1, OTHER, PRESET2, OTHER, PRESET3
		
		// 0 = XBOX P1; 2 = XBOX P2; 4 = XBOX P3; 6 = PS4 P1; 8 = PS4 P2; 10 = PS4 P3; 12 = OTHER P1; 14 = OTHER P2; 16 = OTHER P3
		
		for(int i = 0; i < vsProfilePresets.length(); i+=2)
		{
			if(vsProfilePresets[i] == sCurrentProfile && vsProfilePresets[i+1] == sPreset)
			{
				lId = i / 2;
				break;
			}
		}
		
		// lId
		// 0 = XBOX P1; 1 = XBOX P2; 2 = XBOX P3; 3 = PS4 P1; 4 = PS4 P2; 5 = PS4 P3; 6 = OTHER P1; 7 = OTHER P2; 8 = OTHER P3
		
		/*for (int i = 0; i < vProfileValues.length(); i++)
		{
			if (sProfile == "X360 Controller")
			{
				lProfileId = 0;
			}
			else if (sProfile == "PS4 Controller")
			{
				lProfileId = 3;
			}
			else
			{
				lProfileId = 6;
			}
		}*/
		
		/*if(ImGui_IsFading("PresetTransition"))
{
			float fAlpha = ImGui_GetStateFloat("PresetTransition");
			GuiOptionsInputMappingGamepadProfile(sProfile, sPreset, fAlpha, false);
			GuiOptionsInputMappingGamepadProfile(msOldProfile, msOldPreset, 1.0f-(fAlpha*3.0f), false);
		}
		else*/
		{
			GuiOptionsInputMappingGamepadProfile(sCurrentProfile, sPreset, 1.0f, false);
		}
		
		///////////////////////
		// Preset Selection
		{
			int lPresetId = lId;
			//cLux_AddDebugMessage("PRESET ID: "+lPresetId);
			int lNewPresetId = OptionMenu_ButtonOptionsMultiSelect("GamepadPreset", vGamepadPresetMenuPos+cVector2f(100,50), 10, msSelectedInputMappingButton, mvPresetValues, lPresetId, false, mlActionHorizontal, "Menu", 0, vRightAnchor, cVector3f_Zero, mfTransitionAlpha, true);
			//cLux_AddDebugMessage("NEW: "+lNewPresetId);
			
			if (lPresetId != lNewPresetId)
			{
				
				lId = lNewPresetId;
				
				mpKeyConfig.SetString("GamepadMapping", "Profile", vsProfilePresets[lId * 2]);
				
				tString sPreset = vsProfilePresets[lId * 2 + 1];
				mpKeyConfig.SetString("GamepadMapping", "Preset", sPreset);
				mbKeybindChanged = true;
					
				msOldProfile = sCurrentProfile;
				msOldPreset = sPreset;
					
				//ImGui_SetStateFloat("PresetTransition", 0.0f);
				//ImGui_FadeStateFloat("PresetTransition", 1.0f, 0.75f);
					
				//ImGui_SetStateFloat("PresetTransitionRight", 1.0f);
				//ImGui_FadeStateFloat("PresetTransitionRight", 0.0f, 0.5f);
	
			}
			
			msSelectedInputMappingButton = OptionMenu_UpdateFocus("GamepadPreset", msSelectedInputMappingButton);
		}
		if (cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false)
			mlCurrentItemId++;
			
		/////////////////
		// Back
		{
			bool bButton = MainMenu_DoBackButton(msSelectedInputMappingButton, mfTransitionAlpha);//OptionMenu_ButtonOptions("Back", vGamepadPresetMenuPos+cVector2f(60,0), 11, msSelectedInputMappingButton, true, cVector2f_Zero ,cVector3f_Zero, mfTransitionAlpha);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				if(mbKeybindChanged == false)
				{
					mlFirstItemId = 0;
					mlLastInFocus = 0;
				
					mTargetGroup = eMainMenuGroup_Options_Controls;
					msTargetFocus = msSelectedOptionsButton;
					
					if (ImGui_TimerExists("TransitionOut") == false)
						ImGui_AddTimer("TransitionOut", 10);
				}
				else
				{
					mbShowApplyKeyChanges = true;
					msFocusNextFrame = "No";
				}

				//////////
				// Reset menu pos
				if(bGamepad == false)
				{
					OptionMenu_ShowGamepadButtons(false);
					msSelectedInputMappingButton = "Back";
					return;
				}
			}
			
			tString sID = cLux_GetInputHandler().GetGamepadWasLastDeviceUsed() ? "GamepadPreset" : "Back";
			msSelectedInputMappingButton = OptionMenu_UpdateFocus(sID, msSelectedInputMappingButton);
		}
		
		if(mbShowApplyKeyChanges == false)
			GuiHandleTransition(mTargetGroup, msTargetFocus);

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
	}
	
	//-------------------------------------------------------
	
	[nosave] int mlNewGamepadPresetSprintMode = -1;
	
	void GuiOptionsInputGamepadPresets_New()
	{
		GuiPauseDarkOverlay();
				
		array<tString> vMenuItems = {"GamepadPreset", "SprintMode"};
			
		for (int i=0; i<vMenuItems.length(); i++)
		{
			OptionMenu_UpdateButtonWidth(vMenuItems[i]);
		}
		
		OptionMenu_UpdateToggleExtraWidth();
			
		array<tString> vRunOptions = {"Hold", "SemiToggle", "Toggle"};
		
		OptionMenu_UpdateMultiSelectionExtraWidth(vRunOptions, "Menu", gfFontSize_MainMenu, OptionMenu_GetScaledSize(100.f).x);
		OptionMenu_AlignExtraButtonWidth();
		
		tString sProfile = cLux_GetInputHandler().GetCurrentGamepadProfile();
		if(sProfile=="") sProfile = cLux_GetInputHandler().GetDefaultGamepadProfile();
		tString sProfileCode = cLux_GetInputHandler().GetGamepadProfilePrefix(sProfile);

		tString sDefaultPreset = gvGamepadPresetValues[eGamepadPreset_1];
		tString sPreset = mpKeyConfig.GetString("GamepadMapping", "Preset_" + sProfileCode, sDefaultPreset);
		eGamepadProfile pluggedGamepadProfile = Input_GetCurrentGamepadProfile();

		// Gamepad Presets are defined in Dev_user_keys.cfg, as well as in the Input Handler 
		
		cVector2f vGamepadPresetMenuPos = kOptionsBgPos+cVector2f(0,-100);
		cVector2f vGamepadPresetMenuSize = (pluggedGamepadProfile==eGamepadProfile_PS4) ? kMappingSize_PS4 : kMappingSize;
		vGamepadPresetMenuSize += cVector2f(gfOptionsMenu_ExtraWidth + gfOptionsMenu_ExtraWidth_MultiSelect, 0);
		float fInfoBoxOffset = (pluggedGamepadProfile==eGamepadProfile_PS4) ? 600.f : 450.f;
		cVector3f vInfoBoxPos = OptionMenu_GetTopLeftOffset(cVector2f(vGamepadPresetMenuPos.x+vGamepadPresetMenuSize.x-fInfoBoxOffset,0),0);
		cVector2f vRightAnchor = cVector2f(vGamepadPresetMenuPos.x+468 + gfOptionsMenu_ExtraWidth_MultiSelect,0);
		
		////////////////
		// Title
		mlCurrentItemId = mlFirstItemId;
		
		ImGui_SetTransCategory("Menu"); 
		OptionMenu_SectionTitle("Controls", kOptionsControlsBgPos + cVector2f(40,-130), 1.f, mfTransitionAlpha);
		
		DoBackground(vRightAnchor.x + 550);
		
		///////////////
		// Validation
		sPreset = (gvGamepadPresetValues.find(sPreset) == -1) ? sDefaultPreset : sPreset;

		if(sProfile != mpKeyConfig.GetString("GamepadMapping", "LastPluggedProfile", ""))
		{
			mpKeyConfig.SetString("GamepadMapping", "LastPluggedProfile", sProfile);
			mpKeyConfig.SetString("GamepadMapping", "Preset_" + sProfileCode, sPreset);
		}

		////////////////
		// Get current selection
		int lId = 0;
		array<tString> vsProfilePresets;
		
		mlOptionItemId = 0;
		
		GuiOptionsInputMappingGamepadProfile(sProfile, sPreset, 1.0f, false);

		cLux_GetInputHandler().GetGamepadProfilePresetNames(sProfile, vsProfilePresets);
		for(int i=0; i<vsProfilePresets.size(); ++i)
		{
			if(sPreset!=vsProfilePresets[i])
				continue;

			lId = i;
			break;
		}
		
		///////////////////////
		// Preset Selection
		{
			int lPresetId = lId;
			int lNewPresetId = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], vGamepadPresetMenuPos+cVector2f(80,60), 10, msSelectedInputMappingButton, mvPresetValues, lPresetId, false, mlActionHorizontal, "Menu", 0, vRightAnchor, cVector3f_Zero, mfTransitionAlpha, true, false, true, "", cString_To16Char(""), true, true);
			
			if (lPresetId != lNewPresetId)
			{
				lId = lNewPresetId;
				
				sPreset = vsProfilePresets[lNewPresetId];
				mpKeyConfig.SetString("GamepadMapping", "Preset_" + sProfileCode, sPreset);
				mbKeybindChanged = true;
					
				msOldProfile = sProfile;
				msOldPreset = sPreset;
				
				mlNewGamepadPresetSprintMode = lNewPresetId;
			}
			
			msSelectedInputMappingButton = OptionMenu_UpdateFocus("GamepadPreset", msSelectedInputMappingButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Sprint Mode
		{			
			int lValue = mlNewGamepadPresetSprintMode == -1 ? mpConfig.GetInt("Accessibility", "SprintMode", 0) : mlNewGamepadPresetSprintMode;
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], vGamepadPresetMenuPos+cVector2f(80,60), 11, msSelectedInputMappingButton, vRunOptions, lValue, false, mlActionHorizontal, "menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha, false, false, true, "", cString_To16Char(""), true, true);
			if (lNewValue != lValue)
			{
				mbKeybindChanged = true;
				mlNewGamepadPresetSprintMode = lNewValue;
			}
			msSelectedInputMappingButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedInputMappingButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Back
		{
			bool bButton = MainMenu_DoBackButton(msSelectedInputMappingButton, mfTransitionAlpha);//OptionMenu_ButtonOptions("Back", vGamepadPresetMenuPos+cVector2f(60,0), 11, msSelectedInputMappingButton, true, cVector2f_Zero ,cVector3f_Zero, mfTransitionAlpha);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				if(mbKeybindChanged == false)
				{
					mlFirstItemId = 0;
					mlLastInFocus = 0;
				
					mTargetGroup = eMainMenuGroup_Options_Controls;
					msTargetFocus = msSelectedInputMouseButton;
					
					if (ImGui_TimerExists("TransitionOut") == false)
						ImGui_AddTimer("TransitionOut", 10);
						
					mlNewGamepadPresetSprintMode = -1;
				}
				else
				{
					mbShowApplyKeyChanges = true;
					msFocusNextFrame = "No";
				}

				//////////
				// Reset menu pos
				if(bGamepad == false)
				{
					OptionMenu_ShowGamepadButtons(false);
					msSelectedInputMappingButton = "Back";
					return;
				}
			}
			
			tString sID = cLux_GetInputHandler().GetGamepadWasLastDeviceUsed() ? msSelectedInputMappingButton : "Back";
			msSelectedInputMappingButton = OptionMenu_UpdateFocus(sID, msSelectedInputMappingButton);
		}
		
		if(mbShowApplyKeyChanges == false)
			GuiHandleTransition(mTargetGroup, msTargetFocus);

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
	}
	
	//------------------------------------------------------- 
	
	cVector2f mvButtonPos, mvLabelPos;

	void GuiOptionsInputMappingGamepadProfile(const tString &in asProfile, const tString &in asPreset, float afAlpha, bool abFadeController)
	{
		eGamepadProfile pluggedGamepadProfile = Input_GetCurrentGamepadProfile();

		//cImGuiGfx gfxController;
		//array<cVector3f> vControlGroupPositions;

		cGamepadProfileLayoutData layoutData;
		
		GetGamepadProfileLayout(pluggedGamepadProfile, @layoutData);
		
		ImGui_SetModColorMul(cColor(1, layoutData.mfControllerAlpha*afAlpha*mfTransitionAlpha));
		ImGui_SetAlignment(eImGuiAlign_CenterCenter);
		ImGui_DoImage(layoutData.mGfxController, layoutData.mvReferencePos+cVector3f(layoutData.mvFrameSize.x, layoutData.mvFrameSize.y,0)*0.5f, layoutData.mvControllerSize);
		ImGui_SetAlignment(eImGuiAlign_TopLeft);
		
		ImGui_SetModColorMul(cColor(1, afAlpha)*cColor(1,mfTransitionAlpha));
		
		layoutData.mvReferencePos.z += 1.0f;
		
		cImGuiLabelData labelData;
		labelData.mFont.SetFile(FontHandler_GetFont(eFontType_MainMenu_InfoBox, 56));
		labelData.mFont.mvSize = cVector2f(14);
		labelData.mFont.mColor = cColor(1,1);
		labelData.mFontAlign = eFontAlign_Center;
		
		// Left shoulder buttons
		cVector3f vPos = layoutData.mvControlGroupPositions[0];
		
		if(DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Axis.4.Positive", labelData, vPos, layoutData.mfGfxHeight, false))
			vPos.y += layoutData.mfEntrySeparation;
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.9", labelData, vPos, layoutData.mfGfxHeight, false);
	
		// Right shoulder buttons
		vPos = layoutData.mvControlGroupPositions[1];
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Axis.5.Positive", labelData, vPos, layoutData.mfGfxHeight);
		vPos.y += layoutData.mfEntrySeparation;
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.10", labelData, vPos, layoutData.mfGfxHeight);
		
		// Select
		vPos = layoutData.mvControlGroupPositions[2];
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.4", labelData, vPos, layoutData.mfGfxHeight, false);
		
		// Start
		vPos = layoutData.mvControlGroupPositions[3];
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.6", labelData, vPos, layoutData.mfGfxHeight);
		
		// D-Pad Up
		vPos = layoutData.mvControlGroupPositions[4];
		if(DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.11", labelData, vPos, layoutData.mfGfxHeight, false))
			vPos.y += layoutData.mfEntrySeparation;
		// D-Pad Down
		if(DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.12", labelData, vPos, layoutData.mfGfxHeight, false))
			vPos.y += layoutData.mfEntrySeparation;
		// D-Pad Left
		if(DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.13", labelData, vPos, layoutData.mfGfxHeight, false))
			vPos.y += layoutData.mfEntrySeparation;
		// D-Pad Right
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.14", labelData, vPos, layoutData.mfGfxHeight, false);
		
		vPos = layoutData.mvControlGroupPositions[5];
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.7", labelData, vPos, layoutData.mfGfxHeight, false);
		
		vPos = layoutData.mvControlGroupPositions[6];
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.8", labelData, vPos, layoutData.mfGfxHeight);
		
		// A
		vPos = layoutData.mvControlGroupPositions[7];
		if(DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.0", labelData, vPos, layoutData.mfGfxHeight, true, layoutData.mvButtonColors[0]))
			vPos.y += layoutData.mfEntrySeparation;
		// B
		if(DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.1", labelData, vPos, layoutData.mfGfxHeight, true, layoutData.mvButtonColors[1]))
			vPos.y += layoutData.mfEntrySeparation;
		// Y
		if(DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.3", labelData, vPos, layoutData.mfGfxHeight, true, layoutData.mvButtonColors[3]))
			vPos.y += layoutData.mfEntrySeparation;
		// X
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.2", labelData, vPos, layoutData.mfGfxHeight, true, layoutData.mvButtonColors[2]);
		
		ImGui_ResetModifiers();
	}
	
	void GetGamepadProfileLayout(eGamepadProfile aProfile, cGamepadProfileLayoutData @apOutLayoutData)
	{	
		cVector3f mvReferencePos;
		cVector2f mvFrameSize;
		cVector2f mvControllerSize;
		float mfGfxHeight;
		float mfControllerAlpha;
		float mfEntrySeparation;

		cImGuiGfx mGfxController;
		array<cVector3f> mvControlGroupPositions;
		array<cColor> mvButtonColors;
		mvButtonColors.resize(4);

		// Draw controller image and set buttons positions
		
		if(aProfile==eGamepadProfile_X360)
		{
			mvReferencePos = OptionMenu_GetTopLeftOffset(kMappingPos, 1.0);
			mvFrameSize = OptionMenu_GetScaledSize(kGamepadPresetSize);
			mvControllerSize = mvFrameSize;
			mfControllerAlpha = kMappingGamepadAlpha;
			mfGfxHeight = mvFrameSize.y;
			mfGfxHeight *= kMappingGfxHeightMul;
			mfEntrySeparation = mfGfxHeight*1.0f;

			mGfxController = cImGuiGfx(Platform_IsXboxOne() ? "controller_XBOX.dds" : "controller_XSX.dds", eImGuiGfx_Texture);
			
			mvControlGroupPositions.push_back(mvReferencePos+cVector3f(mvFrameSize.x*0.25f, mfGfxHeight, 0));						// 0 Left shoulder
			mvControlGroupPositions.push_back(mvReferencePos+cVector3f(mvFrameSize.x*0.75f, mfGfxHeight, 0));						// 1 Right shoulder
			mvControlGroupPositions.push_back(mvReferencePos+cVector3f(mvFrameSize.x*0.475f, mfGfxHeight, 0));						// 2 Back
			mvControlGroupPositions.push_back(mvReferencePos+cVector3f(mvFrameSize.x*0.525f, mfGfxHeight, 0));						// 3 Start
			mvControlGroupPositions.push_back(mvControlGroupPositions[0]+cVector3f(0,mfEntrySeparation*4.0f,0.0f));						// 4 DPAD
			mvControlGroupPositions.push_back(mvControlGroupPositions[0]+cVector3f(0,mfEntrySeparation*2.5f,0.0f));						// 5 Left stick
			mvControlGroupPositions.push_back(mvReferencePos+cVector3f(mvFrameSize.x*0.575f, mvFrameSize.y*0.9f, 0));			// 6 Right stick
			mvControlGroupPositions.push_back(mvControlGroupPositions[1]+cVector3f(0, mfGfxHeight+mfEntrySeparation*2.0f, 0));			// 7 Action button block

			// Button Colors (Xbox used as reference)
			mvButtonColors[0] = cColor(0,0.8,0.4,1);
			mvButtonColors[1] = cColor(1,0.4,0.4,1);
			mvButtonColors[2] = cColor(0.9,0.78,0.11,1);
			mvButtonColors[3] = cColor(0.04,0.57,0.78,1);
		}
		else if(aProfile==eGamepadProfile_PS4)
		{
			mvReferencePos = OptionMenu_GetTopLeftOffset(kMappingPos_PS4, 1.0);
			mvFrameSize = OptionMenu_GetScaledSize(kGamepadPresetSize_PS4);
			mvControllerSize = mvFrameSize;
			mfControllerAlpha = kMappingGamepadAlpha_PS4;
			mfGfxHeight = mvFrameSize.y;
			mfGfxHeight *= kMappingGfxHeightMul_PS4;
			mfEntrySeparation = mfGfxHeight*1.0f;

			mGfxController = cImGuiGfx(cLux_GetInputHandler().GetGamepadType(0)==eGamepadType_PS5? "controller_PS5.dds" : "controller_PS4.dds", eImGuiGfx_Texture);
					
			mvControlGroupPositions.push_back(mvReferencePos+cVector3f(mvFrameSize.x*0.025f, -mvFrameSize.y*0.05f, 0));						// 0 Left shoulder
			mvControlGroupPositions.push_back(mvReferencePos+cVector3f(mvFrameSize.x*1.0f, -mvFrameSize.y*0.05f, 0));						// 1 Right shoulder
			mvControlGroupPositions.push_back(mvReferencePos+cVector3f(mvFrameSize.x*0.475f, -mvFrameSize.y*0.05f, 0));						// 2 Back
			mvControlGroupPositions.push_back(mvReferencePos+cVector3f(mvFrameSize.x*0.525f, -mvFrameSize.y*0.05f, 0));						// 3 Start
			mvControlGroupPositions.push_back(mvControlGroupPositions[0]+cVector3f(0, mfEntrySeparation*3.0f,0.0f));					// 4 DPAD
			mvControlGroupPositions.push_back(mvReferencePos+cVector3f(mvFrameSize.x*0.425f, mvFrameSize.y*0.75f,0.0f));			// 5 Left stick
			mvControlGroupPositions.push_back(mvReferencePos+cVector3f(mvFrameSize.x*0.575f, mvFrameSize.y*0.75f, 0));			// 6 Right stick
			mvControlGroupPositions.push_back(mvControlGroupPositions[1]+cVector3f(0, mfGfxHeight+mfEntrySeparation*2.0f, 0));			// 7 Action button block

			// Button Colors
			mvButtonColors[0] = cColor(0.42,0.54,0.78,1);
			mvButtonColors[1] = cColor(1,0.4,0.4,1);
			mvButtonColors[2] = cColor(0.87,0.55,0.75,1);
			mvButtonColors[3] = cColor(0.19,0.87,0.6,1);
		}
		else
		{
			mvReferencePos = OptionMenu_GetTopLeftOffset(kMappingPos, 1.0);
			mvFrameSize = OptionMenu_GetScaledSize(kGamepadPresetSize);
			mvControllerSize = mvFrameSize;
			mfControllerAlpha = kMappingGamepadAlpha;
			mfGfxHeight = mvFrameSize.y;
			mfGfxHeight *= kMappingGfxHeightMul;
			mfEntrySeparation = mfGfxHeight*1.0f;

			mGfxController = cImGuiGfx();
			mGfxController.mColor = cColor(0.3f, 0.3f);
			
			mvControlGroupPositions.push_back(mvReferencePos+cVector3f(mvFrameSize.x*0.25f, mfGfxHeight, 0));						// 0 Left shoulder
			mvControlGroupPositions.push_back(mvReferencePos+cVector3f(mvFrameSize.x*0.75f, mfGfxHeight, 0));						// 1 Right shoulder
			mvControlGroupPositions.push_back(mvReferencePos+cVector3f(mvFrameSize.x*0.475f, mfGfxHeight, 0));						// 2 Back
			mvControlGroupPositions.push_back(mvReferencePos+cVector3f(mvFrameSize.x*0.525f, mfGfxHeight, 0));						// 3 Start
			mvControlGroupPositions.push_back(mvControlGroupPositions[0]+cVector3f(0, mfEntrySeparation*3.0f,0.0f));					// 4 DPAD
			mvControlGroupPositions.push_back(mvReferencePos+cVector3f(mvFrameSize.x*0.425f, mvFrameSize.y*0.9f,0.0f));			// 5 Left stick
			mvControlGroupPositions.push_back(mvReferencePos+cVector3f(mvFrameSize.x*0.575f, mvFrameSize.y*0.9f, 0));			// 6 Right stick
			mvControlGroupPositions.push_back(mvControlGroupPositions[1]+cVector3f(0, mfGfxHeight+mfEntrySeparation*2.0f, 0));			// 7 Action button block

			mvButtonColors[0] = cColor(0,0.8,0.4,1);
			mvButtonColors[1] = cColor(1,0.4,0.4,1);
			mvButtonColors[2] = cColor(0.9,0.78,0.11,1);
			mvButtonColors[3] = cColor(0.04,0.57,0.78,1);
		}

		apOutLayoutData.mvReferencePos = mvReferencePos;
		apOutLayoutData.mvFrameSize = mvFrameSize;
		apOutLayoutData.mvControllerSize = mvControllerSize;
		apOutLayoutData.mfControllerAlpha = mfControllerAlpha;
		apOutLayoutData.mfGfxHeight = mfGfxHeight;
		apOutLayoutData.mfEntrySeparation = mfEntrySeparation;

		apOutLayoutData.mGfxController = mGfxController;
		apOutLayoutData.mvControlGroupPositions = mvControlGroupPositions;
		apOutLayoutData.mvButtonColors = mvButtonColors;
	}
	
	//------------------------------------------------------- 
	
	bool DrawGamepadButtonActionPair(const tString &in asProfile, const tString &in asPreset, const tString &in asGamepadString, 
									const cImGuiLabelData &in aLabelData, const cVector3f &in avPosition, float afGfxHeight, bool abLeftToRight=true, cColor aColor=cColor_White)
	{
		tString sActions;
		array<tString> vIgnoredActions = {	"MenuUp", 
											"MenuDown", 
											"MenuLeft", 
											"MenuRight", 
											"MenuCancel", 
											"MenuConfirm", 
											"GamepadBack", 
											"GamepadRotateUp", 
											"GamepadRotateDown", 
											"GamepadRotateLeft", 
											"GamepadRotateRight", 
											"InteractCancel", 
											"SketchbookPrevTab", 
											"SketchbookNextTab",
											"InventoryUse",
											"InventoryAdjustStack",
											"InventoryCombine"
										};
		
		cLux_GetInputHandler().GetActionsAssociatedToGamepadControl(asProfile, asPreset, asGamepadString, sActions);

		if(sActions.length()==0) 
		{	
			Error("No actions found for profile "+asProfile);
			return false;
		}
					
		float fLabelSeparation = afGfxHeight*1.25f;
		
		array<tString> vActions;
		cString_GetStringVec(sActions, vActions, "/");
				
		float fLabelMaxLength = -1.0f;
		array<tWString> vActionLabels;
		
		for(int i=0; i<vActions.size(); ++i)
		{
			bool bSkip = false;
			for (int j = 0; j < vIgnoredActions.length(); j++)
			{
				if (vActions[i] == vIgnoredActions[j])
				{
					bSkip = true;
					break;
				}
			}
			
			if (bSkip) continue;
			
			tWString sActionLabel = cResources_Translate("Actions", vActions[i]);
			if (sActionLabel.length()==0)
				continue;
							
			vActionLabels.push_back(sActionLabel);
			
			float fActionLabelLength = GetFontLengthW(aLabelData.mFont, 1.0f, sActionLabel);
			
			if(fLabelMaxLength<fActionLabelLength)
				fLabelMaxLength = fActionLabelLength;
		}

		if(vActionLabels.size() == 0)
			return false;
				
		tString sProfilePrefix, sInputLayoutString;
		cLux_GetInputHandler().FetchGamepadInputLayoutString(asGamepadString, sProfilePrefix, sInputLayoutString);
		//cLux_AddDebugMessage(sProfilePrefix);
		array<tString> vGfxParts;
		cString_GetStringVec(sInputLayoutString, vGfxParts, ",");

		
		cVector3f vPosition = avPosition;
		vPosition.z += vGfxParts.length()*0.01f;
		
		eImGuiAlign align = eImGuiAlign_CenterRight;
		if(abLeftToRight)
		{
			align = eImGuiAlign_CenterLeft;
		}
		else
		{
			align = eImGuiAlign_CenterRight;
		}
				
		ImGui_SetAlignment(align);
		
		// Draw icons
		for(int i=0; i<vGfxParts.length(); ++i)
		{
			tString sGfxFile = sProfilePrefix + "/" + vGfxParts[i];
			cImGuiGfx gfxControl(sGfxFile, eImGuiGfx_Texture);
			cVector2f vControlSize = ImGui_GetRatioCorrectSizeByHeight(gfxControl, afGfxHeight);
			gfxControl.mColor = aColor;
			ImGui_DoImage(gfxControl, vPosition, vControlSize);
		
			vPosition.z -= 0.01f;
		}
		
		cVector2f vLayoutSize = cVector2f(0, vActionLabels.length()*aLabelData.mFont.mvSize.y+2.0f);

		cVector3f vLayoutPos = avPosition;
		vLayoutPos.y -= vLayoutSize.y*0.5f;
		if(abLeftToRight)
		{
			vLayoutPos.x += fLabelSeparation;
			align = eImGuiAlign_TopLeft;
		}
		else
		{
			align = eImGuiAlign_TopRight;
			vLayoutPos.x -= fLabelSeparation;
		}
				
		ImGui_SetAlignment(align);
							
			
		ImGui_LayoutBegin(eImGuiLayout_Y, vLayoutPos, vLayoutSize);
			for(int i=0; i<vActionLabels.length(); ++i)
				cLux_GetCurrentImGui().DoLabel(vActionLabels[i], aLabelData);
		ImGui_LayoutEnd();
		
		ImGui_SetAlignment(eImGuiAlign_TopLeft);

		return true;
	}


	//------------------------------------------------------- 
	
	void GuiOptionsDisplay()
	{		
		GuiPauseDarkOverlay();
		
		array<tString> vMenuItems = {"Resolution", "ResolutionScale", "DynamicResolution", "DisplayMode", "VSync", "UpdateRate", "AllowSlowdowns", "FOV"};
		array<tString> vDisplayValues = { "Fullscreen", "Windowed", "Borderless" };
		array<tString> vVSyncValues = { "On", "Adaptive", "Off" };
		
		if (cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false)
			vMenuItems.push_back("Back");
				
		for (int i=0; i<=vMenuItems.length()-1; i++)
		{
			OptionMenu_UpdateButtonWidth(vMenuItems[i]);
		}
		
		OptionMenu_UpdateToggleExtraWidth();
		OptionMenu_UpdateMultiSelectionExtraWidth(vDisplayValues);
		OptionMenu_UpdateMultiSelectionExtraWidth(vVSyncValues);
		OptionMenu_AlignExtraButtonWidth();
				
		////////////////////////////////////
		// Options background
		cVector2f vDisplayMenuPos = kOptionsDisplayBgPos;
		cVector2f vDisplayMenuSize = kOptionsDisplayBgSize+cVector2f(gfOptionsMenu_ExtraWidth+gfOptionsMenu_ExtraWidth_MultiSelect,0);
		cVector3f vInfoBoxPos = OptionMenu_GetTopLeftOffset(cVector2f(vDisplayMenuPos.x+vDisplayMenuSize.x,0),0);
		cVector2f vRightAnchor = cVector2f(vDisplayMenuPos.x+vDisplayMenuSize.x-40,0);
		
		DoBackground(vRightAnchor.x + 100);
		
		////////////////
		// Title
		OptionMenu_SectionTitle("Display", kOptionsDisplayBgPos + cVector2f(40,-40), 1.f, mfTransitionAlpha);
		
		mlCurrentItemId = mlFirstItemId;
		
		/////////////////////////
		// Handles dynamic scrolling
		OptionMenu_SetOutOfLimit(vMenuItems.length());
		
		/////////////////
		// Resolution
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			/////////////
			// Get current resolution and update config
			int lResolution = GetCurrentResolution();
			int lNewResolution = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDisplayButtonPos, mlCurrentItemId, msSelectedDisplayButton, mvResolutionValues, lResolution, false, mlActionHorizontal, "", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha, false, false, true, "", cString_To16Char(""), true);
			
			if(lResolution != lNewResolution)
			{
				mlOptionChanges++;
				SetCurrentResolution(lNewResolution);
			}

			msSelectedDisplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDisplayButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Resolution Scale
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			/////////////
			// Get current resolution and update config
			float fResolutionScaleMin = 10;
			float fResolutionScaleMax = 200;
			float fValue = mpConfig.GetFloat("Screen", "ResolutionScale", 1) * 100;

			tString sTextValue = "" + (cMath_RoundToInt(fValue) / 5) * 5;

			fValue = (fValue - fResolutionScaleMin) / (fResolutionScaleMax - fResolutionScaleMin);
			float fNewValue = OptionMenu_ButtonOptionsSlider(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDisplayButtonPos, mlCurrentItemId, msSelectedDisplayButton, fValue, 0.05, mlActionHorizontal, sTextValue, "", vRightAnchor, vInfoBoxPos, mfTransitionAlpha, false, true, true);
			if(fValue != fNewValue)
			{
				mlOptionChanges++;
				fNewValue = (fNewValue * (fResolutionScaleMax - fResolutionScaleMin) + fResolutionScaleMin) / 100;
				mpConfig.SetFloat("Screen", "ResolutionScale", fNewValue);
			}

			msSelectedDisplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDisplayButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Dynamic Resolution
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Screen", "DynamicResolution", false);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDisplayButtonPos, mlCurrentItemId, msSelectedDisplayButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if (bValue != bNewValue)
			{
				mpConfig.SetBool("Screen", "DynamicResolution", bNewValue);
				mlOptionChanges++;
			}
			 
			msSelectedDisplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDisplayButton);
		}
		mlCurrentItemId++;

		/////////////////
		// Display Mode
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config

			tString sValue = cString_ToLowerCase(mpConfig.GetString("Screen", "FullScreen", "true"));

			int lValue = (sValue == "true") ? 0 : (sValue == "borderless" ? 2 : 1); 
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDisplayButtonPos, mlCurrentItemId, msSelectedDisplayButton, vDisplayValues, lValue, false, mlActionHorizontal, "Menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha, false, false, true, "", cString_To16Char(""), true);

			if(lValue != lNewValue)
			{
				mlOptionChanges++;
				mpConfig.SetString("Screen", "FullScreen", (lNewValue == 0) ? "true" :
														   (lNewValue == 1	? "false" : "borderless"));
			}

			msSelectedDisplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDisplayButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// V-sync
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			tString sValue = cString_ToLowerCase(mpConfig.GetString("Screen", "Vsync", "true"));

			int lValue = (sValue == "true") ? 0 : (sValue == "adaptive" ? 1 : 2);
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDisplayButtonPos, mlCurrentItemId, msSelectedDisplayButton, vVSyncValues, lValue, false, mlActionHorizontal, "Menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha, false, false, true, "", cString_To16Char(""), true);
			
			if(lValue != lNewValue)
			{
				mlOptionChanges++;
				mpConfig.SetString("Screen", "Vsync",	(lNewValue == 0)	? "true" :
														(lNewValue == 1		? "adaptive" : "false"));
			}
			 
			msSelectedDisplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDisplayButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Framerate
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			int lValue = GetCurrentRefreshRate();
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDisplayButtonPos, mlCurrentItemId, msSelectedDisplayButton, mvRefreshValues, lValue, false, mlActionHorizontal, "", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha, false, false, true, "", cString_To16Char(""), true);
			
			if(lValue != lNewValue)
			{
				mlOptionChanges++;
				SetCurrentRefreshRate(lNewValue);
			}
			 
			msSelectedDisplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDisplayButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Min update rate
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Engine", "AllowSlowdowns", false);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDisplayButtonPos, mlCurrentItemId, msSelectedDisplayButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if (bValue != bNewValue)
			{
				mpConfig.SetBool("Engine", "AllowSlowdowns", bNewValue);
				mlOptionChanges++;
			}
			 
			msSelectedDisplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDisplayButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// FOV
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			float fFOVMin = 50;
			float fFOVMax = 83;
			float fValue = mpConfig.GetFloat("Gameplay", "FOV", 70);

			float fAspectRatio = mpConfig.GetFloat("Screen", "Width", 1920) / mpConfig.GetFloat("Screen", "Height", 1080);
			float fHorizontalFov = 2.0f * cMath_ATan(cMath_Tan(cMath_ToRad(fValue) / 2.0f) * fAspectRatio);
			tString sTextValue = "" + cMath_RoundToInt(cMath_ToDeg(fHorizontalFov));

			fValue = (fValue - fFOVMin) / (fFOVMax - fFOVMin);
			float fNewValue = OptionMenu_ButtonOptionsSlider(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDisplayButtonPos, mlCurrentItemId, msSelectedDisplayButton, fValue, 0.2f / 4.0f, mlActionHorizontal, sTextValue, "", vRightAnchor, vInfoBoxPos, mfTransitionAlpha, false, true, true);
			
			if(fValue != fNewValue)
			{
				mlOptionChanges++;
				fNewValue = fNewValue * (fFOVMax - fFOVMin) + fFOVMin;
				mpConfig.SetFloat("Gameplay", "FOV", fNewValue);
			}

			msSelectedDisplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDisplayButton);
		}
		if (cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false)
			mlCurrentItemId++;
		
		/////////////////
		// Back
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			bool bButton = MainMenu_DoBackButton(msSelectedDisplayButton, mfTransitionAlpha); 
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				if(mlOptionChanges > 0)
				{
					// Changes has been made
					mbShowApplyChanges = true;
					msFocusNextFrame = "No";
				}
				else
				{
					mlFirstItemId = 0;
					mlLastInFocus = 0;
				
					// No changes
					mTargetGroup = eMainMenuGroup_Options;
					msTargetFocus = msSelectedOptionsButton;
					
					if (ImGui_TimerExists("TransitionOut") == false)
						ImGui_AddTimer("TransitionOut", 10);
				}
				
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				mlLastInFocusRel = 0;
				mbScrolled = false;
				mbScrollDown = false;
				mbScrollUp = false;

				//////////
				// Reset menu poos
				if(bGamepad == false)
				{
					OptionMenu_ShowGamepadButtons(true);
					return;
				}
			}

			msSelectedDisplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDisplayButton);
		}
		else
		{
			bool bBack = ImGui_ActionTriggered(eImGuiAction_Cancel, true);
			if (bBack)
			{
				
				if(mlOptionChanges > 0)
				{
					// Changes has been made
					mbShowApplyChanges = true;
					msFocusNextFrame = "No";
				}
				else
				{
					// No changes
					mTargetGroup = eMainMenuGroup_Options;
					msTargetFocus = msSelectedOptionsButton;
					
					if (ImGui_TimerExists("TransitionOut") == false)
						ImGui_AddTimer("TransitionOut", 10);
				}
				
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				mlLastInFocusRel = 0;
				mbScrolled = false;
				mbScrollDown = false;
				mbScrollUp = false;
			}
		}
		
		if (mbShowApplyChanges == false)
			GuiHandleTransition(mTargetGroup, msTargetFocus);

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
	}
	
	//------------------------------------------------------- 
	
	void GuiOptionsGraphics()
	{
		GuiPauseDarkOverlay();
		
		array<tString> vMenuItems = {"AutoDetect","AA", "TextureQuality", "TextureFiltering",/*"TextureStreaming",*/ "ShadowQuality", "DirShadowQuality", "LanternShadows", "Reflection", "Refraction", "SkinShading", "TerrainQuality","SoftParticles", "ParticleQuality", "DepthOfField", "FilmGrain", "SSAO", "Bloom"};
		array<tString> vTextureValues = { "High", "Medium", "Low" };
		array<tString> vParticleValues = { "High", "Medium", "Low" };
		array<tString> vTextureFilterValues = { "Bilinear", "Trilinear", "Anis2x", "Anis4x", "Anis8x", "Anis16x" };
		array<tString> vShadowValues = { "Off", "Low", "Medium", "High", "VeryHigh" };
		array<tString> vDirShadowValues = { "Low", "Medium", "High", "VeryHigh" };
		array<tString> vReflectionValues = { "Off", "Static", "Dynamic" };
		array<tString> vAAValues = { "Off", "FXAA" };
		array<tString> vDOFValues = {"Low", "Medium", "High"};
		
		if (cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false)
			vMenuItems.push_back("Back");
				
		for (int i=0; i<=vMenuItems.length()-1; i++)
		{
			if(vMenuItems[i] == "AutoDetect")
				continue;

			OptionMenu_UpdateButtonWidth(vMenuItems[i]);
		}
		
		OptionMenu_UpdateToggleExtraWidth();
		OptionMenu_UpdateMultiSelectionExtraWidth(vParticleValues);
		OptionMenu_UpdateMultiSelectionExtraWidth(vTextureValues);
		OptionMenu_UpdateMultiSelectionExtraWidth(vTextureFilterValues);
		OptionMenu_UpdateMultiSelectionExtraWidth(vShadowValues);
		OptionMenu_UpdateMultiSelectionExtraWidth(vDirShadowValues);
		OptionMenu_UpdateMultiSelectionExtraWidth(vReflectionValues);
		OptionMenu_UpdateMultiSelectionExtraWidth(vAAValues);
		OptionMenu_UpdateMultiSelectionExtraWidth(vDOFValues);
		OptionMenu_AlignExtraButtonWidth();
		
		cVector2f vGraphicsMenuPos = kOptionsGraphicsBgPos;
		cVector2f vGraphicsMenuButtonPos = kOptionsGraphicsButtonPos;
		cVector2f vGraphicsMenuSize = kOptionsGraphicsBgSize+cVector2f(gfOptionsMenu_ExtraWidth+gfOptionsMenu_ExtraWidth_MultiSelect, 10);
		cVector2f vRightAnchor = cVector2f(vGraphicsMenuPos.x+vGraphicsMenuSize.x-40,0);
		cVector3f vInfoBoxPos = OptionMenu_GetTopLeftOffset(cVector2f(vGraphicsMenuPos.x+vGraphicsMenuSize.x-30,0),0);
		
		DoBackground(vRightAnchor.x + 100);
		
		////////////////
		// Title
		OptionMenu_SectionTitle("Options_Graphics", kOptionsGraphicsBgPos + cVector2f(40,-40), 1.f, mfTransitionAlpha);
		
		mlOptionItemId = 0;
		
		mlCurrentItemId = mlFirstItemId;
		
		/////////////////////////
		// Handles dynamic scrolling
		OptionMenu_SetOutOfLimit(vMenuItems.length());
		
		cVector2f vItemSpacing = cVector2f(0,-3);
		
		/////////////////
		// Auto Detect
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			if (OptionMenu_ButtonOptions(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, true, vRightAnchor, vInfoBoxPos, mfTransitionAlpha))
			{
				/////////////
				// Show detect settings popup
				mbShowDetectSettings = true;
				msFocusNextFrame = "No";
				msMessageBoxFocus = "No";
				mlCurrentOptionChange = mlOptionChanges; //keep track of number of changes that have been made, determines if "Apply Changes" window should show
			}
			
			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;
		/////////////////
		// AA
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			/////////////
			// Draw multi select box and update config
			tString sValue = mpConfig.GetString("Graphics", "AntiAliasing", "FXAA");

			int lValue = (sValue == "FXAA") ? 1 : 0;
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, vAAValues, lValue, true, mlActionHorizontal, "Menu" ,0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(lValue != lNewValue)
			{
				mlOptionChanges++;
				mpConfig.SetString("Graphics", "AntiAliasing", vAAValues[lNewValue]);
			}
		
			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Textures
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			/////////////
			// Draw multi select box and update config
			int lValue = mpConfig.GetInt("Graphics", "TextureQuality", 0);
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, vTextureValues, lValue, true, mlActionHorizontal, "Menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(lValue != lNewValue)
			{
				mpConfig.SetInt("Graphics", "TextureQuality", lNewValue);
				mlOptionChanges++;
			}

			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;

		/////////////////
		// Textures Filtering
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			/////////////
			// Draw multi select box and update config
			int lFilter = mpConfig.GetInt("Graphics", "TextureFilter", 0);
			int lAnis = mpConfig.GetInt("Graphics", "TextureAnisotropy", 0);

			int lValue = 0;

			if(lAnis < 2)
			{
				lValue = lFilter == 2 ? 1 : 0;
			}
			else
			{
				if(lAnis == 2)		lValue = 2;
				else if(lAnis == 4) lValue = 3;
				else if(lAnis == 8) lValue = 4;
				else				lValue = 5;
			}

			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, vTextureFilterValues, lValue, false, mlActionHorizontal, "Menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(lValue != lNewValue)
			{
				switch(lNewValue)
				{
				case 0:
					lAnis = 1;
					lFilter = 1;
					break;
				case 1:
					lAnis = 1;
					lFilter = 2;
					break;
				case 2:
					lAnis = 2;
					lFilter = 2;
					break;
				case 3:
					lAnis = 4;
					lFilter = 2;
					break;
				case 4:
					lAnis = 8;
					lFilter = 2;
					break;
				case 5:
					lAnis = 16;
					lFilter = 2;
					break;
				}

				mpConfig.SetInt("Graphics", "TextureFilter", lFilter);
				mpConfig.SetInt("Graphics", "TextureAnisotropy", lAnis);
				mlOptionChanges++;
			}

			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;
/*
		/////////////////
		// Texture streaming
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			/////////////
			// Draw multi select and update config
			bool bValue = mpConfig.GetBool("MapStreaming", "UseTextureMapStreaming", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
				
			if (bValue != bNewValue)
			{
				mpConfig.SetBool("MapStreaming", "UseTextureMapStreaming", bNewValue);
				mlOptionChanges++;
			}
			
			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;
*/		
		/////////////////
		// Shadows
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			/////////////
			// Draw multi select and update config
			int lShadowQuality = mpConfig.GetInt("Graphics", "ShadowResolution", 2)+1;
			int lValue = lShadowQuality;
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, vShadowValues, lValue, false, mlActionHorizontal, "Menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);

			if(lValue != lNewValue)
			{	
				mpConfig.SetBool("Graphics", "BodyShadows", lNewValue > 2);
				mpConfig.SetBool("Graphics", "ShadowsActive", lNewValue != 0);
				mpConfig.SetInt("Graphics", "ShadowResolution", lNewValue-1);
				mlOptionChanges++;
			}

			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Dir Light Shadows
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			/////////////
			// Draw multi select and update config
			int lShadowQuality = mpConfig.GetInt("Graphics", "DirLightSliceNum", 4);
			int lValue = lShadowQuality-1;
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, vShadowValues, lValue, false, mlActionHorizontal, "Menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
				
			if(lValue != lNewValue)
			{	
				mpConfig.SetInt("Graphics", "DirLightSliceNum", lNewValue + 1);
				mlOptionChanges++;
			}

			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;

		/////////////////
		// Lantern shadows
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			/////////////
			// Draw multi select and update config
			bool bValue = mpConfig.GetBool("Graphics", "LanternShadowsActive", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
				
			if (bValue != bNewValue)
			{
				mpConfig.SetBool("Graphics", "LanternShadowsActive", bNewValue);
				mlOptionChanges++;
			}
			
			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Reflection
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bWorldReflections = mpConfig.GetBool("Graphics", "WorldReflection", true);
			bool bIrradianceSpecular = mpConfig.GetBool("Graphics", "IrradianceSpecular", true);

			int lValue = (bWorldReflections ? 1 : 0) + (bIrradianceSpecular ? 1 : 0);
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, vReflectionValues, lValue, false, mlActionHorizontal, "Menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
				
			if(lValue != lNewValue)
			{
				mpConfig.SetBool("Graphics", "WorldReflection", lNewValue >= 2);
				mpConfig.SetBool("Graphics", "IrradianceSpecular", lNewValue >= 1);
				mlOptionChanges++;
			}

			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;

		/////////////////
		// Refraction
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Graphics", "Refraction", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Graphics", "Refraction", bNewValue);
				mlOptionChanges++;
			}
			
			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Skin Shading
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Graphics", "SkinShadingActive", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Graphics", "SkinShadingActive", bNewValue);
				mlOptionChanges++;
			}
			
			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Tesselation
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			/////////////
			// Draw multi select and update config
			array<tString> vValues = { "Low", "Medium", "High", "VeryHigh" };
			int lValue = mpConfig.GetInt("Graphics", "TerrainQuality", 0);
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, vValues, lValue, false, mlActionHorizontal, "Menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
					
			if(lValue != lNewValue)
			{	
				mpConfig.SetInt("Graphics", "TerrainQuality", lNewValue);
				mpConfig.SetInt("Graphics", "TerrainTessellation", lNewValue);
				mlOptionChanges++;
			}

			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// SoftParticles
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Graphics", "SoftParticles", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Graphics", "SoftParticles", bNewValue);
				mlOptionChanges++;
			}
			
			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;

		/////////////////
		// Particle Quality
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			/////////////
			// Draw multi select and update config
			array<tString> vValues = { "Low", "Medium", "High"};
			int lValue = mpConfig.GetInt("Graphics", "ParticleQuality", 1);
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, vValues, lValue, false, mlActionHorizontal, "Menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
					
			if(lValue != lNewValue)
			{	
				mpConfig.SetInt("Graphics", "ParticleQuality", lNewValue);
				mlOptionChanges++;
			}

			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;

		/////////////////
		// DOF
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			/////////////
			// Draw multi select box and update config
			int lValue = mpConfig.GetInt("Graphics", "DepthOfFieldQuality", 2);
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, vDOFValues, lValue, false, mlActionHorizontal, "Menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(lValue != lNewValue)
			{
				mpConfig.SetInt("Graphics", "DepthOfFieldQuality", lNewValue);
				mlOptionChanges++;
			}

			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;
		

		/////////////////
		// Film Grain
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Graphics", "FilmGrainActive", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Graphics", "FilmGrainActive", bNewValue);
				mlOptionChanges++;
			}
			
			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;

		/////////////////
		// SSAO
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Graphics", "SSAOActive", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Graphics", "SSAOActive", bNewValue);
				mlOptionChanges++;
			}
			
			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;

		/////////////////
		// Bloom
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Graphics", "BloomActive", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Graphics", "BloomActive", bNewValue);
				mlOptionChanges++;
			}
			
			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		if (cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false)
			mlCurrentItemId++;
		
		/////////////////
		// Back
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			bool bButton = MainMenu_DoBackButton(msSelectedGraphicsButton, mfTransitionAlpha);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{

				// No changes
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				mlLastInFocusRel = 0;
				mbScrolled = false;
				mbScrollDown = false;
				mbScrollUp = false;
				
				if(mlOptionChanges > 0)
				{
					// Changes has been made
					mbShowApplyChanges = true;
					msFocusNextFrame = "No";
				}
				else
				{
					mlFirstItemId = 0;
					mlLastInFocus = 0;
				
					// No changes
					mTargetGroup = eMainMenuGroup_Options;
					msTargetFocus = msSelectedOptionsButton;
					
					if (ImGui_TimerExists("TransitionOut") == false)
						ImGui_AddTimer("TransitionOut", 10);
					
				}
				
				///////////////////////
				// Reset menu pos
				if(bGamepad == false)
				{
					OptionMenu_ShowGamepadButtons(true);
					return;
				}
			}

			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		else
		{
			bool bBack = ImGui_ActionTriggered(eImGuiAction_Cancel, true);
			if (bBack)
			{
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				mlLastInFocusRel = 0;
				mbScrolled = false;
				mbScrollDown = false;
				mbScrollUp = false;
				
				if(mlOptionChanges > 0)
				{
					// Changes has been made
					mbShowApplyChanges = true;
					msFocusNextFrame = "No";
				}
				else
				{
					// No changes
					mlFirstItemId = 0;
					mlLastInFocus = 0;
					mTargetGroup = eMainMenuGroup_Options;
					msTargetFocus = msSelectedOptionsButton;
					
					//if (ImGui_TimerExists("TransitionOut") == false)
					//	ImGui_AddTimer("TransitionOut", 10);
				}
			}
		}

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
		
		if (mbShowDetectSettings == false && mbShowApplyChanges == false)
			GuiHandleTransition(mTargetGroup, msTargetFocus);
		
	}
	
	//------------------------------------------------------

	void GuiOptionsAudio()
	{
		GuiPauseDarkOverlay();
		
		////////////////////////////////////
		// Options background
		
		array<tString> vMenuItemsPC = {"Volume", "Subtitles", "SubtitleOptions"};
		array<tString> vMenuItemsPS4 = {"SpeakerType", "Volume", "Subtitles", "SubtitleOptions"}; 
		array<tString> vMenuItems = Platform_IsConsole() ? vMenuItemsPS4 : vMenuItemsPC;
		array<tString> vSpeakerValuesPS4 = {"SmallTV", "MediumTV", "HomeCinema", "Headphones", "NightMode"};
		array<tString> vSpeakerValuesXbox = {"SmallTV", "MediumTV", "HomeCinema", "Headphones", "NightMode"};
		array<tString> vSpeakerValues = Platform_IsPlayStation() ? vSpeakerValuesPS4 : vSpeakerValuesXbox;
		
		if (cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false)
			vMenuItems.push_back("Back");
		
		for (int i=0; i<=vMenuItems.length()-1; i++)
		{
			if(vMenuItems[i] == "SubtitleOptions")
				continue;

			OptionMenu_UpdateButtonWidth(vMenuItems[i]);
		}
				
		OptionMenu_UpdateToggleExtraWidth();

		cVector2f vBGSize = kOptionsAudioBgSize;
		if(Platform_IsConsole())
		{
			OptionMenu_UpdateExtraButtonWidth_MultiSelection(vSpeakerValues);
		
			vBGSize = kOptionsAudioBgSizePS4;
		}
		OptionMenu_AlignExtraButtonWidth();

		////////////////////////////////////
		// Options background
		cVector2f vAudioMenuPos = kOptionsAudioBgPos;
		cVector2f vAudioMenuSize = vBGSize+cVector2f(gfOptionsMenu_ExtraWidth+gfOptionsMenu_ExtraWidth_MultiSelect,0);
		cVector3f vInfoBoxPos = OptionMenu_GetTopLeftOffset(cVector2f(vAudioMenuPos.x+vAudioMenuSize.x-40,0),0);
		cVector2f vRightAnchor = cVector2f(vAudioMenuPos.x+vAudioMenuSize.x-40,0);
		
		DoBackground(vRightAnchor.x + 100);
		
		////////////////
		// Audio
		OptionMenu_SectionTitle("Audio", kOptionsAudioBgPos + cVector2f(40,-40), 1.f, mfTransitionAlpha);
		
		mlCurrentItemId = mlFirstItemId;
		
		/////////////////////////
		// Handles dynamic scrolling
		OptionMenu_SetOutOfLimit(vMenuItems.length());

		/////////////////
		// Speaker type
		if(Platform_IsConsole())
		{
			if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
			{
				/////////////
				// Draw multi select box and update config
				tString sValue = mpConfig.GetString("Sound", "SpeakerType", "HomeCinema");
				int lValue =-1;
				for(int i=0;i<vSpeakerValues.size(); ++i)
				{
					if(sValue == vSpeakerValues[i]){
						lValue = i;
						break;
					}
				}
				
				int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsAudioButtonPos, mlCurrentItemId, msSelectedAudioButton, vSpeakerValues, lValue, false, mlActionHorizontal, "Menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
				if(lValue != lNewValue)
				{
					mpConfig.SetString("Sound", "SpeakerType", vSpeakerValues[lNewValue]);
					ApplySettings(false);
				}

				msSelectedAudioButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedAudioButton);
			}
			mlCurrentItemId++;
		}
		/////////////////
		// Volume
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			float fValue = mpConfig.GetFloat("Sound", "Volume", 1.0f);
			float fNewValue = OptionMenu_ButtonOptionsSlider(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsAudioButtonPos, mlCurrentItemId, msSelectedAudioButton, fValue, 0.05f, mlActionHorizontal, "", "", vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(fNewValue != fValue)
			{
				mpConfig.SetFloat("Sound", "Volume", fNewValue);
				ApplySettings(false);
			}

			msSelectedAudioButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedAudioButton);
		}
		mlCurrentItemId++;
		/////////////////
		// SUBTITLES
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Sound", "ShowSubtitles", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsAudioButtonPos, mlCurrentItemId, msSelectedAudioButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Sound", "ShowSubtitles", bNewValue);
			}
			
			msSelectedAudioButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedAudioButton);
		}
		mlCurrentItemId++;
		
		/////////////////////
		// SUBTITLE OPTIONS
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			if(OptionMenu_ButtonOptions(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsAudioButtonPos, mlCurrentItemId, msSelectedAudioButton, true, vRightAnchor, vInfoBoxPos, mfTransitionAlpha))
			{
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				mPrevGroup = eMainMenuGroup_Options_Audio;
				mTargetGroup = eMainMenuGroup_Options_Audio_Subtitles;
				msTargetFocus = msSelectedSubtitlesButton;
			}
			msSelectedAudioButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedAudioButton);
		}
		if (cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false)
			mlCurrentItemId++;
			
		/////////////////
		// Back
		{
			bool bButton = MainMenu_DoBackButton(msSelectedAudioButton, mfTransitionAlpha);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				ApplySettings();
				
				if (ImGui_TimerExists("TransitionOut") == false)
						ImGui_AddTimer("TransitionOut", 10);
				
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				mTargetGroup = eMainMenuGroup_Options;
				msTargetFocus = msSelectedOptionsButton;

				/////////
				// Reset menu position
				if(bGamepad == false)
				{
					OptionMenu_ShowGamepadButtons(true);
					return;
				}
			}
			
			tString sID = cLux_GetInputHandler().GetGamepadWasLastDeviceUsed() ? vMenuItems[mlCurrentItemId] : "Back";
			msSelectedAudioButton = OptionMenu_UpdateFocus(sID, msSelectedAudioButton);
		}
		
		GuiHandleTransition(mTargetGroup, msTargetFocus);

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
	}
	
	//-------------------------------------------------------
	
	int GetCurrentResolution()
	{
		cVector2l vResolution = cVector2l(mpConfig.GetInt("Screen", "Width", 1280), 
									      mpConfig.GetInt("Screen", "Height", 720));

		if(vResolution.x == -1 || vResolution.y == -1)
		{
			vResolution.x = cGraphics_GetLowLevel().GetScreenSizeInt().x;
			vResolution.y = cGraphics_GetLowLevel().GetScreenSizeInt().y;
		}

		for(int i = 0; i < mvResolutionSizes.size(); ++i)
		{
			if(vResolution == mvResolutionSizes[i])
			{
				return i;
			}
		} 

		////////////
		// Custom resolution
		mvResolutionSizes.push_back(vResolution);
		mvResolutionValues.push_back(""+vResolution.x + "x"+vResolution.y);

		return mvResolutionValues.size()-1;
	}
	
	//-------------------------------------------------------
	
	cVector2l GetScreenRatio()
	{
		const cVector2l vResolution = cVector2l(mpConfig.GetInt("Screen", "Width", 1280), mpConfig.GetInt("Screen", "Height", 720));
		return GetScreenRatio(vResolution.x, vResolution.y);
	}
	
	//-------------------------------------------------------
	
	cVector2l GetScreenRatio(int alScreenWidth, int alScreenHeight)
	{
		int lGreatestCommonDiv = 1;
		for (int i = 1; i <= alScreenWidth && i <= alScreenHeight; i++)
		{
			if (alScreenWidth % i == 0 && alScreenHeight % i == 0)
			{
				lGreatestCommonDiv = i;
			}
		}
		
		int lAspectWidth = alScreenWidth / lGreatestCommonDiv;
		int lAspectHeight = alScreenHeight / lGreatestCommonDiv;
		
		return cVector2l(lAspectWidth, lAspectHeight);
	}
	
	//-------------------------------------------------------

	void SetCurrentResolution(int aID)
	{
		aID = (aID + mvResolutionSizes.size()) % mvResolutionSizes.size();

		mpConfig.SetInt("Screen", "Width", mvResolutionSizes[aID].x);
		mpConfig.SetInt("Screen", "Height", mvResolutionSizes[aID].y);
	}
	
	//-------------------------------------------------------
	
	int GetCurrentRefreshRate()
	{
		int lRate = mpConfig.GetInt("Screen", "RefreshRate", 0);

		if(lRate == 0)
		{
			lRate = mvRefresh[mvRefresh.size()-1];
		}

		for(int i = 0; i < mvRefresh.size(); ++i)
		{
			if(lRate == mvRefresh[i])
			{
				return i;
			}
		} 

		////////////
		// Custom resolution
		mvRefresh.push_back(lRate);
		mvRefreshValues.push_back(""+lRate);

		return mvRefreshValues.size()-1;
	}
	
	//-------------------------------------------------------

	void SetCurrentRefreshRate(int aID)
	{
		aID = (aID + mvRefresh.size()) % mvRefresh.size();

		mpConfig.SetInt("Screen", "RefreshRate", mvRefresh[aID]);
		mpConfig.SetInt("Engine", "GameplayUpdateRate", cMath_Max(mvRefresh[aID], 30));
	}

	//------------------------------------------------------
	
	int GetBaseQualityAMD(tString asPrefix, int alCardNumber)
	{
		if(asPrefix == "HD")
		{
			if(alCardNumber < 6600) return 0;
			if(alCardNumber < 7600) return 1;
			if(alCardNumber < 8600) return 2;
			if(alCardNumber < 9600) return 2;
		}
		else if(asPrefix == "R5")
		{
			return 0;
		}
		else if(asPrefix == "R7")
		{
			return 2;
		}
		else if(asPrefix == "R9")
		{
			return 3;
		}
		else if(asPrefix == "RX")
		{
			if(alCardNumber < 450) return 1;
			if(alCardNumber < 460) return 2;
			if(alCardNumber < 500) return 3;
			if(alCardNumber < 550) return 2;
			if(alCardNumber < 560) return 3;
			if(alCardNumber < 600) return 4;
			if(alCardNumber < 6000) return 4;

			return 4;
		}

		return -1;
	} 

	int GetBaseQualityNvidia(int alCardNumber)
	{
		if(alCardNumber < 100 || alCardNumber > 6000) return -1;

		if(alCardNumber < 450) return 0;
		if(alCardNumber < 550) return 1;
		if(alCardNumber < 650) return 2;
		if(alCardNumber < 750) return 3;
		if(alCardNumber < 6000) return 4;

		return -1;
	}
	
	int GetBaseQualityIntel(tString asPrefix, int alCardNumber)
	{
		if(asPrefix == "UHD")
		{
			if(alCardNumber < 620) return 0;
			if(alCardNumber < 630) return 1;
			if(alCardNumber < 700) return 2;
		}
		else if(asPrefix == "Iris" || asPrefix == "Plus")
		{
			return 2;
		}
		else if(asPrefix == "Xe")
		{
			return 2;
		}

		return -1;
	} 

	void GetQualityAndMemoryFromRenderer(int&out alQuality, int&out alVRAM, bool&out abDynamicResolution)
	{
		/////////////
		// Get and parse graphics info
		tString sGraphicsInfo = cGraphics_GetLowLevel().GetGraphicsInfo();
		Log("GraphicsInfo: " + sGraphicsInfo + "\n");
		array<tString> vInfo;
		cString_GetStringVec(sGraphicsInfo, vInfo, ";");

		alQuality = -1;
		alVRAM = -1;
		abDynamicResolution = false;

		if(vInfo.size() >= 5)
		{
			/////////////////
			// Parse vram
			array<tString> vVRAM;
			cString_GetStringVec(vInfo[4], vVRAM, " ");
			
			if(vVRAM.size() == 3)
			{
				alVRAM = cString_ToInt(vVRAM[1], -1);
			}
			else
			{
				// VRAM Parse failed, no need to continue
				return;
			}
					
			///////////////////
			// Get info about card
			array<tString> vCardName;
			cString_GetStringVec(vInfo[1], vCardName, " ,/\\");
			tString sModelPrefix;
			int lVersion = 0;
			bool bLaptop = false;

			for(uint i = 0; i < vCardName.size(); ++i)
			{
				//////////////
				// Check for mobile GPU
				int lPos = cString_GetFirstCharPos(vCardName[i], 'M');

				if(lPos == -1)
				{
					//////////////
					// Normal gpu
					lVersion = cString_ToInt(vCardName[i], 0);
				}
				else
				{
					//////////////
					// Check if its at the start or end
					if(lPos == 0)
					{
						lVersion = cString_ToInt(cString_Sub(vCardName[i], 1), 0);
						
						if(lVersion != 0) bLaptop = true;
					}
					else if(lPos == vCardName[i].length() - 1)
					{
						lVersion = cString_ToInt(cString_Sub(vCardName[i], 0, lPos), 0);

						if(lVersion != 0) bLaptop = true;
					}
				}

				if(lVersion != 0) break;

				sModelPrefix = vCardName[i];
			}

			Log("Card: " + vInfo[0] + " Model: " + sModelPrefix + " Version: " + lVersion + "\n");


			//////////////
			// Convert card to quality setting
			if(cString_GetFirstStringPos(vInfo[0], "NVIDIA") != -1)
			{
				alQuality = GetBaseQualityNvidia(lVersion);
			}
			else if(cString_GetFirstStringPos(vInfo[0], "AMD") != -1 || 
					cString_GetFirstStringPos(vInfo[0], "ATI") != -1 || 
					cString_GetFirstStringPos(vInfo[0], "Radeon") != -1)
			{
				alQuality = GetBaseQualityAMD(sModelPrefix, lVersion);
			}
			else if(cString_GetFirstStringPos(vInfo[0], "Intel") != -1)
			{
				// Special case for intel cards
				alQuality = GetBaseQualityIntel(sModelPrefix, lVersion);
				alVRAM = 1024;
				abDynamicResolution = true;
			}

			//////////////
			// Downgrade quality one level for laptops
			if(bLaptop)
			{
				if(alQuality >= 0)
					alQuality = cMath_Max(alQuality - 1, 0);
				abDynamicResolution = true;
			}

			//////////////
			// In case vram fails, set to max
			if(alVRAM == 0) alVRAM = 2048;
		}
	}
		
	void AutoDetectSettings(bool abSkipOnHigh)
	{
		if(Platform_IsConsole()) return;

		/////////////////////
		// Parse string to get quality and vram;
		int lBaseQuality;
		int lVRAM;
		bool bDynamicResolution;
		GetQualityAndMemoryFromRenderer(lBaseQuality, lVRAM, bDynamicResolution);
		
		/////////////////
		// Get qúality based on vram and GPU card
		eGraphicSettings setting = eGraphicSettings_High;

		if(lVRAM > 0) //valid VRAM?
		{
			switch(lBaseQuality)
			{
			case 0:
				if(lVRAM < 1024)		setting = eGraphicSettings_Low;
				else if(lVRAM < 2048)	setting = eGraphicSettings_Low;
				else					setting = eGraphicSettings_Medium;
				break;
			case 1:
				if(lVRAM <= 1024)		setting = eGraphicSettings_Low;
				else if(lVRAM < 2048)	setting = eGraphicSettings_Medium;
				else					setting = eGraphicSettings_Medium;
				break;
			case 2:
				if(lVRAM <= 512)		setting = eGraphicSettings_Low;
				else if(lVRAM < 1024)	setting = eGraphicSettings_Medium;
				else if(lVRAM < 2048)	setting = eGraphicSettings_Medium;
				else					setting = eGraphicSettings_High;
				break;
			case 3:
				if(lVRAM < 512)			setting = eGraphicSettings_Low;
				else if(lVRAM < 1024)	setting = eGraphicSettings_Medium;
				else if(lVRAM < 2048)	setting = eGraphicSettings_High;
				else					setting = eGraphicSettings_High;
				break;
			case 4:
				if(lVRAM < 512)			setting = eGraphicSettings_Low;
				else if(lVRAM < 1024)	setting = eGraphicSettings_Medium;
				else if(lVRAM < 2048)	setting = eGraphicSettings_High;
				else					setting = eGraphicSettings_High;
				break;
			default:
				setting = eGraphicSettings_High; //Set to high if unsure
				break;
			}
		}

		tString sQuality;
		if(setting == eGraphicSettings_Low)		sQuality = "Low";
		if(setting == eGraphicSettings_Medium)	sQuality = "Medium";
		if(setting == eGraphicSettings_High)	sQuality = "High";
		
		Log("AutoDetect Quality: " +  sQuality + "; Base "+ lBaseQuality + "; VRAM " + lVRAM + " mb\n");

		////////////////////
		// Update config based on quality selected
		switch(setting)
		{
		case eGraphicSettings_High:
			//if(abSkipOnHigh) return;

			mpConfig.SetString("Graphics", "AntiAliasing", "FXAA");
			mpConfig.SetInt("Graphics", "TextureFilter", 2);
			mpConfig.SetInt("Graphics", "TextureAnisotropy", 16);
			mpConfig.SetInt("Graphics", "ShadowResolution", lBaseQuality >= 4 ? 3 : 2);
			mpConfig.SetBool("Graphics", "WorldReflection", true);
			mpConfig.SetBool("Graphics", "IrradianceSpecular", true);
			mpConfig.SetBool("Graphics", "Refraction", true);
			mpConfig.SetInt("Graphics", "DepthOfFieldQuality", 2);
			mpConfig.SetBool("Graphics", "LanternShadowsActive", true);
			mpConfig.SetInt("Graphics", "DirLightSliceNum", 4);
			mpConfig.SetBool("Graphics", "SSAOActive", true);
			mpConfig.SetBool("Graphics", "BloomActive", true);
			mpConfig.SetBool("Engine", "AllowSlowdowns", false);
			if(mpConfig.GetInt("Screen", "RefreshRate", 0) == 30) mpConfig.SetInt("Screen", "RefreshRate", 60);
			if(lBaseQuality >= 4) mpConfig.SetString("Screen", "Vsync", "true");
			else				  mpConfig.SetString("Screen", "Vsync", "adaptive");
			mpConfig.SetBool("Screen", "DynamicResolution", bDynamicResolution);
			mpConfig.SetBool("Graphics", "FilmGrainActive", true);
			mpConfig.SetBool("Graphics", "SkinShadingActive", true);
			mpConfig.SetInt("Graphics", "TerrainTessellation", cMath_Min(lBaseQuality, 3));
			mpConfig.SetBool("Graphics", "SoftParticles", true);
			mpConfig.SetInt("Graphics", "ParticleQuality", 2);
			break;
		case eGraphicSettings_Medium:
			mpConfig.SetString("Graphics", "AntiAliasing", "Off");
			mpConfig.SetInt("Graphics", "TextureFilter", 2);
			mpConfig.SetInt("Graphics", "TextureAnisotropy", 2);
			mpConfig.SetInt("Graphics", "ShadowResolution", 1);
			mpConfig.SetInt("Graphics", "DirLightSliceNum", 3);
			mpConfig.SetBool("Graphics", "LanternShadowsActive", false);
			mpConfig.SetBool("Graphics", "WorldReflection", false);
			mpConfig.SetBool("Graphics", "IrradianceSpecular", true);
			mpConfig.SetBool("Graphics", "Refraction", true);
			mpConfig.SetInt("Graphics", "DepthOfFieldQuality", 1);
			mpConfig.SetBool("Graphics", "SSAOActive", true);
			mpConfig.SetBool("Graphics", "BloomActive", true);
			mpConfig.SetBool("Engine", "AllowSlowdowns", false);
			if(mpConfig.GetInt("Screen", "RefreshRate", 0) == 30) mpConfig.SetInt("Screen", "RefreshRate", 60);
			mpConfig.SetString("Screen", "Vsync", "adaptive");
			mpConfig.SetBool("Screen", "DynamicResolution", bDynamicResolution);
			mpConfig.SetBool("Graphics", "FilmGrainActive", false);
			mpConfig.SetBool("Graphics", "SkinShadingActive", false);
			mpConfig.SetInt("Graphics", "TerrainTessellation", 0);
			mpConfig.SetBool("Graphics", "SoftParticles", false);
			mpConfig.SetInt("Graphics", "ParticleQuality", 1);
			break;
		case eGraphicSettings_Low:
			mpConfig.SetString("Graphics", "AntiAliasing", "Off");
			mpConfig.SetInt("Graphics", "TextureFilter", 2);
			mpConfig.SetInt("Graphics", "TextureAnisotropy", 0);
			mpConfig.SetInt("Graphics", "ShadowResolution", 0);
			mpConfig.SetInt("Graphics", "DirLightSliceNum", 1);
			mpConfig.SetBool("Graphics", "LanternShadowsActive", false);
			mpConfig.SetBool("Graphics", "WorldReflection", false);
			mpConfig.SetBool("Graphics", "IrradianceSpecular", false);
			mpConfig.SetBool("Graphics", "Refraction", false);
			mpConfig.SetInt("Graphics", "DepthOfFieldQuality", 0);
			mpConfig.SetBool("Graphics", "SSAOActive", false);
			mpConfig.SetBool("Graphics", "BloomActive", false);
			mpConfig.SetInt("Screen", "RefreshRate", 30);
			mpConfig.SetBool("Engine", "AllowSlowdowns", true);
			mpConfig.SetBool("Screen", "DynamicResolution", bDynamicResolution);
			mpConfig.SetString("Screen", "Vsync", "adaptive");
			mpConfig.SetBool("Graphics", "FilmGrainActive", false);
			mpConfig.SetBool("Graphics", "SkinShadingActive", false);
			mpConfig.SetInt("Graphics", "TerrainTessellation", 0);
			mpConfig.SetBool("Graphics", "SoftParticles", false);
			mpConfig.SetInt("Graphics", "ParticleQuality", 0);
			break;
		}

		// Update body shadows shadow
		mpConfig.SetBool("Graphics", "BodyShadows", mpConfig.GetInt("Graphics", "ShadowResolution", 2) > 1);

		//////////////////
		// Update texture quality based on just the VRAM
		if(lVRAM > 0) //valid VRAM?
		{
			if(lVRAM >= 3500)
			{
				mpConfig.SetInt("Graphics", "TextureQuality", 0); //high
				mpConfig.SetInt("Graphics", "TerrainQuality", 3);
			}
			else if(lVRAM >= 1500)
			{
				mpConfig.SetInt("Graphics", "TextureQuality", 1); //medium
				mpConfig.SetInt("Graphics", "TerrainQuality", 2);
			}
			else
			{
				mpConfig.SetInt("Graphics", "TextureQuality", 2); //low
				mpConfig.SetInt("Graphics", "TerrainQuality", 0);
			}
		}

		///////////////
		// Apply config
		ApplySettings(true);
	}
	
	//------------------------------------------------------

	void GuiOptionsSubtitles()
	{
		GuiPauseDarkOverlay();
		
		array<tString> vMenuItems = {"Subtitles", "HearingAid", "SubtitleDirectionalIndicators", "AnimateSubtitles", "FadeSubtitlesOverDistance", "SubtitleSize", "SubtitleBGOpacity"};
		array<tString> vSubtitleSizeValues = {"Small", "Default", "Large", "VeryLarge"};
		
		if (cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false)
			vMenuItems.push_back("Back");
		
		for (int i=0; i<=vMenuItems.length()-1; i++)
		{
			OptionMenu_UpdateButtonWidth(vMenuItems[i], 450.f);
		}
		OptionMenu_UpdateToggleExtraWidth();
		OptionMenu_UpdateMultiSelectionExtraWidth(vSubtitleSizeValues, "Menu", gfFontSize_MainMenu, 50.f);
		gfOptionsMenu_ExtraWidth_MultiSelect = cMath_Max(gfOptionsMenu_ExtraWidth_MultiSelect, 20.f);
		
		OptionMenu_AlignExtraButtonWidth();
		
		cVector2f vSubtitlesMenuPosOffset = cVector2f(0.f, mfSubtitleOptionsMenuPosOffsetY);
		cVector2f vSubtitlesMenuButtonPos = kOptionsButtonPos + vSubtitlesMenuPosOffset;
		cVector2f vSubtitlesMenuPos = kOptionsBgPos + vSubtitlesMenuPosOffset;
		cVector2f vSubtitlesMenuSize = kOptionsSubtitlesBgSize+cVector2f(gfOptionsMenu_ExtraWidth+gfOptionsMenu_ExtraWidth_MultiSelect,0);
		cVector3f vInfoBoxPos = OptionMenu_GetTopLeftOffset(cVector2f(vSubtitlesMenuPos.x+vSubtitlesMenuSize.x,0),0);
		cVector2f vRightAnchor = cVector2f(vSubtitlesMenuPos.x+vSubtitlesMenuSize.x-40,0);
		
		float fBGAlphaA = cMath_Easing(eEasing_SineInOut, mfSubtitleOptionsBGAlpha);
		float fBGAlphaB = 0.8f + fBGAlphaA * 0.2f;
		DoBackground(vRightAnchor.x + 120, fBGAlphaA, fBGAlphaB);
		
		////////////////
		// Audio
		OptionMenu_SectionTitle("SubtitleOptions", kOptionsBgPos + cVector2f(40,-40) + vSubtitlesMenuPosOffset, 1.f, mfTransitionAlpha);

		int lY=0;
		mlCurrentItemId = mlFirstItemId;
		OptionMenu_SetOutOfLimit(vMenuItems.length());
		
		/////////////////
		// SUBTITLES
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Sound", "ShowSubtitles", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], vSubtitlesMenuButtonPos, mlCurrentItemId, msSelectedSubtitlesButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Sound", "ShowSubtitles", bNewValue);
				++mlOptionChanges;
			}
			
			msSelectedSubtitlesButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedSubtitlesButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// HEARING AID
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Sound", "ForceShowSubtitleCharacterName", false);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], vSubtitlesMenuButtonPos, mlCurrentItemId, msSelectedSubtitlesButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Sound", "ForceShowSubtitleCharacterName", bNewValue);
				++mlOptionChanges;
			}
			
			msSelectedSubtitlesButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedSubtitlesButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// DIRECTIONAL SUBTITLES
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			bool bValue = mpConfig.GetBool("Sound", "ShowSubtitleDirection", false);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], vSubtitlesMenuButtonPos, mlCurrentItemId, msSelectedSubtitlesButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			if(bNewValue != bValue)
			{
				mpConfig.SetBool("Sound", "ShowSubtitleDirection", bNewValue);
				++mlOptionChanges;
			}
			msSelectedSubtitlesButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedSubtitlesButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// GRADUAL SUBTITLES
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Sound", "AnimateSubtitles", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], vSubtitlesMenuButtonPos, mlCurrentItemId, msSelectedSubtitlesButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Sound", "AnimateSubtitles", bNewValue);
				++mlOptionChanges;
			}
			
			msSelectedSubtitlesButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedSubtitlesButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// FADE AT DISTANCE
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Sound", "FadeSubtitlesOverDistance", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], vSubtitlesMenuButtonPos, mlCurrentItemId, msSelectedSubtitlesButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Sound", "FadeSubtitlesOverDistance", bNewValue);
				++mlOptionChanges;
			}
			
			msSelectedSubtitlesButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedSubtitlesButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// SUBTITLE SIZE
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			tString sValue = mpConfig.GetString("Sound", "SubtitleSizePreset", "Default");
			int lValue = 0;
			for (int i = 0; i < vSubtitleSizeValues.length(); i++)
			{
				if (vSubtitleSizeValues[i] != sValue)
					continue;
				lValue = i;
				break;
			}
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], vSubtitlesMenuButtonPos, mlCurrentItemId, msSelectedSubtitlesButton, vSubtitleSizeValues, lValue, false, mlActionHorizontal, "Menu" ,0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha, false, false, true, "", cString_To16Char(""), true);
			 
			if(lValue != lNewValue)
			{
				tString sNewValue = vSubtitleSizeValues[lNewValue];
				mpConfig.SetString("Sound", "SubtitleSizePreset", sNewValue);
				
				const float fNewSize = cLux_GetGameConfig().GetFloat("Voice", "FontSize_"+sNewValue, 23);
				mpConfig.SetFloat("Sound", "SubtitleSize", fNewSize);
				
				++mlOptionChanges;
			}
			
			msSelectedSubtitlesButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedSubtitlesButton);
		}
		mlCurrentItemId++;
		
		///////////////////////
		// SUBTITLE BG OPACITY
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			float fConfigValue = mpConfig.GetFloat("Sound", "SubtitleBGAlpha", 0.0f);
			tString sTextValue = fConfigValue==0 || fConfigValue==1 ? cString_ToString(fConfigValue, 0,true) : cString_ToString(fConfigValue, 1);// fConfigValue==0 ? "Off" : cString_ToString(fConfigValue, 1);
			tString sTextValueTransCat = ""; //fConfigValue==0 ? "Menu" : "";
			ImGui_SetStateFloat("CustomInfoBoxPosYAdd", -110.f);
			float fNewValue = OptionMenu_ButtonOptionsSlider(vMenuItems[mlCurrentItemId-mlFirstItemId], vSubtitlesMenuButtonPos, mlCurrentItemId, msSelectedSubtitlesButton, fConfigValue, 0.1f, mlActionHorizontal, sTextValue, sTextValueTransCat, vRightAnchor, vInfoBoxPos, mfTransitionAlpha, false, true, false, true);
			ImGui_SetStateFloat("CustomInfoBoxPosYAdd", 0.f);
			float fNewConfigValue = fNewValue;
			if (fNewConfigValue < 0.1)
				fNewConfigValue = 0;
			if (fNewConfigValue > 0.95)
				fNewConfigValue = 1.0f;
			
			if(fNewConfigValue != fConfigValue)
			{
				mpConfig.SetFloat("Sound", "SubtitleBGAlpha", fNewConfigValue);
				++mlOptionChanges;
			}

			msSelectedSubtitlesButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedSubtitlesButton);
		}
		if (cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false)
			mlCurrentItemId++;
		
		/////////////////
		// Back
		{
			bool bButton = MainMenu_DoBackButton(msSelectedSubtitlesButton, mfTransitionAlpha);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				if (mlOptionChanges == 0)
				{
					mlFirstItemId = 0;
					mlLastInFocus = 0;
					
					mTargetGroup = mPrevGroup;
					msTargetFocus = msSelectedAudioButton;
					
					if (ImGui_TimerExists("TransitionOut") == false)
						ImGui_AddTimer("TransitionOut",10.f);
				}
				
				///////////////////////
				// Show apply popup
				else
				{
					mbShowApplyChanges = true;
					msFocusNextFrame = "No";
				}

				/////////
				// Reset menu position
				if (bGamepad == false)
				{
					OptionMenu_ShowGamepadButtons(true);
					return;
				}
			}
			
			tString sID = cLux_GetInputHandler().GetGamepadWasLastDeviceUsed() ? vMenuItems[mlCurrentItemId] : "Back";
			msSelectedSubtitlesButton = OptionMenu_UpdateFocus(sID, msSelectedSubtitlesButton);
		}
		
		if (mbShowApplyChanges == false)
			GuiHandleTransition(mTargetGroup, msTargetFocus);

		/////////////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
		
		/////////////////
		// Preview subtitles
		cCamera@ pCam = cLux_GetPlayer().GetCamera();
		cLuxVoiceHandler@ pVoice = cLux_GetVoiceHandler();
		
		if (pVoice !is null && pCam !is null)
		{
			bool bPreviewSubtitles = mpConfig.GetBool("Sound", "ShowSubtitles", true);
			bool bPreviewAnimate = mpConfig.GetBool("Sound", "AnimateSubtitles", true);
			bool bPreviewDirectional = mpConfig.GetBool("Sound", "ShowSubtitleDirection", false);
			bool bPreviewDistanceFade = mpConfig.GetBool("Sound", "FadeSubtitlesOverDistance", true);
			bool bPreviewCaptions = mpConfig.GetBool("Sound", "ForceShowSubtitleCharacterName", false);
			float fPreviewBGAlpha = mpConfig.GetFloat("Sound", "SubtitleBGAlpha", 0.f);
			tString sPreviewSubtitleSize = mpConfig.GetString("Sound", "SubtitleSizePreset", "Default");
			
			cVector3f vCamPos = pCam.GetPosition();
			cVector3f vCamRight = pCam.GetRight();
			
			if (bPreviewSubtitles || bPreviewCaptions)
			{
				ApplySettings(false);
				pVoice.SetTempSubtitleOffsetY(-OptionMenu_GetScaledSize(46).y);
			}
			
			if (bPreviewSubtitles && 
				bPreviewCaptions && 
				sPreviewSubtitleSize == vSubtitleSizeValues[vSubtitleSizeValues.size() - 1])
			{
				mfSubtitleOptionsMenuPosOffsetY = -52.f;
			}
			else
			{
				mfSubtitleOptionsMenuPosOffsetY = 0.f;
			}
			
			if (bPreviewSubtitles && 
				mbDrawPreviewSubtitles &&
				ImGui_TimerExists("TransitionOut") == false && 
				mTargetGroup == eMainMenuGroup_Options_Audio_Subtitles)
			{
				tString sCharNameCategory = "SubtitleCharNames";
				tWString[] sCharNames = { cResources_Translate(sCharNameCategory, gsSubtitlePreview_Henri[0]), 
										  cResources_Translate(sCharNameCategory, gsSubtitlePreview_Lambert[0]) };
				array<array<tWString>> vSubtitles = { { cResources_Translate(gsSubtitlePreview_Henri[1], gsSubtitlePreview_Henri[2]) },
													  { cResources_Translate(gsSubtitlePreview_Lambert[1], gsSubtitlePreview_Lambert[2]) } };
				
				for (int i = 0; i < vSubtitles.size(); ++i)
				{
					int lDrawnChars = -1;
					bool bVoiceSoundMissing = false;
					bool bIsPlayer = false;
					bool bPlayWhilePaused = true;
					bool bPositional = i != 0;
					cVector3f vPos = vCamPos + vCamRight * -10.f;
					cColor color = cColor_White;
					tString sDrawnCharsVar = "DrawnCharVar_" + cString_To8Char(sCharNames[i]);
					
					/////////////////
					// Animate
					if (bPreviewAnimate)
					{
						float fDrawnChars = ImGui_GetStateFloat(sDrawnCharsVar, -1.f) + (10.f / 1.f) * cEngine_GetFrameTime();
						
						if (fDrawnChars > vSubtitles[i][0].length() + 10.f)
							fDrawnChars = 0.f;
						
						ImGui_SetStateFloat(sDrawnCharsVar, fDrawnChars);
						lDrawnChars = int(cMath_Min(fDrawnChars, vSubtitles[i][0].length()));
					}
					
					/////////////////
					// Dist fade
					if (bPreviewDistanceFade && i != 0)
					{
						float fDist = (vPos - vCamPos).Length();
						color.a = cMath_Clamp(1.f - (fDist / 20.f), 0.2f, 1.f);
					}	
					
					/////////////////
					// Draw
					pVoice.AddSubtitle(vSubtitles[i], sCharNames[i], color, lDrawnChars, bVoiceSoundMissing, bIsPlayer, bPlayWhilePaused, bPositional, vPos);
				}
			}
			
			/////////////////
			// Captions
			tWString sClosedCaption = cLux_Translate(gsSubtitlePreview_ClosedCaption[0], gsSubtitlePreview_ClosedCaption[1]);
			
			if (bPreviewCaptions &&
				ImGui_TimerExists("TransitionOut") == false &&
				mCurrentGroup == eMainMenuGroup_Options_Audio_Subtitles)
			{
				cVector3f vPos = vCamPos + vCamRight * 10.f;	
				pVoice.AddClosedCaption(sClosedCaption, 1.f, true, vPos, true);
			}
			else
			{
				pVoice.StopClosedCaption(sClosedCaption);
			}
			
			////////////////
			// Don't draw until reset
			mbDrawPreviewSubtitles = false;
			
			///////////////
			// Change background alpha so the subtitle preview is properly visible
			if (ImGui_TimerExists("TransitionOut") == false)
			{
				float fBGAlpha = (bPreviewSubtitles || bPreviewCaptions) ? 0.f : 1.f;
				mfSubtitleOptionsBGAlpha = cMath_IncreaseTo(mfSubtitleOptionsBGAlpha, cEngine_GetFrameTime() * 2.f, fBGAlpha);
			}
		}
	}
	
	//------------------------------------------------------

	void ShowMessageBoxes()
	{
		if(mbShowApplyChanges )
		{
			MessageBoxApplyChanges();
		}
		else if(mbShowDuplicateKeys )
		{
			MessageBoxDuplicateKeys();
		}
		else if(mbShowApplyKeyChanges )
		{
			MessageBoxApplyKeyChanges();
		}
		else if(mbShowReset)
		{
			MessageBoxResetKeys();
		}
		else if(mfKeepDisplaySetting > 0)
		{
			MessageBoxKeepResolution();
		}
		else if(mlActionToBind > 0)
		{
			MessageBoxKeybind();
		}
		else if(mbShowRestartWarning)
		{
			MessageBoxRestartWarning();
		}
		else if(mbShowExit)
		{
			if(mbMainMenuActive)
			{
				MessageBoxExitFromMainMenu();
			}
			else
			{
				MessageBoxExitFromPauseMenu();
			}
		}
		else if(mbShowPlayGo)
		{
			MessageBoxPlayGo();
		}
		else if(mbShowNewGame)
		{
			MessageBoxNewGame();
		}
		else if(mbShowSkipIntro)
		{
			MessageBoxSkipIntro();
		}
		else if (mbShowCustomSettingsChangesWillBeLost)
		{
			MessageBoxCustomSettingsChangesWillBeLost();
		}
		else if (mbShowOverwriteSaveSlot)
		{
			MessageOverwriteSaveSlot();
		}
		else if(mbShowLoadGame)
		{
			MessageBoxLoadGame();
		}
		else if(msLoadSaveError.length() > 0)
		{
			MessageBoxLoadError();
		}
		else if(mbShowDetectSettings)
		{
			MessageBoxDetectSettings();
		}
		else if(mbShowSelectedModDialog)
		{
			MessageBoxModDialog();
		}
		else if(mbShowGameCompleted)
		{
			MessageBoxGameCompleted();
		}
		else if(mbShowGameCompleted_02)
		{
			MessageBoxGameCompleted_02();
		}
		else if(mbShowGameCompleted_03)
		{
			MessageBoxGameCompleted_03();
		}
		else if (mbShowNewGamePlusPopUpMsg)
		{
			MessageBoxShowNewGamePlusCheatBtn();
		}
		else if (mbShowNewGamePlusSettingPopUp)
		{
			MessageBoxShowNewGamePlusSettingBtn();
		}
	}
	
	//------------------------------------------------------

	void MessageBoxApplyChanges()
	{
		////////////////////////////
		// Apply changes message box
		int lSelect = OptionMenu_MessageBox("ApplyChanges", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets
		mlActionHorizontal = 0;

		if(lSelect == -1)
		{
			ApplySettings();
			mlFirstItemId = 0;
			mlLastInFocus = 0;
			
			tString sNextFrameFocus = msSelectedVideoButton;
			
			if (mCurrentGroup == eMainMenuGroup_Options_Display_Gamma)
			{
				if (mbMainMenuActive == false)
				{
					mTargetGroup = eMainMenuGroup_Options;
					msTargetFocus = msSelectedOptionsButton;
				}
				else
				{
					mTargetGroup = eMainMenuGroup_Main;
					msTargetFocus = msSelectedMainMenuButton;
				}					
			}
			else if (mCurrentGroup == eMainMenuGroup_Options_Audio_Subtitles)
			{
				mTargetGroup = eMainMenuGroup_Options_Audio;
				msTargetFocus = msSelectedAudioButton;
				sNextFrameFocus = msSelectedSubtitlesButton;
			}
			else
			{
				mTargetGroup = eMainMenuGroup_Options;
				msTargetFocus = msSelectedOptionsButton;
				
				if (mCurrentGroup == eMainMenuGroup_Options_Display)
					sNextFrameFocus = msSelectedDisplayButton;
			}

			mlOptionChanges = 0;

			mbShowRestartWarning = mbRestartWarning;
			mbShowApplyChanges = false;
			
			//////////////////////////////
			// If resolution has changed 
			if(GetCurrentResolution() != mlCurrentResolution && Platform_IsConsole() == false)
			{
				mfKeepDisplaySetting = 15;
			}

			if(mfKeepDisplaySetting > 0) msFocusNextFrame = "No";
			else if(mbShowRestartWarning == false) msFocusNextFrame = sNextFrameFocus;
			else if(mbShowRestartWarning) msFocusNextFrame = "Ok";
			
			if (ImGui_TimerExists("TransitionOut") == false)
				ImGui_AddTimer("TransitionOut",10);
		}
		else if(lSelect == 1)
		{
			DiscardSettings();
			
			if (mCurrentGroup == eMainMenuGroup_Options_Display_Gamma)
			{
				if (mbMainMenuActive == false)
				{
					mTargetGroup = eMainMenuGroup_Options;
					msTargetFocus = msSelectedOptionsButton;
				}
				else
				{
					mTargetGroup = eMainMenuGroup_Main;
					msTargetFocus = msSelectedMainMenuButton;
				}					
			}
			else if (mCurrentGroup == eMainMenuGroup_Options_Audio_Subtitles)
			{
				mTargetGroup = eMainMenuGroup_Options_Audio;
				msTargetFocus = msSelectedAudioButton;
				msFocusNextFrame = msSelectedSubtitlesButton;
			}
			else
			{				
				mTargetGroup = eMainMenuGroup_Options;
				msTargetFocus = msSelectedOptionsButton;
				
				if (mCurrentGroup == eMainMenuGroup_Options_Display)
					msFocusNextFrame = msSelectedDisplayButton;
			}
			
			mlFirstItemId = 0;
			mlLastInFocus = 0;
			mlOptionChanges = 0;
			mbShowApplyChanges = false;
			
			if (ImGui_TimerExists("TransitionOut") == false)
				ImGui_AddTimer("TransitionOut",10);
		}

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
	}
	
	//------------------------------------------------------- 
	
	void MessageBoxApplyKeyChanges()
	{
		////////////////
		// Apply changes message box (Keybinding, Controller Preset)
		int lSelect = OptionMenu_MessageBox("ApplyChanges", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets 
		mlActionHorizontal = 0;

		bool bDismiss = false;
		if(lSelect == -1)
		{
			ApplyKeybinds();
			bDismiss = true;
			
			if (mlNewGamepadPresetSprintMode != -1)
			{
				mpConfig.SetInt("Accessibility", "SprintMode", mlNewGamepadPresetSprintMode);
				ApplySettings();
			}
		}
		else if(lSelect == 1)
		{
			DiscardKeybinds();
			bDismiss = true;
		}

		if(bDismiss)
		{
			mTargetGroup = eMainMenuGroup_Options_Controls;
			msTargetFocus =  mCurrentGroup == eMainMenuGroup_Options_Input_GamepadMapping ? msSelectedInputMouseButton : msSelectedInputButton;
			
			mbShowApplyKeyChanges = false;
			mlNewGamepadPresetSprintMode = -1;
			
			if (ImGui_TimerExists("TransitionOut") == false)
				ImGui_AddTimer("TransitionOut", 10);
		}
		
		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
	}
	
	//------------------------------------------------------- 
	
	void MessageBoxDuplicateKeys()
	{
		////////////////
		// Apply changes message box
		int lSelect = OptionMenu_MessageBox("DuplicateKeys", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets
		mlActionHorizontal = 0;

		if(lSelect == -1)
		{
			msFocusNextFrame = "Yes";
			mbShowDuplicateKeys = false;
		}
		else if(lSelect == 1)
		{
			msFocusNextFrame = "Back";
			mbShowDuplicateKeys = false;
			mbShowApplyKeyChanges = false;
		}

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
	}
	
	//-----------------------------------------------------------------------------------
	
	void MessageBoxResetKeys()
	{
		////////////////
		// Apply changes message box
		int lSelect = OptionMenu_MessageBox("ResetToDefaultMessage", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets
		mlActionHorizontal = 0;

		if(lSelect == -1)
		{
			// Erase all settings
			if(mbBindingGamepad)
			{
				for(int i = 0; i < mvGamepadActions.size(); ++i)
				{
					mpKeyConfig.EraseValue(mvGamepadActions[i].msAction, "GamepadPrimary");
					mpKeyConfig.EraseValue(mvGamepadActions[i].msAction, "GamepadSecondary");
				}
			}
			else
			{
				for(int i = 0; i < mvActions.size(); ++i)
				{
					mpKeyConfig.EraseValue(mvActions[i].msAction, "Primary");
					mpKeyConfig.EraseValue(mvActions[i].msAction, "Secondary");
				}
			}

			// Get default settings by reloading key config
			cLux_GetInputHandler().LoadKeyConfig();

			mbKeybindChanged = true;
			msFocusNextFrame = "ResetToDefault";
			mbShowReset = false;
				
			/////////////
			// Reloading keys will make actions trigger again, so ignore next frame
			mlIgnoreInput = 3;
		}
		else if(lSelect == 1)
		{
			msFocusNextFrame = "ResetToDefault";
			mbShowReset = false;
		}

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
	}
	
	//-----------------------------------------------------------------------------------
	
	void MessageBoxRestartWarning()
	{
		//////////////
		// Restart warning message box
		int lSelect = OptionMenu_MessageBox("RestartRequired", "Ok", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets
		mlActionHorizontal = 0;
			
		if(lSelect == 1)
		{
			mbShowRestartWarning = false;
			msFocusNextFrame = msSelectedVideoButton;
		}

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(false);
	}
	
	//-----------------------------------------------------------------------------------

	void MessageBoxKeepResolution()
	{
		//////////////
		// Restart warning message box
		int lSelect = OptionMenu_MessageBox("KeepSettings", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus, cString_To16Char(""+cMath_RoundToInt(mfKeepDisplaySetting+0.5)));
		ImGui_SetModUseInput(false); //disable input for any other widgets
		mlActionHorizontal = 0;

		mfKeepDisplaySetting -= 1.0 / cEngine_GetUpdatesPerSec();	

		if(lSelect == -1)
		{
			// Keep settings
			if(mbShowRestartWarning) msFocusNextFrame = "Ok";
			else msFocusNextFrame = msSelectedOptionsButton;
			
			mlCurrentResolution = GetCurrentResolution();
			
			mfKeepDisplaySetting = 0;
		}
		else if(lSelect == 1 || mfKeepDisplaySetting <= 0)
		{
			//////////
			// Revert to old settings
			mpConfig.SetString("Screen", "FullScreen", msCurrentDisplayMode);
			SetCurrentResolution(mlCurrentResolution);
			ApplySettings();

			if(mbShowRestartWarning) msFocusNextFrame = "Ok";
			else msFocusNextFrame = msSelectedOptionsButton;
			
			mfKeepDisplaySetting = 0;
		}

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(false);
	}
	
	//-----------------------------------------------------------------------------------
	
	void MessageBoxPlayGo()
	{
		////////////////
		// Get time left
		int64 lETA = 0;
		cLux_IsPlayGoReady(lETA);

		int64 lSeconds = lETA % 60;
		int64 lMinutes = (lETA / 60) % 60;
		int64 lHour = (lETA / 3600);

		tString sTime;

		if(lHour > 9) sTime += lHour + ":";
		else if(lHour > 0) sTime += "0"+lHour + ":";
			
		if(lMinutes > 9) sTime += lMinutes + ":";
		else if(lMinutes > 0) sTime += "0"+lMinutes + ":";

		if(lSeconds > 9) sTime += lSeconds;
		else if(lSeconds > 0) sTime += "0"+lSeconds;

		if(lETA == 0)
		{
			mfPlayGoTimer -= 1.0f / 30.0f;
			sTime = "";
		}
		else
		{
			mfPlayGoTimer = 3.0f;
		}

		////////////////////////////////
		// Restart warning message box
		int lSelect = OptionMenu_MessageBox("PlayGoInstructions", "Ok", "", msMessageBoxFocus, msMessageBoxFocus, cString_To16Char(sTime));
		ImGui_SetModUseInput(false); //disable input for any other widgets
		mlActionHorizontal = 0;

		if(lSelect == 1 || mfPlayGoTimer < 0)
		{
			mbShowPlayGo = false;
			msFocusNextFrame = msSelectedMainMenuButton;
		}

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(false);
	}
	
	//-----------------------------------------------------------------------------------

	void MessageBoxKeybind()
	{
		////////////////////////////////////
		// Darken other widgest
		cImGuiGfx gfx;
		gfx.mColor = cColor(0,1);
		ImGui_DrawGfx(gfx, ImGui_FullScreenPos(25.5), ImGui_FullScreenSize(), cColor(0, 0.65)); 
			
		///////////////
		// Draw title
		cImGuiLabelData labelData;
		labelData.mFont.SetFile(FontHandler_GetFont(eFontType_MainMenu_InfoBox, 56));
		labelData.mFont.mvSize = gfFontSize_Prompts;
		labelData.mFont.mColor =  cColor(1,1) * gOptionMenu_ModColor;
		labelData.mFontAlign = eFontAlign_Center;
		
		/////////////////////////////
		// Get data based on bind type
		bool bAnalog = mbBindingGamepad ? mvGamepadActions[mlActionToBind-1].mbAnalog : mvActions[mlActionToBind-1].mbAnalog;
		tString sAction = mbBindingGamepad ? mvGamepadActions[mlActionToBind-1].msAction : mvActions[mlActionToBind-1].msAction;

		if(bAnalog)
		{
			tString sLabel = msKeybindFirstState.length() == 0 ? "PressRightGamepad" : "PressUpGamepad";
			ImGui_DoLabelExt(sLabel,labelData, OptionMenu_GetTopLeftOffset(kOptionMenu_KeybindBgPos + cVector2f(kOptionMenu_KeybindBgSize.x * 0.45,15), 5.5), 0);
		}
		else
		{
			ImGui_DoLabelExt("PressAnyKey",labelData, OptionMenu_GetTopLeftOffset(kOptionMenu_KeybindBgPos + cVector2f(kOptionMenu_KeybindBgSize.x * 0.45,15), 5.5), 0);
		}

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(false);

		///////////////
		// Check if keybind button was pressed
		tString sKeyPressed = cLux_GetInputHandler().GetLatestKeyPressed();

		if(sKeyPressed.length() > 0)
		{
			/////////////
			// Disable cancel
			ImGui_ActionTriggered(eImGuiAction_Cancel, true);
			
			bool bCancelled = sKeyPressed == "Keyboard.Escape";
			
			if(mbBindingGamepad == false &&
			   cString_GetFirstStringPos(sKeyPressed, "Gamepad") >= 0 &&
			   cString_GetFirstStringPos(sKeyPressed, "Button.1") >= 0)
			   bCancelled = true;
			
			if(bCancelled == false)
			{
				//////////////
				// Check for valid keys
				if(mbBindingGamepad)
				{
					// Only allow gamepad 0
					if(cString_GetFirstStringPos(sKeyPressed, "Gamepad.0") == -1)
					{
						return;
					}
				}
				else
				{
					// Only allow mouse or keyboard
					if(cString_GetFirstStringPos(sKeyPressed, "Gamepad") >= 0)
					{
						return;
					}
				}
				
				if(bAnalog)
				{
					/////////////////
					// Analog requires two binds in a row and must be from gamepad
					if(cString_GetFirstStringPos(sKeyPressed, "Gamepad") != -1 && 
					   cString_GetFirstStringPos(sKeyPressed, "Axis") != -1)
					{
						if(msKeybindFirstState.length() == 0) 
						{
							msKeybindFirstState = sKeyPressed;
							return;
						}
						else if(sKeyPressed != msKeybindFirstState)
						{
							sKeyPressed = msKeybindFirstState +"."+ ParseKeybind(sKeyPressed, false);
						}
						else
						{
							return; //Skip binding if its the same axis again
						}
					}
					else
					{
						return; //Skip binding if not a gamepad axis
					}
				}
				
								
				mpKeyConfig.SetString(sAction, msKeybindSlot, sKeyPressed);
				mbKeybindChanged = true;
				mlIgnoreInput = 3;
			}

			mlActionToBind = 0;
			msFocusNextFrame = msFocusAfterBind;
		}
	}
	
	//-----------------------------------------------------------------------------------

	void MessageBoxExitFromPauseMenu()
	{
		//////////////
		// Restart warning message box
		//bool bExitToMenu =  mbExitToMainMenu;//mpConfig.GetBool("Main", "ShowMenu", true);
		
		tString sMessageBoxText = mbExitToMainMenu ? "QuitToMenuFromPauseMessageBox" : "QuitToDesktopFromPauseMessageBox";
		int lSelect = OptionMenu_MessageBox(sMessageBoxText, "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets
		mlActionHorizontal = 0;

		if(lSelect == 1)
		{
			///////////
			// Cancel
			msFocusNextFrame = mbExitToMainMenu ? "QuitToMainMenu" : "QuitToDesktop";
			mbShowExit = false;
		}
		else if(lSelect == -1)
		{
			///////////////
			// Achievement
			cConfigFile@ pUserFile = cLux_GetUserConfig();
			cConfigFile@ pStatsFile = cLux_GetStatsConfig();
			bool bUserNope = pUserFile !is null && pUserFile.GetBool("Game", "Nope", false);
			bool bStatsNope = pStatsFile !is null && pStatsFile.GetBool("Game", "Nope", false);
			if (bUserNope || bStatsNope) 
				Achievement_Unlock(eAchievement_Nope);
			/////////////////////////////////////
			// We're moving this over to the stats config. Make sure it doesn't break people's game.
			if (bUserNope && bStatsNope==false)
				pStatsFile.SetBool("Game", "Nope", true);
			
			////////////////////////////////////
			// Check for exit to menu or exit game
			if(mbExitToMainMenu)
			{
				cLux_GetGuiHandler().SetGameHudInputFocus(false);
				
				ImGui_AddTimer("ExitToMainMenu", mfFadeLength);
				Map_FadeOut(mfFadeLength);
				Music_StopAll(mfFadeLength);
				Sound_Stop("MenuBGNoise", mfFadeLength);
			}
			else
			{
				ImGui_AddTimer("ExitGame", mfExitGameFadeLength);
				Map_FadeOut(mfExitGameFadeLength);
				Music_StopAll(mfExitGameFadeLength);
				Sound_Stop("MenuBGNoise", mfFadeLength);
			}
		}
	}
	
	//-----------------------------------------------------------------------------------
	
	void MessageBoxExitFromMainMenu()
	{
		//////////////
		// Restart warning message box
		
		int lSelect = OptionMenu_MessageBox("QuitToDesktopMessageBox", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets
		mlActionHorizontal = 0;

		if(lSelect == 1)
		{
			///////////
			// Cancel
			mbShowExit = false;
			msFocusNextFrame = "Exit";
		}
		else if(lSelect == -1)
		{
			///////////
			// Exit the game
			//SetMenuActive(false);
			cLux_GetGuiHandler().SetGameHudInputFocus(false);
			
			ImGui_AddTimer("ExitGame", mfExitGameFadeLength);
			Map_FadeOut(mfExitGameFadeLength);
			Music_StopAll(mfExitGameFadeLength);
			Sound_Stop("MenuBGNoise", mfExitGameFadeLength);
		}
	}
	
	//-----------------------------------------------------------------------------------

	void MessageBoxNewGame()
	{
		//////////////
		// Restart warning message box
		int lSelect = OptionMenu_MessageBox("StartingNewGame", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false);
		mlActionHorizontal = 0;
		
		///////////
		// Cancel
		if(lSelect == 1)
		{
			mbShowNewGame = false;
			msFocusNextFrame = msSelectedGameplayButton;
			msTargetFocus = msSelectedGameplayButton;
		}
		///////////
		// Next page
		else if(lSelect == -1)
		{
			mbShowNewGame = false;
			ImGui_AddTimer("NewGameTimer", mfNewGameFadeLength);
			Sound_PlayGui("special_fx/frontend/new_game_sting", 1.0f, eSoundEntryType_Gui);
			Effect_Rumble_Start(0.5, 0.5, 1.f, 1.f);
			Music_StopAll(2.0f);
		}
	}
	
	//-----------------------------------------------------------------------------------

	void MessageBoxSkipIntro()
	{
		//////////////
		// Restart warning message box
		int lSelect = OptionMenu_MessageBox("SkipIntroMsg", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false);
		mlActionHorizontal = 0;
		
		///////////
		// Cancel
		if(lSelect == 1)
		{
			mbShowSkipIntro = false;
			mbShowNewGame = true;
			mbNewGameSkipIntro = false;
			msFocusNextFrame = "No";
			msMessageBoxFocus = "No";
		}
		///////////
		// Start New game
		else if(lSelect == -1)
		{
			mbShowSkipIntro = false;
			mbShowNewGame = true;
			mbNewGameSkipIntro = true;
			msFocusNextFrame = "No";
			msMessageBoxFocus = "No";
		}
	}
	
	//-----------------------------------------------------------------------------------
	
	void MessageBoxCustomSettingsChangesWillBeLost()
	{
		//////////////
		// warning message box
		int lSelect = OptionMenu_MessageBox("CustomSettingsChangesMsg", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false);
		mlActionHorizontal = 0;
		
		///////////
		// Cancel
		if(lSelect == 1)
		{
			mbToggleNewGamePlus = false;
			mbShowCustomSettingsChangesWillBeLost = false;
			mlCustomSettingsChangesWillBeLost = eCustomSettingsChangesWillBeLost_None;
			msFocusNextFrame = msSelectedGameModesBtn;
			msMessageBoxFocus = msSelectedGameModesBtn;
			
			ImGui_StopTimer("TransitionOut");
		}
		///////////
		// Proceed
		else if(lSelect == -1)
		{
			mbShowCustomSettingsChangesWillBeLost = false;
			
			if (mbToggleNewGamePlus)
			{
				mbToggleNewGamePlus = false;
				mbNewGamePlus = false;
			}
			
			if (mlCustomSettingsChangesWillBeLost == eCustomSettingsChangesWillBeLost_BackBtn)
			{
				if (ImGui_TimerExists("TransitionOut") == false)
					ImGui_AddTimer("TransitionOut", 10);
				
				mlFirstItemId = 0;
				mlLastInFocus = mlLastInFocus_SaveSlots;
				mTargetGroup = eMainMenuGroup_SaveSlotSelection;
				msTargetFocus = msSelectedSaveSlotButton;
				mlCustomSettingsChangesWillBeLost = eCustomSettingsChangesWillBeLost_None;
			}
			else if (mlCustomSettingsChangesWillBeLost == eCustomSettingsChangesWillBeLost_Randomize)
			{
				RandomizeCustomDifficultySettings();
				mlCustomSettingsChangesWillBeLost = eCustomSettingsChangesWillBeLost_None;
				msFocusNextFrame = "RandomizeSettings";
			}
			else if (mlCustomSettingsChangesWillBeLost == eCustomSettingsChangesWillBeLost_Default)
			{
				mlSelectedGameMode = mlNewGameModeToUse;
				mlCustomSettingsChangesWillBeLost = eCustomSettingsChangesWillBeLost_None;
				GameDifficulty_SwitchSettingsPresetTo(mlSelectedGameMode);
			}
		}
		
		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(false);
	}
	
	//-----------------------------------------------------------------------------------
	
	void MessageOverwriteSaveSlot()
	{
		//////////////
		// Restart warning message box
		int lSelect = OptionMenu_MessageBox("OverwriteGame", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false);
		mlActionHorizontal = 0;
		
		///////////
		// Cancel
		if(lSelect == 1)
		{
			mbShowOverwriteSaveSlot = false;
			mlSelectedSaveSlot = mlPreviouslySelectedSaveSlot; //revert
			mlSelectedGameMode = mlPrevSelectedGameMode;
			GameDifficulty_SwitchSettingsPresetTo(mlPrevSelectedGameMode);
			msFocusNextFrame = msSelectedSaveSlotButton;
			msTargetFocus = msSelectedSaveSlotButton;
			
			cLux_AddDebugMessage("[MainMenu] Save suffix is: " + mlSelectedSaveSlot);
		}
		///////////
		// Next page
		else if(lSelect == -1)
		{
			mbShowOverwriteSaveSlot = false;
			mlFirstItemId = 0;
			mlLastInFocus_SaveSlots = mlLastInFocus;
			mlLastInFocus = 0;
			msFocusNextFrame = msSelectedSaveSlotButton;
			mTargetGroup = eMainMenuGroup_GameModes;
			msSelectedGameModesBtn = "DifficultyMode";
			msTargetFocus = msSelectedGameModesBtn;
			
			//////////////////////////////////
			// Always suggest the normal game mode
			mlSelectedGameMode = eGameMode_Normal;
			GameDifficulty_SwitchSettingsPresetTo(eGameMode_Normal);
					
			if (ImGui_TimerExists("TransitionOut") == false)
				ImGui_AddTimer("TransitionOut", 10);
				
			cLux_AddDebugMessage("[MainMenu] Save suffix is: " + mlSelectedSaveSlot);
		}
	}

	//-----------------------------------------------------------------------------------

	void MessageBoxLoadGame()
	{
		//////////////
		// Restart warning message box
		int lSelect = OptionMenu_MessageBox("LoadMessageBox", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets
		mlActionHorizontal = 0;

		if(lSelect == 1)
		{
			///////////
			// Cancel
			mbShowLoadGame = false;
			
			//////////////
			// Handle the load game page
			if(mCurrentGroup == eMainMenuGroup_LoadGame)
			{
				if(mlSelectedLoadButton >= 0 && mlSelectedLoadButton < 3)
					msFocusNextFrame = "SaveGame_"+mlSelectedLoadButton;
				else
					msFocusNextFrame = "Back";
			}
			/////////////////
			// Handle main menu
			else
			{
				msFocusNextFrame = mbPauseMenuEnabled ? "LoadLastSave" : "Continue";
			}
		}
		else if(lSelect == -1)
		{
			///////////
			// Load the game
			if (mbPauseMenuEnabled)
			{
				bool bLoadSelectedGame = mCurrentGroup == eMainMenuGroup_LoadGame;
				tWString sFileToLoad = bLoadSelectedGame ? msSaveFileToLoad : msContinueFile;
				StartSavedGameLoad(sFileToLoad);
				mbShowLoadGame = false;
			}
			else
			{
				ImGui_AddTimer("LoadGame", gfContinueGameFadeOutTime);
				cSound_FadeOutAll(eSoundEntryType_WorldAll, 1.0f / gfContinueGameFadeOutTime, false);
				Music_StopAll(mfFadeLength);
				Sound_Stop("MenuBGNoise", mfFadeLength);
				mbShowLoadGame = false;
				cLux_GetGuiHandler().SetGameHudInputFocus(false);
			}
			
			//GameStats_Load();
		}

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(false);
	}
	
	//-----------------------------------------------------------------------------------

	void MessageBoxLoadError()
	{
		//////////////
		// Restart warning message box
		ImGui_SetTransCategory("LoadGame");
		int lSelect = OptionMenu_MessageBox(msLoadSaveError, "Ok", "", msMessageBoxFocus, msMessageBoxFocus, ImGui_TranslatePlatformSpecific(mbProfileError ? "DeleteProfile" : "DeleteSave"));
		ImGui_SetModUseInput(false); //disable input for any other widgets
		ImGui_SetTransCategory("Menu");
		mlActionHorizontal = 0;

		if(lSelect == 1)
		{
			msLoadSaveError = "";

			if(mbProfileError)
			{
				if(mpConfig !is null) mpConfig.Save();
				if(mpKeyConfig !is null) mpKeyConfig.Save();
			}
			else if(mbProfileError == false && cString_To8Char(msPreviousSaveLoaded) != "")
			{
				//////////////////
				//Delete the save file
				cLux_GetSaveHandler().DeleteSaveFile(msPreviousSaveLoaded);

				for(int i = 0; i < mvSaveFiles.size(); ++i)
				{
					if(cString_To8Char(mvSaveFiles[i]) == 
					   cString_To8Char(msPreviousSaveLoaded))
					{
						for(int j = i + 1; j < mvSaveFiles.size(); ++j)
						{
							mvSaveFiles[j-1] = mvSaveFiles[j];
							mvSaveDates[j-1] = mvSaveDates[j];
							mvSaveNames[j-1] = mvSaveNames[j];	
							mvSaveSuffix[j-1] = mvSaveSuffix[j];
							mvSaveModeSuffix[j-1] = mvSaveModeSuffix[j];
						}
						
						mvSaveFiles.resize(mvSaveFiles.size()-1);
						mvSaveDates.resize(mvSaveDates.size()-1);
						mvSaveNames.resize(mvSaveNames.size()-1);
						mvSaveSuffix.resize(mvSaveSuffix.size()-1);
						mvSaveModeSuffix.resize(mvSaveModeSuffix.size()-1);

						break;
					}
				}

				if(cString_To8Char(msContinueFile) == cString_To8Char(msPreviousSaveLoaded))
				{
					 msContinueFile = "";
					 mbCanContinue = false;
				}

				msPreviousSaveLoaded = "";

				if(mbCanContinue == false)
				{
					mbCanContinue = mvSaveFiles.size() > 0;

					if(mbCanContinue)
					{
						msContinueFile = mvSaveFiles[0];
						//msContinueSuffix = mvSaveSuffix[0];
						mlSelectedSaveSlot = cString_GetNumericSuffixIntW(mvSaveSuffix[0]);
						mlSelectedGameMode = cString_GetNumericSuffixIntW(mvSaveModeSuffix[0]);

						///////////
						// Remove "CheckPoint" from save file list
						for(int i = 0; i < mvSaveFiles.size(); ++i)
						{
							if(cString_GetFirstStringPosW(mvSaveNames[i], tWString("CheckPoint")) != -1)
							{
								for(int j = i + 1; j < mvSaveFiles.size(); ++j)
								{
									mvSaveFiles[j-1] = mvSaveFiles[j];
									mvSaveDates[j-1] = mvSaveDates[j];
									mvSaveNames[j-1] = mvSaveNames[j];	
									mvSaveSuffix[j-1] = mvSaveSuffix[j];
									mvSaveModeSuffix[j-1] = mvSaveModeSuffix[j];
								}
						
								mvSaveFiles.resize(mvSaveFiles.size()-1);
								mvSaveDates.resize(mvSaveDates.size()-1);
								mvSaveNames.resize(mvSaveNames.size()-1);
								mvSaveSuffix.resize(mvSaveSuffix.size()-1);
								mvSaveModeSuffix.resize(mvSaveModeSuffix.size()-1);
							}
						}
					}
				}
			}
		}

		///////////
		// Show gamepad legacy
		if(mbProfileError == false) OptionMenu_ShowGamepadButtons(false);
	}
	
	//-----------------------------------------------------------------------------------
	
	void MessageBoxDetectSettings()
	{
		////////////////
		// Apply changes message box
		int lSelect = OptionMenu_MessageBox("DetectSettingsPrompt", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets
		mlActionHorizontal = 0;

		if(lSelect == -1)
		{
			AutoDetectSettings(false);
			mbShowDetectSettings = false;
		}
		else if(lSelect == 1)
		{
			mbShowDetectSettings = false;
		}

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
	}

	//-----------------------------------------------------------------------------------
	
	void MessageBoxModDialog()
	{
		//////////////
		// Restart warning message box
		ImGui_SetTransCategory("ModMenu");
		int lSelect = OptionMenu_MessageBox("CustomStoryStartConfirm", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets
		mlActionHorizontal = 0;

		/////////
		// Cancel
		if(lSelect == 1)
		{
			mbShowSelectedModDialog = false;
			
			/*if(mCurrentGroup == eMainMenuGroup_CustomStories)
			{
				if(mlSelectedModEntry >= 0 && mlSelectedModEntry < kMaxModsToShow)
					msFocusNextFrame = "Mod" + cString_ToString(mlSelectedModEntry);
				else
					msFocusNextFrame = "Back";
			}
			else
			{
				msFocusNextFrame = "Exit";
			}*/
		}
		/////////
		// Launch
		else if(lSelect == -1)
		{
			mbShowSelectedModDialog = false;
			array<uint32> vAddOnIDs;
			m_setSelectedAddOnIDs.ElementsToArray(vAddOnIDs);
			//cLux_GetModHandler().LaunchMod(mvModIDs[mlModEntryToLoad]);
			mbHasSaveFiles = false;
			cLux_GetModHandler().LaunchMod_New(mlSelectedStandAloneModID, vAddOnIDs);
			cLux_AddDebugMessage("LAUNCHING MOD!!!!!!");
		}

		//////////////////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(false);
	}
	
	//-----------------------------------------------------------------------------------
	
	void MessageBoxGameCompleted()
	{
		//////////////
		// Restart warning message box
		ImGui_SetTransCategory("Menu");
		bool bSelect = OptionMenu_MessageBox_GameCompleted("GameCompletedOnce_01", "Next", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets
		mlActionHorizontal = 0;

		if(bSelect)
		{
			mbGameCompletedMsgSeen = true;
			cConfigFile@ pFile = cLux_GetStatsConfig();
			pFile.SetBool("Game", "NewGamePlusMsgSeen", true);
			mbShowGameCompleted = false;
			mbShowGameCompleted_02 = true;
			msFocusNextFrame = "Next";
		}
		
		//cLux_AddDebugMessage("msg 1");
		//////////////////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(false, false);
	}
	
	void MessageBoxGameCompleted_02()
	{
		//////////////
		// Restart warning message box
		ImGui_SetTransCategory("Menu");
		bool bSelect = OptionMenu_MessageBox_GameCompleted("GameCompletedOnce_02", "Next", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets
		mlActionHorizontal = 0;

		if(bSelect)
		{
			mbShowGameCompleted_02 = false;
			mbShowGameCompleted_03 = true;
			msFocusNextFrame = "Next";
		}
		
		//cLux_AddDebugMessage("msg 2");
		//////////////////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(false, false);
	}
	
	void MessageBoxGameCompleted_03()
	{
		//////////////
		// Restart warning message box
		ImGui_SetTransCategory("Menu");
		bool bSelect = OptionMenu_MessageBox_GameCompleted("GameCompletedOnce_03", "Ok", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets
		mlActionHorizontal = 0;

		if(bSelect)
		{
			mbShowGameCompleted_03 = false;
			msFocusNextFrame = "Ok";
		}
		
		//cLux_AddDebugMessage("msg 3");
		//////////////////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(false, false);
	}
	
	//-----------------------------------------------------------------------------------
	
	void MessageBoxShowNewGamePlusCheatBtn()
	{
		////////////////
		// Apply changes message box
		int lSelect = OptionMenu_MessageBox("NewGamePlusCodeWarning", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets
		mlActionHorizontal = 0;

		if(lSelect == -1)
		{
			mbShowNewGamePlusPopUpMsg = false;
			mbShowNewGamePlusButton = false;
			SetGameCompletedOnce(true);
		}
		else if(lSelect == 1)
		{
			mbShowNewGamePlusPopUpMsg = false;
		}

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
	}
	
	//-----------------------------------------------------------------------------------
	
	void MessageBoxShowNewGamePlusSettingBtn()
	{
		////////////////
		// Apply changes message box
		int lSelect = OptionMenu_MessageBox("NewGamePlusSettingPopUp", "Ok", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets
		mlActionHorizontal = 0;

		if(lSelect == -1)
		{
			mbShowNewGamePlusSettingPopUp = false;
			msFocusNextFrame = "NewGamePlusSetting";
		}
		else if(lSelect == 1)
		{
			mbShowNewGamePlusSettingPopUp = false;
			msFocusNextFrame = "NewGamePlusSetting";
		}

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
	}
	
	//-----------------------------------------------------------------------------------

	int mlStartPos = 0;
	int mlTestButton = 1;
	int mlMap = 0;
	bool mbPauseProfiler = false;
	int mlProfilerFilter = 0;
	int mlSpeed = 0;
	//bool mbReloadGame = false;
	
	int mlFirstItemId = 0; // ID of the first item in the list
	int mlCurrentItemId = 0;
	int mlDebugHoverItemId = 0; // ID of the button to hover
	
	int mlScrollMargin = 2;
	int mlLastInFocus = 0;
	int mlLastInFocusRel = 0;
	int mlLastInFocus_SaveSlots = 0;
	bool mbScrolled = false;
	bool mbScrollDown = false;
	bool mbScrollUp = false;
	
	//-----------------------------------------------------------------------------------
	
	void DoCustomScrollInput(array<tString> avMenuItems, bool abUseBothAxis=false)
	{
		if(	mbShowApplyChanges || mbShowDuplicateKeys || 
			mbShowApplyKeyChanges || mbShowReset || 
			mbShowRestartWarning || mbShowExit || mbShowPlayGo ||
			mbShowNewGame || mbShowSkipIntro || mbShowCustomSettingsChangesWillBeLost || mbShowOverwriteSaveSlot 
			|| mbShowLoadGame || mbShowSelectedModDialog || mbShowNewGamePlusPopUpMsg || mbShowNewGamePlusSettingPopUp ||
			mbShowDetectSettings || mbShowGameCompleted || mbShowGameCompleted_02 || mbShowGameCompleted_03 || 
			mfKeepDisplaySetting > 0 || mlActionToBind > 0 || 
			(msLoadSaveError.length() > 0 && mbPremenuActive == false))
			{
				return;
			}
		
		bool bWantsToScrollDown = ImGui_ActionTriggered(eImGuiAction_Down, true);
		bool bWantsToScrollUp = ImGui_ActionTriggered(eImGuiAction_Up, true);
		bool bWantsToScrollRight = ImGui_ActionTriggered(eImGuiAction_Right, false);
		bool bWantsToScrollLeft = ImGui_ActionTriggered(eImGuiAction_Left, false);
		
		/////////////////////
		// SCROLL DOWN
		if(bWantsToScrollDown || (abUseBothAxis && bWantsToScrollRight)) 
		{ 
			int lNextID = mlLastInFocus+1;
			if (lNextID >= avMenuItems.length())
				lNextID = 0;
			
			tString sNextID = avMenuItems[lNextID];
			ImGui_SetFocus(sNextID);
			mlLastInFocus = lNextID;
			//cLux_AddDebugMessage("[MenuHandler] Start Custom Widget Scrolling. Current Widget Name: " + sNextID + ". Current widget in focus ID: " + lNextID);
		}
		
		/////////////////////
		// SCROLL UP
		else if(bWantsToScrollUp || (abUseBothAxis && bWantsToScrollLeft)) 
		{
			int lNextID = mlLastInFocus > 0 ? mlLastInFocus-1 : avMenuItems.length()-1;
				
			/////////////////////////////
			// No idea why this happens but if using a gamepad and mlLastInFocus == avMenuItems.length()-1 then mlLastInFocus-=1 equals avMenuItems.length()-1 which makes no sense. 
			// So I added this to debug. But why is it happening in the first place?
			//else if (lNextID == avMenuItems.length()-1)
			//	lNextID = avMenuItems.length()-2;
			
			tString sNextID = avMenuItems[lNextID];
			ImGui_SetFocus(sNextID);
			mlLastInFocus = lNextID;
			//cLux_AddDebugMessage("[MenuHandler] Start Custom Widget Scrolling. Current Widget Name: " + sNextID + ". Current widget in focus ID: " + mlLastInFocus);
		}
	}
	
	//-------------------------------------------------------
	
	tString OptionMenu_UpdateFocusCustom(const array<tString> &in avMenuItems, tString asID, tString asSelector)
	{
		if (ImGui_PrevBecameInFocus())
		{
			mlLastInFocus = mlCurrentItemId - mlFirstItemId;
			
			if (mlCurrentItemId >= 0 && mlCurrentItemId < avMenuItems.length())
			{
				tString asAbsoluteID = avMenuItems[mlLastInFocus];
				mlDebugHoverItemId = avMenuItems.find(avMenuItems[mlCurrentItemId])-mlFirstItemId;
				Sound_PlayGui("special_fx/frontend/frontend_menu_focus", 1.0f, eSoundEntryType_Gui);
				return asAbsoluteID;
			}
			
		}
		
		return asSelector;
	}
	
	//------------------------------------------------------- 
	
	void GuiOptionsAccessibility()
	{
		GuiPauseDarkOverlay();
		
		array<tString> vMenuItems = {"HearingAid", "SubtitleDirectionalIndicators", "ReduceCameraMotion", "ScreenDisortion", "AccessibilityGameplay", "AccessibilityInput"};
		if (cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false)
			vMenuItems.push_back("Back");
		
		for (int i=0; i<vMenuItems.length(); i++)
		{
			OptionMenu_UpdateButtonWidth(vMenuItems[i]);
		}
		OptionMenu_UpdateToggleExtraWidth();
		OptionMenu_AlignExtraButtonWidth();
		
		cVector2f vDebugMenuPos = kOptionsAccessibilityBgPos;
		cVector2f vDebugMenuSize = kOptionsAccessibilityBgSize + cVector2f(gfOptionsMenu_ExtraWidth + gfOptionsMenu_ExtraWidth_MultiSelect, 0);
		cVector2f vRightAnchor = cVector2f(vDebugMenuPos.x + vDebugMenuSize.x - 40,0);
		
		DoBackground(vRightAnchor.x);
		
		cVector3f vInfoBoxPos = OptionMenu_GetTopLeftOffset(cVector2f(vDebugMenuPos.x + vDebugMenuSize.x - 110,0), 0);
		
		////////////////
		// Title
		OptionMenu_SectionTitle("Options_Accessibility", kOptionsAccessibilityBgPos + cVector2f(40,-40), 1.f, mfTransitionAlpha);

		ImGui_SetTransCategory("Menu");
		
		mlCurrentItemId = mlFirstItemId;
		
		/////////////////
		// Closed Captions
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			bool bValue = mpConfig.GetBool("Sound", "ForceShowSubtitleCharacterName", false);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsAccessibilityButtonPos, mlCurrentItemId, msSelectedAccessibilityButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			if(bNewValue != bValue)
			{
				mpConfig.SetBool("Sound", "ForceShowSubtitleCharacterName", bNewValue);
			}
			msSelectedAccessibilityButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedAccessibilityButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Directional Subtitles
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			bool bValue = mpConfig.GetBool("Sound", "ShowSubtitleDirection", false);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsAccessibilityButtonPos, mlCurrentItemId, msSelectedAccessibilityButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			if(bNewValue != bValue)
			{
				mpConfig.SetBool("Sound", "ShowSubtitleDirection", bNewValue);
			}
			msSelectedAccessibilityButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedAccessibilityButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Camera Motion
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			bool bValue = mpConfig.GetBool("Accessibility", "ReduceCameraMotion", false);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsAccessibilityButtonPos, mlCurrentItemId, msSelectedAccessibilityButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			if (bNewValue != bValue)
			{
				mpConfig.SetBool("Accessibility", "ReduceCameraMotion", bNewValue);
			}
			msSelectedAccessibilityButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedAccessibilityButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Screen Distortion
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			bool bValue = mpConfig.GetBool("Gameplay", "ScreenDisortion", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsAccessibilityButtonPos, mlCurrentItemId, msSelectedAccessibilityButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			if(bNewValue != bValue)
			{
				mpConfig.SetBool("Gameplay", "ScreenDisortion", bNewValue);
			}
			msSelectedAccessibilityButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedAccessibilityButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Gameplay
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			if(OptionMenu_ButtonOptions(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsAccessibilityButtonPos, mlCurrentItemId, msSelectedAccessibilityButton, true, vRightAnchor, vInfoBoxPos, mfTransitionAlpha))
			{
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				
				mPrevGroup = eMainMenuGroup_Options_Accessibility;
				mTargetGroup = eMainMenuGroup_Options_Accessibility_Game;
				msTargetFocus = msSelectedAccessibilityGameButton;
			}
			msSelectedAccessibilityButton = OptionMenu_UpdateFocusCustom(vMenuItems, vMenuItems[mlCurrentItemId], msSelectedAccessibilityButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Input
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			if(OptionMenu_ButtonOptions(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsAccessibilityButtonPos, mlCurrentItemId, msSelectedAccessibilityButton, true, vRightAnchor, vInfoBoxPos, mfTransitionAlpha))
			{
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				
				mPrevGroup = eMainMenuGroup_Options_Accessibility;
				mTargetGroup = eMainMenuGroup_Options_Accessibility_Input;
				msTargetFocus = msSelectedAccessibilityInputButton;
			}
			msSelectedAccessibilityButton = OptionMenu_UpdateFocusCustom(vMenuItems, vMenuItems[mlCurrentItemId], msSelectedAccessibilityButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Back
		{
			bool bButton = MainMenu_DoBackButton(msSelectedAccessibilityButton, mfTransitionAlpha);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				ApplySettings();
				
				if (ImGui_TimerExists("TransitionOut") == false)
					ImGui_AddTimer("TransitionOut", 10);
				
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				mTargetGroup = mbAccessibilityOptionsBackToNewGame ? eMainMenuGroup_Options_NewGame_Gameplay : eMainMenuGroup_Options;
				msTargetFocus = mbAccessibilityOptionsBackToNewGame ? msSelectedGameplayButton : msSelectedOptionsButton;

				/////////
				// Reset menu position
				if(bGamepad == false)
				{
					OptionMenu_ShowGamepadButtons(true);
					return;
				}
			}
			
			tString sID = cLux_GetInputHandler().GetGamepadWasLastDeviceUsed() ? vMenuItems[mlCurrentItemId-1] : "Back";
			msSelectedAccessibilityButton = OptionMenu_UpdateFocus(sID, msSelectedAccessibilityButton);
		}
		
		GuiHandleTransition(mTargetGroup, msTargetFocus);
		
		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
	}
	
	//------------------------------------------------------- 
	
	void GuiOptionsAccessibilityGame()
	{
		GuiPauseDarkOverlay();
		
		array<tString> vMenuItems = {"AimAssist", "WeaponSway", "ReducedEnemyPerception", "NonAggressiveRats"};
		if (cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false)
			vMenuItems.push_back("Back");
			
		array<tString> vAimAssistOptions = {"CustomSettings_None", "CustomSettings_VeryLow", "CustomSettings_Low", "CustomSettings_Medium", "CustomSettings_High", "CustomSettings_VeryHigh"};
			
		for (int i=0; i<vMenuItems.length(); i++)
		{
			OptionMenu_UpdateButtonWidth(vMenuItems[i], 410);
		}
		OptionMenu_UpdateToggleExtraWidth();
		OptionMenu_AlignExtraButtonWidth();
		
		cVector2f vDebugMenuPos = kOptionsAccessibilityBgPos;
		cVector2f vDebugMenuSize = kOptionsAccessibilityBgSize + cVector2f(gfOptionsMenu_ExtraWidth + gfOptionsMenu_ExtraWidth_MultiSelect, 0);
		cVector2f vRightAnchor = cVector2f(vDebugMenuPos.x + vDebugMenuSize.x - 40,0);
		
		DoBackground(vRightAnchor.x + 210);
		
		cVector3f vInfoBoxPos = OptionMenu_GetTopLeftOffset(cVector2f(vDebugMenuPos.x + vDebugMenuSize.x + 110,0), 0);
		
		////////////////
		// Title
		OptionMenu_SectionTitle("Options_AccessibilityGameplay", kOptionsAccessibilityBgPos + cVector2f(40,-40), 1.f, mfTransitionAlpha);

		ImGui_SetTransCategory("Menu");
		
		mlCurrentItemId = mlFirstItemId;
		
		/////////////////
		// Aim Assist
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			int lValue = mpConfig.GetInt("Accessibility", "AimAssist", 0);
			int lNewValue = OptionMenu_ButtonOptionsMultiSelectSlider(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsAccessibilityButtonPos, mlCurrentItemId, msSelectedAccessibilityGameButton, vAimAssistOptions, lValue, mlActionHorizontal, vAimAssistOptions[lValue], "menu", vRightAnchor, vInfoBoxPos, mfTransitionAlpha, false, true, "", cString_To16Char(""), true);
			if (lNewValue != lValue)
			{
				mpConfig.SetInt("Accessibility", "AimAssist", lNewValue);
			}
			msSelectedAccessibilityGameButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedAccessibilityGameButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Weapon Sway
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			bool bValue = mpConfig.GetBool("Accessibility", "WeaponSway", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsAccessibilityButtonPos, mlCurrentItemId, msSelectedAccessibilityGameButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha, false, true, "", cString_To16Char(""), true);

			if (bNewValue != bValue)
			{
				mpConfig.SetBool("Accessibility", "WeaponSway", bNewValue);
			}
			msSelectedAccessibilityGameButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedAccessibilityGameButton);
		}
		mlCurrentItemId++;
		
		///////////////////////////
		// Reduced Enemy Perception
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			bool bValue = mpConfig.GetBool("Accessibility", "ReducedEnemyPerception", false);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsAccessibilityButtonPos, mlCurrentItemId, msSelectedAccessibilityGameButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha, false, true, "", cString_To16Char(""), true);
			if (bNewValue != bValue)
			{
				mpConfig.SetBool("Accessibility", "ReducedEnemyPerception", bNewValue);
			}
			msSelectedAccessibilityGameButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedAccessibilityGameButton);
		}
		mlCurrentItemId++;
		
		///////////////////////////
		// Non- Aggressive Rats
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			bool bValue = mpConfig.GetBool("Accessibility", "NonAggressiveRats", false);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsAccessibilityButtonPos, mlCurrentItemId, msSelectedAccessibilityGameButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha, false, true, "", cString_To16Char(""), true);
			if (bNewValue != bValue)
			{
				mpConfig.SetBool("Accessibility", "NonAggressiveRats", bNewValue);
			}
			msSelectedAccessibilityGameButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedAccessibilityGameButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Back
		{
			bool bButton = MainMenu_DoBackButton(msSelectedAccessibilityGameButton, mfTransitionAlpha);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				ApplySettings();
				
				if (ImGui_TimerExists("TransitionOut") == false)
					ImGui_AddTimer("TransitionOut", 10);
				
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				mTargetGroup = eMainMenuGroup_Options_Accessibility;
				msTargetFocus = msSelectedAccessibilityButton;

				/////////
				// Reset menu position
				if(bGamepad == false)
				{
					OptionMenu_ShowGamepadButtons(true);
					return;
				}
			}
			
			tString sID = cLux_GetInputHandler().GetGamepadWasLastDeviceUsed() ? vMenuItems[mlCurrentItemId-1] : "Back";
			msSelectedAccessibilityGameButton = OptionMenu_UpdateFocus(sID, msSelectedAccessibilityGameButton);
		}
		
		GuiHandleTransition(mTargetGroup, msTargetFocus);
		
		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
	}
	
	//------------------------------------------------------- 
	
	void GuiOptionsAccessibilityInput()
	{
		GuiPauseDarkOverlay();
		
		array<tString> vMenuItems = {"PhysicsInteractionMode", "SprintMode", "UseItemMode", "ReloadWeaponMode", "ChargeFlashlightMode", "CheckHealthMode", "LeanMode"};
		array<tString> vOptions = {"Hold", "Toggle"};
		array<tString> vRunOptions = {"Hold", "SemiToggle", "Toggle"};
		if (cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false)
			vMenuItems.push_back("Back");
			
		for (int i=0; i<vMenuItems.length(); i++)
		{
			OptionMenu_UpdateButtonWidth(vMenuItems[i], 450);
		}
		
		OptionMenu_UpdateMultiSelectionExtraWidth(vRunOptions, "Menu", gfFontSize_MainMenu, 50.f);
		OptionMenu_AlignExtraButtonWidth();
		
		cVector2f vDebugMenuPos = kOptionsAccessibilityBgPos;
		cVector2f vDebugMenuSize = kOptionsAccessibilityBgSize + cVector2f(gfOptionsMenu_ExtraWidth + gfOptionsMenu_ExtraWidth_MultiSelect, 0);
		cVector2f vRightAnchor = cVector2f(vDebugMenuPos.x + vDebugMenuSize.x - 40,0);
		
		DoBackground(vRightAnchor.x + 100);
		
		cVector3f vInfoBoxPos = OptionMenu_GetTopLeftOffset(cVector2f(vDebugMenuPos.x + vDebugMenuSize.x - 20,0), 0);
		
		////////////////
		// Title
		OptionMenu_SectionTitle("Options_AccessibilityInput", kOptionsAccessibilityBgPos + cVector2f(40,-40), 1.f, mfTransitionAlpha);

		ImGui_SetTransCategory("Menu");
		
		mlCurrentItemId = mlFirstItemId;
		
		/////////////////
		// Physics Interaction Mode
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			int lValue = mpConfig.GetInt("Accessibility", "PhysicsInteractionMode", 0);
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsAccessibilityButtonPos, mlCurrentItemId, msSelectedAccessibilityInputButton, vOptions, lValue, false, mlActionHorizontal, "menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha, false, false, true, "", cString_To16Char(""), true, true);
			if (lNewValue != lValue)
			{
				mpConfig.SetInt("Accessibility", "PhysicsInteractionMode", lNewValue);
			}
			msSelectedAccessibilityInputButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedAccessibilityInputButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Sprint Mode
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			int lValue = mpConfig.GetInt("Accessibility", "SprintMode", 0);
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsAccessibilityButtonPos, mlCurrentItemId, msSelectedAccessibilityInputButton, vRunOptions, lValue, false, mlActionHorizontal, "menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha, false, false, true, "", cString_To16Char(""), true, true);
			if (lNewValue != lValue)
			{
				mpConfig.SetInt("Accessibility", "SprintMode", lNewValue);
			}
			msSelectedAccessibilityInputButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedAccessibilityInputButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Aim/Use Item Mode
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			int lValue = mpConfig.GetInt("Accessibility", "UseItemMode", 0);
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsAccessibilityButtonPos, mlCurrentItemId, msSelectedAccessibilityInputButton, vOptions, lValue, false, mlActionHorizontal, "menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha, false, false, true, "", cString_To16Char(""), true, true);
			if (lNewValue != lValue)
			{
				mpConfig.SetInt("Accessibility", "UseItemMode", lNewValue);
			}
			msSelectedAccessibilityInputButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedAccessibilityInputButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Reload weapon Mode
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			int lValue = mpConfig.GetInt("Accessibility", "ReloadWeaponMode", 0);
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsAccessibilityButtonPos, mlCurrentItemId, msSelectedAccessibilityInputButton, vOptions, lValue, false, mlActionHorizontal, "menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha, false, false, true, "", cString_To16Char(""), true, true);
			if (lNewValue != lValue)
			{
				mpConfig.SetInt("Accessibility", "ReloadWeaponMode", lNewValue);
			}
			msSelectedAccessibilityInputButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedAccessibilityInputButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Flashlight Mode
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			int lValue = mpConfig.GetInt("Accessibility", "ChargeFlashlightMode", 0);
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsAccessibilityButtonPos, mlCurrentItemId, msSelectedAccessibilityInputButton, vOptions, lValue, false, mlActionHorizontal, "menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha, false, false, true, "", cString_To16Char(""), true, true);
			if (lNewValue != lValue)
			{
				mpConfig.SetInt("Accessibility", "ChargeFlashlightMode", lNewValue);
			}
			msSelectedAccessibilityInputButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedAccessibilityInputButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Check health Mode
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			int lValue = mpConfig.GetInt("Accessibility", "CheckHealthMode", 0);
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsAccessibilityButtonPos, mlCurrentItemId, msSelectedAccessibilityInputButton, vOptions, lValue, false, mlActionHorizontal, "menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha, false, false, true, "", cString_To16Char(""), true, true);
			if (lNewValue != lValue)
			{
				mpConfig.SetInt("Accessibility", "CheckHealthMode", lNewValue);
			}
			msSelectedAccessibilityInputButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedAccessibilityInputButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Lean Mode
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			tString sTooltip = "LeanMode";
			if (cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()) sTooltip += "_Gamepad";
			sTooltip += "_Info";
			
			int lValue = mpConfig.GetInt("Accessibility", "LeanMode", 0);
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsAccessibilityButtonPos, mlCurrentItemId, msSelectedAccessibilityInputButton, vOptions, lValue, false, mlActionHorizontal, "menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha, false, false, true, sTooltip, cString_To16Char(""), true, true);
			if (lNewValue != lValue)
			{
				mpConfig.SetInt("Accessibility", "LeanMode", lNewValue);
			}
			msSelectedAccessibilityInputButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedAccessibilityInputButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Back
		{
			bool bButton = MainMenu_DoBackButton(msSelectedAccessibilityInputButton, mfTransitionAlpha);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				ApplySettings();
				
				if (ImGui_TimerExists("TransitionOut") == false)
					ImGui_AddTimer("TransitionOut", 10);
				
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				mTargetGroup = eMainMenuGroup_Options_Accessibility;
				msTargetFocus = msSelectedAccessibilityButton;

				/////////
				// Reset menu position
				if(bGamepad == false)
				{
					OptionMenu_ShowGamepadButtons(true);
					return;
				}
			}
			
			tString sID = cLux_GetInputHandler().GetGamepadWasLastDeviceUsed() ? vMenuItems[mlCurrentItemId-1] : "Back";
			msSelectedAccessibilityInputButton = OptionMenu_UpdateFocus(sID, msSelectedAccessibilityInputButton);
		}
		
		GuiHandleTransition(mTargetGroup, msTargetFocus);
		
		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
	}
	
	//------------------------------------------------------- 

	void GuiOptionsDebug()
	{
		GuiPauseDarkOverlay();
		
		///////////////////
		// Get strings and update size
		array<tString> vStartPositions;
		cLux_GetStartPositions(vStartPositions);
		array<tString> vMaps;
		cLux_GetConsoleMaps(vMaps);
		
		array<tString> vMenuItems = {"SCRIPT DEBUG","RELOAD", "PROFILER", "PROFILE EVERY 5 SEC", "PROFILER TYPE", "GAME SPEED", "MAPS", "LOAD MAP", "START POS", "TELEPORT", "TEST BUTTON", "PRESS TEST KEY"};
		
		if (cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false)
			vMenuItems.push_back("Back");
		
		for (int i=0; i<=vMenuItems.length()-1; i++)
		{
			OptionMenu_UpdateButtonWidth(vMenuItems[i]);
		}
		OptionMenu_UpdateToggleExtraWidth();
		OptionMenu_UpdateMultiSelectionExtraWidth(vMaps, "");
		OptionMenu_UpdateMultiSelectionExtraWidth(vStartPositions, "");
		OptionMenu_AlignExtraButtonWidth();
		
		cVector2f vDebugMenuPos = kOptionsDebugBgPos;
		cVector2f vDebugMenuSize = kOptionsDebugBgSize+cVector2f(gfOptionsMenu_ExtraWidth+gfOptionsMenu_ExtraWidth_MultiSelect,0);
		cVector2f vRightAnchor = cVector2f(vDebugMenuPos.x+vDebugMenuSize.x-40,0);
		
		DoBackground(vRightAnchor.x + 100);
		
		cVector3f vInfoBoxPos = OptionMenu_GetTopLeftOffset(cVector2f(vDebugMenuPos.x+vDebugMenuSize.x-60,0),0);
		
		////////////////
		// Title
		OptionMenu_SectionTitle("Options_Debug", kOptionsDebugBgPos + cVector2f(40,-40), 1.f, mfTransitionAlpha);

		ImGui_SetTransCategory("Menu");
		
		mlCurrentItemId = mlFirstItemId;
		
		/////////////////////////
		// Handles dynamic scrolling
		OptionMenu_SetOutOfLimit(vMenuItems.length());
		

		/////////////////
		// SCRIPT DEBUG
		ImGui_SetTransCategory("");
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDebugButtonPos, mlCurrentItemId, msSelectedDebugButton, cLux_ScriptDebugOn(), mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bNewValue != cLux_ScriptDebugOn())
			{
				cLux_SetScriptDebugOn(bNewValue);
			}
			msSelectedDebugButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDebugButton);
		}
		mlCurrentItemId++;


		/////////////////
		// Reload
		ImGui_SetTransCategory("");
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			if(OptionMenu_ButtonOptions(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDebugButtonPos, mlCurrentItemId, msSelectedDebugButton, true, vRightAnchor, vInfoBoxPos, mfTransitionAlpha))
			{
				cLux_ReloadGame();
				return;
			}
			msSelectedDebugButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDebugButton);	
		}
		mlCurrentItemId++;

		/////////////////
		// Profiler
		ImGui_SetTransCategory("");
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//cLux_AddDebugMessage("PROFILER");
			array<tString> vProfiler = { "OFF", "CPU", "GPU" };
			//////////////
			// Draw button and update config
			int lValue = cLux_GetProfilerActive();
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDebugButtonPos, mlCurrentItemId, msSelectedDebugButton, vProfiler, lValue, false, mlActionHorizontal, "", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(lValue != lNewValue)
			{
				cLux_SetProfilerActive(lNewValue);

				if(lNewValue == 0)
				{
					cLux_SetProfilerPauseInterval(0.0f);
					mbPauseProfiler = false;
				}
			}
			msSelectedDebugButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDebugButton);	
		}
		mlCurrentItemId++;
		
		/////////////////////////////////
		// Profiler Pause Every 5 Seconds
		ImGui_SetTransCategory("");
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//cLux_AddDebugMessage("PROFILER PAUSE");
			//////////////
			// Draw button and update config
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDebugButtonPos, mlCurrentItemId, msSelectedDebugButton, mbPauseProfiler, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bNewValue != mbPauseProfiler)
			{
				mbPauseProfiler = bNewValue;
				cLux_SetProfilerPauseInterval(mbPauseProfiler ? 5.0f : 0.0f);
			}
			msSelectedDebugButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDebugButton);	
		}
		mlCurrentItemId++;
		
		/////////////////
		// Profiler Filter
		ImGui_SetTransCategory("");
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//cLux_AddDebugMessage("PROFILER FILTER");
			array<tString> vFilter = { "Engine", "Game", "Render", "Variable", "Physics" };
			int lFilter = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDebugButtonPos, mlCurrentItemId, msSelectedDebugButton, vFilter, mlProfilerFilter, false, mlActionHorizontal, "", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			msSelectedDebugButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDebugButton);

			if(lFilter != mlProfilerFilter)
			{
				mlProfilerFilter = lFilter;

				switch(lFilter)
				{
				case 0: cLux_SetProfilerFilter("EngineLoop"); break;
				case 1: cLux_SetProfilerFilter("EngineLoop GameLoop"); break;
				case 2: cLux_SetProfilerFilter("EngineLoop RenderAll"); break;
				case 3: cLux_SetProfilerFilter("EngineLoop Variable"); break;
				case 4: cLux_SetProfilerFilter("EngineLoop GameLoop Message_PostUpdate HPL_Scene_PostUpdate Physics");
				}
			}
		}
		mlCurrentItemId++;
		
		/////////////////
		// Game speed
		ImGui_SetTransCategory("");
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//cLux_AddDebugMessage("GAME SPEED");
			array<tString> vSpeed = { "100%", "400%", "25%" };
			int lSpeed = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDebugButtonPos, mlCurrentItemId, msSelectedDebugButton, vSpeed, mlSpeed, false, mlActionHorizontal, "", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			msSelectedDebugButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDebugButton);	
			//cLux_AddDebugMessage(msSelectedDebugButton);

			if(lSpeed != mlSpeed)
			{
				mlSpeed = lSpeed;

				switch(lSpeed)
				{
				case 0: cLux_SetDebugGameSpeed(100); break;
				case 1: cLux_SetDebugGameSpeed(400); break;
				case 2: cLux_SetDebugGameSpeed(25); break;
				}
			}
		}
		mlCurrentItemId++;
		
		/////////////////
		// Maps
		ImGui_SetTransCategory("");
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{	
			//cLux_AddDebugMessage("MAPS");
			mlMap = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDebugButtonPos, mlCurrentItemId, msSelectedDebugButton, vMaps, mlMap, false, mlActionHorizontal, "", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			msSelectedDebugButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDebugButton);	
			//cLux_AddDebugMessage(msSelectedDebugButton);
		}
		mlCurrentItemId++;

		////////////////
		// Maps button
		ImGui_SetTransCategory("");
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{			
			//cLux_AddDebugMessage("MAPS BUTTON");
			if(OptionMenu_ButtonOptions(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDebugButtonPos, mlCurrentItemId, msSelectedDebugButton, true, vRightAnchor, vInfoBoxPos, mfTransitionAlpha))
			{
				Map_ChangeMap(vMaps[mlMap], "", "", "");
				SetMenuActive(false);
				cLux_ClearPlayedVoiceLines();
			}
		
			msSelectedDebugButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDebugButton);	
			//cLux_AddDebugMessage(msSelectedDebugButton);
		}
		mlCurrentItemId++;

		/////////////////
		// Start position
		ImGui_SetTransCategory("");
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{	
			//cLux_AddDebugMessage("START POS");
			mlStartPos = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDebugButtonPos, mlCurrentItemId, msSelectedDebugButton, vStartPositions, mlStartPos, false, mlActionHorizontal, "", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			msSelectedDebugButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDebugButton);	
			//cLux_AddDebugMessage(msSelectedDebugButton);
		}
		mlCurrentItemId++;

		////////////////
		// Start position button
		ImGui_SetTransCategory("");
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//cLux_AddDebugMessage("START POS BUTTON");
			if(OptionMenu_ButtonOptions(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDebugButtonPos, mlCurrentItemId, msSelectedDebugButton, true, vRightAnchor, vInfoBoxPos, mfTransitionAlpha))
			{
				cLux_TeleportToStartPos(vStartPositions[mlStartPos]);
			}
		
			msSelectedDebugButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDebugButton);	
			//cLux_AddDebugMessage(msSelectedDebugButton);
		}
		mlCurrentItemId++;

		///////////////////
		// Test button
		ImGui_SetTransCategory("");
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{	
			//cLux_AddDebugMessage("TEST BUTTON");
			array<tString> vTestButtons = { "Test0", "Test1", "Test2", "Test3", "Test4", "Test5", "Test6", "Test7", "Test8", "Test9" };
			mlTestButton = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDebugButtonPos, mlCurrentItemId, msSelectedDebugButton, vTestButtons, mlTestButton, false, mlActionHorizontal, "", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			msSelectedDebugButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDebugButton);	
		}
		mlCurrentItemId++;
		
		///////////////////
		// Press test button
		ImGui_SetTransCategory("");
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			if (OptionMenu_ButtonOptions(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDebugButtonPos, mlCurrentItemId, msSelectedDebugButton, true, vRightAnchor, vInfoBoxPos, mfTransitionAlpha))
			{
				cLux_RunTestButton(mlTestButton);
			}
			msSelectedDebugButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDebugButton);
		}
		if (cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false)
			mlCurrentItemId++;
			
		/////////////////
		// Back
		ImGui_SetTransCategory("Menu");
		{
			//cLux_AddDebugMessage("ID: "+mlDebugItemId+" - FIRST: "+mlFirstItemId);
			bool bButton = MainMenu_DoBackButton(msSelectedDebugButton, mfTransitionAlpha); 
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);
			if(bButton || bGamepad)
			{
				mlScrollMargin = 2;
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				mbScrolled = false;
				mbScrollDown = false;
				mbScrollUp = false;
				
				
				mTargetGroup = eMainMenuGroup_Options;
				msTargetFocus = msSelectedOptionsButton;
				
				if (ImGui_TimerExists("TransitionOut") == false)
						ImGui_AddTimer("TransitionOut", 10);

				////////
				// Reset menu pos
				if(bGamepad == false)
				{
					OptionMenu_ShowGamepadButtons(true);
					return;
				}
			}
			
			tString sID = cLux_GetInputHandler().GetGamepadWasLastDeviceUsed() ? vMenuItems[mlCurrentItemId] : "Back";
			msSelectedDebugButton = OptionMenu_UpdateFocus(sID, msSelectedDebugButton);
		}
		
		GuiHandleTransition(mTargetGroup, msTargetFocus);
		
		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
	}

	//------------------------------------------------------
	
	void GuiOptionsGamma()
	{
		array<tString> vSpeakerValuesPS4 = {"SmallTV", "MediumTV", "HomeCinema", "Headphones",  "NightMode"};
		array<tString> vSpeakerValuesXbox = {"SmallTV", "MediumTV", "HomeCinema", "Headphones", "NightMode"};
		array<tString> vSpeakerValues = Platform_IsPlayStation() ? vSpeakerValuesPS4 : vSpeakerValuesXbox;
		
		mlCurrentItemId = mlFirstItemId;
		
		bool bTestConsole = false;
		bool bStartingNewGame = mCurrentGroup == eMainMenuGroup_NewGame_Gamma;
		bool bShowAcceptButton = mbPremenuActive || bStartingNewGame;
		bool bIsConsole = Platform_IsConsole()||bTestConsole;
		bool bShowSpeakerButton = bIsConsole && mbPremenuActive;
		bool bShowBackButton = cLux_GetInputHandler().GetGamepadWasLastDeviceUsed()==false && mbPremenuActive==false;
		
		array<tString> vMenuItems = {"Gamma"};
		
		if (bShowSpeakerButton)
			vMenuItems.push_back("SpeakerType");
			
		if (bShowAcceptButton)
			vMenuItems.push_back("AcceptGamma");
			
		if (bShowBackButton)
			vMenuItems.push_back("Back");
			
		for (int i=0; i<vMenuItems.size(); i++)
		{
			OptionMenu_UpdateButtonWidth(vMenuItems[i]);
			//cLux_AddDebugMessage("Menu Item: " + vMenuItems[i]);
		}
		
		OptionMenu_AlignExtraButtonWidth();
		OptionMenu_UpdateToggleExtraWidth();
		
		OptionMenu_SetOutOfLimit(vMenuItems.size());
		
		float fAlpha = mbPremenuActive ? mfPreMenuFadeAmount : 1;
		bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);
		

		OptionMenu_SetModColor(cColor(1, fAlpha));
		
		cVector2f vSize =  ImGui_FullScreenSize();

		// 1024 = -30
		// 1479 = 140
		// 2056 = 340
		// 3299 = 775
		
		float x = vSize.x;
		
		// We shall never speak of this.
		// Last minute fixes for ultrawide. Alex and I spent
		// nearly a day trying to figure out the interplay
		// of all the various aspect ratio stuff going on
		// here, and failed utterly.
		// So I pushed a bunch of known good values into
		// an equation solver, and here we go! - IT
		float xOffset = ((0.0000000123f*(x-2056.0f) - 0.00002617f)*(x-1479.0f)+0.373f)*(x-1024.0f)-30.0f;

		/////////////////////////////////////
		// Reference Image
		cImGuiGfx gfx("gamma_background.tga", eImGuiGfx_Texture);
		cVector2f vBgSize = OptionMenu_GetScaledSize(cVector2f(1280, 720) * 0.6);
		cVector3f vBgPos = OptionMenu_GetCenterOffset(cVector2f(0), 5.2) - cVector3f(vBgSize.x * 0.5, vBgSize.y * 0.8, 0.0);
		
		ImGui_DrawGfx(gfx, vBgPos, vBgSize, cColor(1, fAlpha * mfTransitionAlpha));
		
		////////////////////////////////
		// Cover of the main menu elements with a dark gfx
		ImGui_DrawGfx(cImGuiGfx(), ImGui_FullScreenPos(0.1), ImGui_FullScreenSize(), cColor(0, fAlpha));
		
		////////////////////
		// Hack for Russian!
		bool bIsRussian = false;
		{
			cConfigFile@ pConfig = cLux_GetUserConfig();
			tString sLang = cString_SetFileExt(pConfig.GetString("Main", "StartLanguage", cLux_GetDefaultGameLanguage()), "");
			bIsRussian = (sLang=="russian");
		}
		
		////////////////
		// Setup variables
		cVector2f vDlgSize = cVector2f(824,125);
		cVector2f vDlgPos = cVector2f(100+xOffset,500);
		cVector2f vControlPos = vDlgPos;
		vControlPos.y -= 100;
		vControlPos.x += 75;
		cVector2f vSlidePos = vControlPos;
		vSlidePos.x += 650;
		cVector2f vPromptPos = vControlPos;
		vPromptPos.x-=50;
		vPromptPos.y+=50;
		cVector2f vPromptSize = vDlgSize;
		vPromptSize.x+=100;
		cVector2f vPadPromptPos = vDlgPos;
		vPadPromptPos.x-=75;
		vPadPromptPos.y-=475;

		///////////////////////////
		// Show current user
		OptionMenu_ShowCurrentUser(false);
		
		////////////////////
		// Hack for Russian!
		if (bIsRussian)
		{
			vDlgPos.x-=50;
			vDlgSize.x+=100;
			vControlPos.x-=50;
			vSlidePos.x += 125;
			vPromptPos.x-=50;
			vPromptSize.x+=100;
		}
		
		/////////////////////
		// Help text
		{
			cImGuiTextFrameData frameData;
			frameData.mFont.SetFile(FontHandler_GetFont(eFontType_MainMenu_InfoBox, 96) );
			frameData.mFont.mvSize = 22;
			frameData.mFont.mColor = gOptionMenu_ModColor * cColor(1,fAlpha * mfTransitionAlpha);
			frameData.mbUseBackgroundGfx = false;
			frameData.mFontAlign = eFontAlign_Left;

			ImGui_DoTextFrameExt("GammaInstructions0", cVector2f(0), 2.0, 0.0, frameData, OptionMenu_GetTopLeftOffset(vPromptPos, -10.0), vPromptSize);
		}
		
		int lY = 3;
		
		///////////////////////////
		// Gamma Slider
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			float fValue = (mpConfig.GetFloat("Screen", "Gamma", 1.0f) - 0.3f) / (2.0f - 0.6f);
			float fNewValue = OptionMenu_ButtonOptionsSlider("Gamma", vControlPos, lY++, msSelectedGammaButton, fValue, 0.05f, mlActionHorizontal, "", "", 
								vSlidePos, cVector3f_Zero, fAlpha * mfTransitionAlpha);

			if(fNewValue != fValue)
			{
				mpConfig.SetFloat("Screen", "Gamma", (fNewValue * (2.0f - 0.6f) + 0.3f));
				cGraphics_GetLowLevel().SetGammaCorrection((fNewValue * (2.0f - 0.6f) + 0.3f));
				mlOptionChanges++;
			}

			msSelectedGammaButton = OptionMenu_UpdateFocusCustom(vMenuItems, vMenuItems[mlCurrentItemId], msSelectedGammaButton);
			mlCurrentItemId++;
		}
		
		///////////////////////
		// Speaker type
		if (bShowSpeakerButton)
		{
			if(OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
			{
				OptionMenu_UpdateMultiSelectionExtraWidth(vSpeakerValues);
				OptionMenu_UpdateExtraButtonWidth_MultiSelection(vSpeakerValues);
				
				vDlgSize.y+=25.0f;
				vPadPromptPos.y-=25.0f;
				
				////////////////////////////////////////////
				// Draw multi select box and update config
				tString sValue = mpConfig.GetString("Sound", "SpeakerType", "HomeCinema");
				int lValue =-1;
				for(int i=0;i<vSpeakerValues.size(); ++i)
				{
					if(sValue == vSpeakerValues[i])
					{
						lValue = i;
						break;
					}
				}
				
				int lNewValue = OptionMenu_ButtonOptionsMultiSelect("SpeakerType", vControlPos, lY++, msSelectedGammaButton, vSpeakerValues, lValue, false, mlActionHorizontal, "Menu", 0, 
								vSlidePos, cVector3f_Zero, fAlpha*mfTransitionAlpha);
				
				if(lValue != lNewValue)
				{
					mpConfig.SetString("Sound", "SpeakerType", vSpeakerValues[lNewValue]);
					ApplySettings(false);
				}

				msSelectedGammaButton = OptionMenu_UpdateFocusCustom(vMenuItems, vMenuItems[mlCurrentItemId], msSelectedGammaButton);
			}
			
			mlCurrentItemId++;
		}
		

		//////////////////////////
		// Accept button
		if (bShowAcceptButton)
		{
			if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
			{
				bool bButton = OptionMenu_ButtonOptions("AcceptGamma", vControlPos, lY, msSelectedGammaButton, true, cVector2f_Zero, cVector3f_Zero, fAlpha * mfTransitionAlpha);
			
				if (bButton)
				{
					mlFirstItemId = 0;
					mlLastInFocus = 0;
					if(mbFirstGameStart)
					{
						/////////////////////////////////////
						// Hack to disable multiple btn clicks
						if (ImGui_TimerExists("FirstGameStartGammaSet")) return;
						ImGui_AddTimer("FirstGameStartGammaSet", 2);
						
						////////////////////////
						// Auto detect settings
						AutoDetectSettings(true);

						mTargetGroup = eMainMenuGroup_Main;
						msFocusNextFrame = msSelectedMainMenuButton;
						msTargetFocus = "NewGame";
						mfPreMenuFadeAmount = 1;
						mfPreMenuFadeDest = mfPreMenuFadeDestMin;
					}
					else if (bStartingNewGame)
					{
						mlLastInFocus = mlLastInFocus_SaveSlots;
						mTargetGroup = eMainMenuGroup_SaveSlotSelection;
						msTargetFocus = msSelectedSaveSlotButton;
					}

					ApplySettings();
				}
						
				msSelectedGammaButton = OptionMenu_UpdateFocusCustom(vMenuItems, vMenuItems[mlCurrentItemId], msSelectedGammaButton);
			}
			
			mlCurrentItemId++;
		}
		
		/////////////////
		// Back Btn
		if ( (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false && bShowBackButton) || bGamepad)
		{
			bool bButton = MainMenu_DoBackButton(msSelectedGammaButton, mfTransitionAlpha); 
			if(bButton || bGamepad)
			{
				if(mlOptionChanges == mlCurrentOptionChange)
				{
					mlFirstItemId = 0;
					mlLastInFocus = 0;
					
					//////////////////
					// We're staring a new game
					if (bStartingNewGame)
					{
						mTargetGroup = eMainMenuGroup_GameModes;
						msTargetFocus = msSelectedGameModesBtn;
					}
					///////////////
					// Other places we set gamma
					else
					{
						mTargetGroup = mbMainMenuActive ? eMainMenuGroup_Main : eMainMenuGroup_Options;
						msTargetFocus = mbMainMenuActive ? msSelectedMainMenuButton : msSelectedOptionsButton;
					}
					
					if (ImGui_TimerExists("TransitionOut") == false)
						ImGui_AddTimer("TransitionOut",10.f);
				}
				
				///////////////////////
				// Show apply popup
				else
				{
					mbShowApplyChanges = true;
					msFocusNextFrame = "No";
				}
				
				mbShowingGammaMenu = false;
			}
			
			tString sBtnID = cLux_GetInputHandler().GetGamepadWasLastDeviceUsed() ? "AcceptGamma" : "Back";
			msSelectedGammaButton = OptionMenu_UpdateFocus(sBtnID, msSelectedGammaButton);
		}
		
		//cLux_AddDebugMessage("msSelectedGammaButton " + msSelectedGammaButton);

		//////////////////////////
		// Show gamepad legacy
		if (mbShowApplyChanges == false)
			OptionMenu_ShowGamepadButtons(true, true, cVector2f_Zero, bShowAcceptButton);
		
		if (mbPremenuActive == false && mbShowApplyChanges == false)
			GuiHandleTransition(mTargetGroup, msTargetFocus);
		
		OptionMenu_SetModColor(cColor(1, 1));
	}
	
	//-------------------------------------------------------

	uint mlInvalidModIndex = uint(-1);

	eLuxModContentType mCurrentEntryDisplay = eLuxModContentType_StandAlone;

	array<tString> mvModProviderIcons;

	cScriptUIntUIntMap m_mapIDToDownloadingEntryIndex;
	array<uint32> mvDownloadingEntryIDs;
	array<tString> mvDownloadingEntryNames;
	//array<tWString> mvDownloadingEntryDescriptions;

	array<cModEntryListState> mvModEntryListStates;

	cScriptUIntUIntMap m_mapIDToModIndex;
	array<uint32> mvModIDs;
	array<tString> mvModNames;
	array<tWString> mvModAuthors;
	array<tString> mvModPics;
	
	cScriptUIntUIntMap m_mapIDToAddOnIndex;
	array<uint32> mvAddOnIDs;
	array<tString> mvAddOnNames;
	array<tWString> mvAddOnAuthors;
	array<tString> mvAddOnPics;
	
	int mlEntryOffset = 0;
	int mlModEntryOffset = 0;
	int mlSelectedModEntry=0;
	bool mbScrollingModsList = false;

	int mlModEntryToLoad=0;

	//int mlFocusedModEntryIndex = -1;

	uint32 mlSelectedStandAloneModID = uint32(-1);
	cScriptUIntSet m_setSelectedAddOnIDs;
	
	bool mbShowSelectedModDialog = false;
	
	//-------------------------------------------------------

	bool RemoveModDownload(uint alID)
	{
		uint lIndex = m_mapIDToDownloadingEntryIndex.Get(alID, mlInvalidModIndex);
		if(lIndex == mlInvalidModIndex)
			return false;

		m_mapIDToDownloadingEntryIndex.Erase(alID);
		mvDownloadingEntryIDs.erase(lIndex);
		mvDownloadingEntryNames.erase(lIndex);

		return true;
	}
	bool RemoveStandAloneMod(uint alID)
	{
		uint lIndex = m_mapIDToModIndex.Get(alID, mlInvalidModIndex);
		if(lIndex == mlInvalidModIndex)
			return false;
	
		mvModIDs.erase(lIndex);
		mvModNames.erase(lIndex);
		mvModAuthors.erase(lIndex);
		mvModPics.erase(lIndex);

		m_mapIDToModIndex.Erase(alID);

		return true;
	}
	bool RemoveAddOnMod(uint alID)
	{
		uint lIndex = m_mapIDToAddOnIndex.Get(alID, mlInvalidModIndex);
		if(lIndex == mlInvalidModIndex)
			return false;
	
		mvAddOnIDs.erase(lIndex);
		mvAddOnNames.erase(lIndex);
		mvAddOnAuthors.erase(lIndex);
		mvAddOnPics.erase(lIndex);

		m_mapIDToAddOnIndex.Erase(alID);

		return true;
	}

	//-------------------------------------------------------

	void PrepareModEntries()
	{
		if(mvModProviderIcons.size()==0)
		{
			for(int i=0; i<cLux_GetModHandler().GetProviderNum(); ++i)
			{
				mvModProviderIcons.push_back("mod_providericon_" + cLux_GetModHandler().GetProviderName(i) + ".png");
			}
		}

		if(mvModEntryListStates.size()==0)
		{
			for(int i=0; i<eLuxModContentType_LastEnum; ++i)
			{
				cModEntryListState state;
				state.mlFirstVisibleEntryIndex = 0;
				state.mlFocusedEntryRelativeIndex = -1;

				mvModEntryListStates.push_back(state);
			}
		}

		//////////////////////////////////////////////////////////////////
		// HANDLE MOD LISTING CHANGES
		bool bRebuildModList = false;
		bool bRebuildDownloadIndexMap = false;
		bool bRebuildStandAloneIndexMap = false;
		bool bRebuildAddOnIndexMap = false;
		//bRebuildModList = true;

		bool bPostMessageBox = cLux_GetModHandler().HasNextListEvent();
		
		while(cLux_GetModHandler().HasNextListEvent())
		{
			eLuxModEntryListEventType eventType;
			array<uint32> vEntryIDs;
			uint lIndex;
			uint lInvalidIndex = uint(-1);
			uint lID;
			
			cLux_GetModHandler().NextListEvent(eventType, vEntryIDs);
			
			// array<tString> vEventType;
			// vEventType.resize(5);
			// vEventType[eLuxModEntryListEventType_EntriesAdded] = "EntriesAdded";
			// vEventType[eLuxModEntryListEventType_EntriesRemoved] = "EntriesRemoved";
			// vEventType[eLuxModEntryListEventType_EntriesFetchedDetails] = "EntriesFetchedDetails";
			// vEventType[eLuxModEntryListEventType_EntriesStartedDownloading] = "EntriesStartedDownloading";
			// vEventType[eLuxModEntryListEventType_EntriesFinishedDownloading] = "EntriesFinishedDownloading";
			
			// tString sMsg = "List event - type: " + vEventType[eventType] + " - entries: " + vEntryIDs.size();
			// cLux_AddDebugMessage(sMsg);
			if(eventType==eLuxModEntryListEventType_EntriesStartedDownloading)
			{
				for(uint32 i = 0; i < vEntryIDs.size(); ++i)
				{
					lID = vEntryIDs[i];

					m_mapIDToDownloadingEntryIndex.Set(lID, mvDownloadingEntryIDs.size());

					mvDownloadingEntryIDs.push_back(lID);
					mvDownloadingEntryNames.push_back("");
				}
			}
			else if(eventType == eLuxModEntryListEventType_EntriesFinishedDownloading)
			{
				for(uint32 i = 0; i < vEntryIDs.size(); ++i)
				{
					lID = vEntryIDs[i];
					
					bRebuildDownloadIndexMap = RemoveModDownload(lID) || bRebuildDownloadIndexMap;
				}
			}
			else if(eventType==eLuxModEntryListEventType_EntriesFetchedDetails)
			{
				tString sName;
				eLuxModContentType type;

				for(uint32 i = 0; i < vEntryIDs.size(); ++i)
				{
					lID = vEntryIDs[i];

					lIndex = m_mapIDToDownloadingEntryIndex.Get(lID, lInvalidIndex);
					if(lIndex == lInvalidIndex)
						continue;

					if(cLux_GetModHandler().GetModDownloadDetails(mvDownloadingEntryIDs[lIndex], type, sName))
						mvDownloadingEntryNames[lIndex] = sName;
				}
			}
			else if(eventType==eLuxModEntryListEventType_EntriesRemoved)
			{
				for(uint32 i = 0; i<vEntryIDs.size(); ++i)
				{
					bool bFound = false;
					lID = vEntryIDs[i];
					
					bRebuildDownloadIndexMap = RemoveModDownload(lID) || bRebuildDownloadIndexMap;
					
					bFound = RemoveStandAloneMod(lID);
					bRebuildStandAloneIndexMap = bFound || bRebuildStandAloneIndexMap;
					
					if(bFound == false)
					{
						bFound = RemoveAddOnMod(lID);
						bRebuildAddOnIndexMap = bFound || bRebuildAddOnIndexMap;
					}
				}
			}
			else
			{
				bRebuildModList = true;
			}
		}
		
		if(bRebuildModList)
		{
			cLux_AddDebugMessage("Rebuilding mod list: ");
			
			mvModIDs.resize(0);
			mvModNames.resize(0);
			mvModAuthors.resize(0);
			mvModPics.resize(0);
			m_mapIDToModIndex.Clear();
			bRebuildStandAloneIndexMap = true;

			cLux_GetModHandler().GetModEntriesByName(eLuxModContentType_StandAlone, mvModIDs, mvModNames, mvModAuthors, mvModPics);

			mvModIDs.insertAt(0, uint(-1));
			mvModNames.insertAt(0, "Amnesia: The Bunker");
			mvModAuthors.insertAt(0, tWString("Frictional Games"));
			mvModPics.insertAt(0, "default_story_image.png");

			cLux_AddDebugMessage("Standalone: ");
			for(uint i =0; i<mvModIDs.size(); ++i)
			{
				cLux_AddDebugMessage("("+i+") " + mvModNames[i] + " ("+ mvModIDs[i] + ")");
			}


			mvAddOnIDs.resize(0);
			mvAddOnNames.resize(0);
			mvAddOnAuthors.resize(0);
			mvAddOnPics.resize(0);
			m_mapIDToAddOnIndex.Clear();
			bRebuildAddOnIndexMap = true;

			cLux_GetModHandler().GetModEntriesByName(eLuxModContentType_AddOn, mvAddOnIDs, mvAddOnNames, mvAddOnAuthors, mvAddOnPics);

			cLux_AddDebugMessage("AddOn: ");
			for(uint i =0; i<mvAddOnIDs.size(); ++i)
			{
				cLux_AddDebugMessage("("+i+") " + mvAddOnNames[i] + " ("+ mvAddOnIDs[i] + ")");
			}
		}

		if(bRebuildDownloadIndexMap)
		{
			for(uint i =0; i<mvDownloadingEntryIDs.size(); ++i)
			{
				m_mapIDToDownloadingEntryIndex.Set(mvDownloadingEntryIDs[i], i);
			}			
		}
		if(bRebuildStandAloneIndexMap)
		{
			for(uint i =0; i<mvModIDs.size(); ++i)
			{
				m_mapIDToModIndex.Set(mvModIDs[i], i);
			}
		}
		if(bRebuildAddOnIndexMap)
		{
			for(uint i =0; i<mvAddOnIDs.size(); ++i)
			{
				m_mapIDToAddOnIndex.Set(mvAddOnIDs[i], i);
			}
		}

		
	}
	
	//----------------------------------------------------------------------------------
	
	bool mbModListFocusChanged = false;
	bool mbModListVisibleItemsChanged = false;

	funcdef void ModEntryProcessorFunc(cScrMenuHandler @apMenuHandler, cModEntryListState @apListState, bool abMouseDown, int alIndex, const cVector2f &in avPos, bool &out abOutFocused, bool &out abOutSelected, tString &out asOutSelectedBtn, array<tString> @avOutFocusableItems);
	
	void GuiCustomStories_DoEntryList(eLuxModContentType aType, eImGuiAction aListScrollAction, bool abMouseDown, bool abIsUsingGamepad, bool abDrawWorkshopBtn, int alVisibleItems, tString &out asOutSelectedBtn, array<tString> @avOutFocusableItems)
	{
		if(aType == eLuxModContentType_LastEnum)
			return;

		// Mod List Frame
		cImGuiGfx gfxModListFrame = cImGuiGfx("startmenu_frame_load.tga", eImGuiGfx_Texture);
		gfxModListFrame.mColor = cColor(1,mfTransitionAlpha);
		cVector2f vModListFramePos = kModsBgPos + cVector2f(40, 70);
		cVector2f vModListFrameSize = cVector2f(kModsBgSize.x * 0.47, kModsBgSize.y * 0.655);
		//ImGui_DrawGfx(gfxModListFrame, OptionMenu_GetTopLeftOffset(vModListFramePos, 0.5f), OptionMenu_GetScaledSize(vModListFrameSize));
		
		DoBackground(kModsBgPos.x + kModsBgSize.x + 400);

		cVector2f vModListPos = vModListFramePos + cVector2f(70, 50);

		//////////////////////////////////////////////////////////////////
		// Draw mod entries
		//int lFirstVisibleIndex = bStandAlone? mlFirstVisibleStandAloneModIndex : mlFirstVisibleAddOnModIndex;
				
		// Downloading Mods
		// int lDownloadModsOffset = mlModEntryOffset;
		// for(int i = lDownloadModsOffset; (i < mvDownloadingEntryIDs.size()) && (lItemIndex < lMaxItems); ++i)
		// {
		// 	ImGui_SetTransCategory("");
		// 	const bool bSelected = (lItemIndex == mlSelectedModEntry);
		// 	const cVector2f vElemPos = kModsBgPos + cVector2f(65, 100 + (kModsSlotsSpacing * lItemIndex));
		// 	const float fDownloadProgress = cLux_GetModHandler().GetDownloadProgress(mvDownloadingEntryIDs[i]);
			
		// 	OptionMenu_ButtonMod(sItemNameBase + cString_ToString(lItemIndex), mvDownloadingEntryNames[i], vElemPos, bSelected, "", mfTransitionAlpha, true, fDownloadProgress);
			
		// 	if (bMouseDown==false && ImGui_PrevInFocus())
		// 		mlSelectedModEntry = lItemIndex; 

		// 	lItemIndex++;
		// }

		//if(mvDownloadingEntryIDs.size()>0)
		//{
		//	float fProgress = cLux_GetModHandler().GetDownloadProgress(mvDownloadingEntryIDs[0]);
		//	ImGui_DoGauge(cImGuiGaugeData(), fProgress, OptionMenu_GetTopLeftOffset(vModListFramePos + vModListFrameSize, 100), cVector2f(100, 20));
		//}
		//for(int i = 0; (i < mvDownloadingEntryIDs.size()) ); ++i)
		// 
		// 	ImGui_SetTransCategory("");
		// 	const bool bSelected = (lItemIndex == mlSelectedModEntry);
		// 	const cVector2f vElemPos = kModsBgPos + cVector2f(65, 100 + (kModsSlotsSpacing * lItemIndex));
		// 	const float fDownloadProgress = cLux_GetModHandler().GetDownloadProgress(mvDownloadingEntryIDs[i]);
			
		// 	OptionMenu_ButtonMod(sItemNameBase + cString_ToString(lItemIndex), mvDownloadingEntryNames[i], vElemPos, bSelected, "", mfTransitionAlpha, true, fDownloadProgress);
			
		// 	if (bMouseDown==false && ImGui_PrevInFocus())
		// 		mlSelectedModEntry = lItemIndex; 

		// 	lItemIndex++;
		// }

		ImGui_SetTransCategory("");

		cModEntryListState @pListState = mvModEntryListStates[aType];

		int lOldFocusedItemIndex = pListState.mlFocusedEntryRelativeIndex;
		int lOldFirstVisibleItemIndex = pListState.mlFirstVisibleEntryIndex;

		ModEntryProcessorFunc @pEntryFunc = null;
		
		if(aType == eLuxModContentType_StandAlone)
		{
			pListState.mlListSize = mvModIDs.size();
			@pEntryFunc = function(apMenuHandler, apScrollState, abMouseDown, alRelativeIndex, avPos, abOutFocused, abOutSelected, asOutSelectedBtn, avOutFocusableItems)
			{
				int lItemIndex = apScrollState.mlFirstVisibleEntryIndex + alRelativeIndex;

				uint32 lEntryID = apMenuHandler.mvModIDs[lItemIndex];
				tString sName = apMenuHandler.mvModNames[lItemIndex];

				tString sItemID = "Mod" + lEntryID;
				avOutFocusableItems.push_back(sItemID);

				bool bFocused = alRelativeIndex == apScrollState.mlFocusedEntryRelativeIndex - 1;

				if (OptionMenu_ButtonModStandAlone(lEntryID, sName, avPos, bFocused, apMenuHandler.mvModProviderIcons, apMenuHandler.mfTransitionAlpha, apMenuHandler.mlSelectedStandAloneModID == lEntryID))
				{
					apMenuHandler.mlSelectedStandAloneModID = lEntryID;
					//apMenuHandler.mbShowSelectedModDialog = true;
					//apMenuHandler.msMessageBoxFocus = "No";
					//apMenuHandler.msFocusNextFrame="No";
					//cLux_AddDebugMessage("mlModEntryToLoad: " + mlModEntryToLoad);

					abOutSelected = true;
				}				
				
				if (ImGui_PrevInFocus())
				{
					abOutFocused = true;
					apScrollState.mlFocusedEntryRelativeIndex = alRelativeIndex + 1;
					asOutSelectedBtn = sItemID;
				}
			};
		}
		else
		{
			pListState.mlListSize = mvAddOnIDs.size();
			@pEntryFunc = function(apMenuHandler, apScrollState, abMouseDown, alRelativeIndex, avPos, abOutFocused, abOutSelected, asOutSelectedBtn, avOutFocusableItems)
			{
				uint32 lEntryID = apMenuHandler.mvAddOnIDs[apScrollState.mlFirstVisibleEntryIndex + alRelativeIndex];
				tString sName = apMenuHandler.mvAddOnNames[apScrollState.mlFirstVisibleEntryIndex + alRelativeIndex];

				tString sItemID = "Mod" + lEntryID;
				avOutFocusableItems.push_back(sItemID);

				bool bFocused = alRelativeIndex == apScrollState.mlFocusedEntryRelativeIndex - 1;
				bool bAddOnSelected = apMenuHandler.m_setSelectedAddOnIDs.Exists(lEntryID);

				if (OptionMenu_ButtonModAddOn(lEntryID, sName, avPos, bFocused, bAddOnSelected, apMenuHandler.mvModProviderIcons, apMenuHandler.mfTransitionAlpha))
				{
					if(bAddOnSelected)
					{
						apMenuHandler.m_setSelectedAddOnIDs.Erase(lEntryID);
					}
					else
					{
						apMenuHandler.m_setSelectedAddOnIDs.Add(lEntryID);
					}
					abOutSelected = true;
				}
				
				if (ImGui_PrevInFocus())
				{
					abOutFocused = true;
					apScrollState.mlFocusedEntryRelativeIndex = alRelativeIndex + 1;
					asOutSelectedBtn = sItemID;
				}
			};
		}

		//////////////////////////////////////////
		// Display items
		int lBottomListFirstVisibleItemIndex = pListState.mlListSize - alVisibleItems;
		
		ImGui_SetTransCategory("");
		bool bFocusedAnyEntry = false;
		{
			int i;
			for(i = 0; pListState.mlFirstVisibleEntryIndex + i < pListState.mlListSize && i<alVisibleItems; ++i)
			{
				cVector2f vElemPos = vModListPos + cVector2f(0, (kModsSlotsSpacing * i));
				
				bool bFocused = false;
				bool bSelected = false;
				tString sOutSelectedButton;
				pEntryFunc(this, pListState, abMouseDown, i, vElemPos, bFocused, bSelected, sOutSelectedButton, avOutFocusableItems);
				
				if (bFocused)
				{
					bFocusedAnyEntry = true;
					
					if (msSelectedModButton != sOutSelectedButton)
					{
						Sound_PlayGui("special_fx/frontend/frontend_menu_focus", 1.0f, eSoundEntryType_Gui);
						msSelectedModButton = sOutSelectedButton;
					}
				}
			}
			pListState.mlLastVisibleEntryIndex = pListState.mlFirstVisibleEntryIndex + i - 1;
		}
			
		//////////////////////////////////////////////////////////////////
		// SCROLL BAR
		bool bShowingScrollBar = false;
		const cVector2f vModsScrollPos = vModListPos + cVector2f(385, 0);	
		const cVector2f vModsScrollSize = cVector2f(12, vModListFrameSize.y);
		
		if(pListState.mlListSize > alVisibleItems)
		{
			bShowingScrollBar = true;
			
			// Update input
			float fItems = pListState.mlListSize;
			
			const float fPadding = mbScrollingModsList ? 1000 : 5;
			float fMouseScrollY = OptionMenu_GetMouseInside(vModsScrollPos - cVector2f(fPadding, 0), vModsScrollPos + vModsScrollSize + cVector2f(fPadding, 0)).y;
			
			// Mouse touching scroll, check if button pressed
			if(fMouseScrollY != -1.0 && abMouseDown)
			{
				pListState.mlFirstVisibleEntryIndex = cMath_RoundToInt((fItems-alVisibleItems) * fMouseScrollY);
				mbScrollingModsList = true;
			}

			if(abMouseDown == false)
			{
				// Stopped scrolling
				mbScrollingModsList = false;
			}

			
			pListState.mlFirstVisibleEntryIndex = cMath_Clamp(pListState.mlFirstVisibleEntryIndex, 0, pListState.mlListSize - alVisibleItems);
			if(pListState.mlFocusedEntryRelativeIndex >= 0 && pListState.mlFocusedEntryRelativeIndex < alVisibleItems && (pListState.mlFirstVisibleEntryIndex - lOldFirstVisibleItemIndex) != 0)
			{
				const int lDiff = (pListState.mlFirstVisibleEntryIndex - lOldFirstVisibleItemIndex);
				pListState.mlFocusedEntryRelativeIndex = cMath_Clamp(pListState.mlFocusedEntryRelativeIndex - lDiff, 0, 9);
			}

			//const float fScaleY = 1.0 - (fItems - alVisibleItems) / fItems;
			const float fScaleY =  fItems > alVisibleItems? alVisibleItems / fItems : 1.0f;
			float fPosY = 0;
			if (fItems > alVisibleItems)
				fPosY = pListState.mlFirstVisibleEntryIndex / (fItems-alVisibleItems);
			
			const cColor scrollBarColor = cColor(1, mfTransitionAlpha * 0.8);
			const cVector2f vScrollBarSize = OptionMenu_GetScaledSize(vModsScrollSize * cVector2f(1, fScaleY));
			const cVector3f vScrollBarPos = OptionMenu_GetTopLeftOffset(vModsScrollPos + vModsScrollSize * cVector2f(0, (1.0 - fScaleY) * fPosY), 0.01);
			
			cImGuiGfx gfxScrollBar = cImGuiGfx("startmenu_scrollbar.tga", eImGuiGfx_Texture);
			ImGui_DrawGfx(gfxScrollBar, vScrollBarPos, vScrollBarSize, scrollBarColor);
		}
		
		cImGuiGfx gfxScrollBarBg;
		float fScrollBarBgOffsetX = bShowingScrollBar? -4.f : 6.f;
		ImGui_DrawGfx(gfxScrollBarBg, OptionMenu_GetTopLeftOffset(vModsScrollPos + cVector2f(fScrollBarBgOffsetX, 0)), OptionMenu_GetScaledSize(cVector2f(1, vModsScrollSize.y)), cColor(1, mfTransitionAlpha) * gOptionMenu_ModColor);
		
		if (bShowingScrollBar)
			ImGui_DrawGfx(gfxScrollBarBg, OptionMenu_GetTopLeftOffset(vModsScrollPos + cVector2f(16, 0)), OptionMenu_GetScaledSize(cVector2f(1, vModsScrollSize.y)), cColor(1, mfTransitionAlpha) * gOptionMenu_ModColor);
	}

	//-----------------------------------------

	void GuiCustomStories_DoModDetails(eLuxModContentType aType, int alIndex)
	{
		if(aType == eLuxModContentType_LastEnum)
			return;

		cVector2f vModDetailsFramePos = kModsBgPos + cVector2f(520, 125);
		
		//////////////////////////////////////////////////////////////////
		// MOD IMG
		const cVector2f vModImgPos = vModDetailsFramePos;
		const float fModImgHeight = kModsBgSize.y * 0.356;
		const cVector2f vModImgSize = OptionMenu_GetScaledSize(cVector2f(fModImgHeight * 16/9, fModImgHeight) * 0.88 * 0.85);

		array<uint32> @vContentIDs;
		array<tString> @vContentNames;
		array<tWString> @vContentAuthors;
		array<tString> @vContentPics;

		switch(aType)
		{
		case eLuxModContentType_StandAlone:
			@vContentIDs = mvModIDs;
			@vContentNames = mvModNames;
			@vContentAuthors = mvModAuthors;
			@vContentPics = mvModPics;
			break;
		case eLuxModContentType_AddOn:
			@vContentIDs = mvAddOnIDs;
			@vContentNames = mvAddOnNames;
			@vContentAuthors = mvAddOnAuthors;
			@vContentPics = mvAddOnPics;
			break;
		}

		// Mod Img
		if(vContentPics[alIndex]!="")
		{
			cImGuiGfx gfxModPic = cImGuiGfx(vContentPics[alIndex], eImGuiGfx_Texture);
			cImGuiGfx gfxModPicFrame("simple_white.dds", eImGuiGfx_Texture);
			cVector3f vModPicPos = OptionMenu_GetTopLeftOffset(vModImgPos + cVector2f(5,2), 0.5);
			gfxModPic.mColor = cColor(1,mfTransitionAlpha);		
			gfxModPicFrame.mColor = cColor(0.75f, mfTransitionAlpha);
			
			float fFrameBorderSize = 3.f;
			ImGui_DoImage(gfxModPicFrame, vModPicPos, vModImgSize + cVector2f(fFrameBorderSize * 2.f));			
			ImGui_DoImage(gfxModPic, vModPicPos + cVector3f(fFrameBorderSize, fFrameBorderSize, 0.1f), vModImgSize);			
		}
		
		//////////////////////////////////////////////////////////////////
		// MOD DESC
		cVector2f vModDescFramePos = vModDetailsFramePos + cVector2f(0, vModImgSize.y + 10);
		
		ImGui_LayoutBegin(eImGuiLayout_X);
		{
			cImGuiLabelData labelData;
			labelData.mFont.SetFile(FontHandler_GetFont(eFontType_MainMenu, 56));
			labelData.mFont.mvSize = 18;// cVector2f(28, 28);
			labelData.mFont.mColor = gOptionMenu_ModColor*cColor(1, mfTransitionAlpha);
			labelData.mFontAlign = eFontAlign_Right;
			cVector2f vAuthorLabelPos = vModDescFramePos + cVector2f(10, 5);
			ImGui_SetTransCategory("ModMenu");
			ImGui_DoLabelExt("ByAuthor", labelData, OptionMenu_GetTopLeftOffset(vAuthorLabelPos, 0.5));
			ImGui_SetTransCategory("");
			ImGui_DoLabelExt(": " + cString_To8Char(vContentAuthors[alIndex]), labelData, OptionMenu_GetTopLeftOffset(vAuthorLabelPos, 0.5));
		}
		ImGui_LayoutEnd();
			
		////////////////
		// Description
		ImGui_SetTransCategory("ModDescriptions");
		cImGuiTextFrameData txtData;
		txtData.mbUseBackgroundGfx = false;
		txtData.mFont.SetFile(FontHandler_GetFont(eFontType_MainMenu, 56));
		txtData.mFont.mvSize = cVector2f(19);
		txtData.mFont.mColor = gOptionMenu_ModColor * cColor(1, mfTransitionAlpha);
		cVector2f vTxtFramePos =  vModDescFramePos + cVector2f(10, 40);
		cVector2f vModDescSize = cVector2f(kModsBgSize.x * 0.68f, kModsBgSize.y * 0.27);
		tString sDescTxt = "" + vContentIDs[alIndex];
		ImGui_DoTextFrameExt(sDescTxt, cVector2f(0), 0.f, 0.f, txtData, OptionMenu_GetTopLeftOffset(vTxtFramePos, 0.5), OptionMenu_GetScaledSize(vModDescSize));
	}

	//-----------------------------------------

	void GuiCustomStories_V2()
	{
		mbBackgroundShowTitle = false;
		bool bIsUsingGamepad = cLux_GetInputHandler().GetGamepadWasLastDeviceUsed();
		bool bIsUsingKeys = cLux_GetInputHandler().GetLastDeviceUsed()==eInputDeviceType_Keyboard;
		bool bDrawWorkshopBtn = cLux_GetModHandler().GetProviderIsAvailable("SteamWorkshop");
		
		//////////////////////////////////////////////////////////////////
		// Title
		//OptionMenu_SectionTitle("Mods", kLoadBgPos, 1.f);
		OptionMenu_SectionTitle("Mods", kModsBgPos + cVector2f(100,10), 1.f, mfTransitionAlpha);
		
		PrepareModEntries();
		
		tString sItemNameBase = "Mod";
		bool bDismissPageOnReturn = false;
		
		cModEntryListState @pListState = mvModEntryListStates[mCurrentEntryDisplay];

		int lOldFocusedItemIndex = pListState.mlFocusedEntryRelativeIndex;
		int lOldFirstVisibleItemIndex = pListState.mlFirstVisibleEntryIndex;

		//////////////////////////////////////////////////////////////////
		// HANDLE INPUT
		eImGuiAction listScrollAction = eImGuiAction_LastEnum;
		int lActionVertical = 0;
		const int lMaxItems = kMaxModsToShow;
		bool bMouseDown = false;
		bool bUsingKeys = false;
		int lLastModEntryIndex = -1;
		
		if(mbShowSelectedModDialog == false)
		{
			// Only catch input if confirmation popup is not visible
			if(ImGui_ActionTriggered(eImGuiAction_Down, true)) 
			{
				listScrollAction = eImGuiAction_Down;
			}
			if(ImGui_ActionTriggered(eImGuiAction_Up, true)) 
			{
				listScrollAction = eImGuiAction_Up;
			}
			
			if(ImGui_ActionTriggered(eImGuiAction_ScrollDown, true))
			{
				listScrollAction = eImGuiAction_ScrollDown;
			}
			
			if(ImGui_ActionTriggered(eImGuiAction_ScrollUp, true))
			{
				listScrollAction = eImGuiAction_ScrollUp;
			}

			if(ImGui_ActionTriggered(eImGuiAction_Left, false) && mCurrentEntryDisplay != eLuxModContentType_StandAlone)
			{
				mCurrentEntryDisplay = eLuxModContentType_StandAlone;
				mvModEntryListStates[eLuxModContentType_StandAlone].mlFocusedEntryRelativeIndex = 0;
				mvModEntryListStates[eLuxModContentType_AddOn].mlFocusedEntryRelativeIndex = 0;
				
				Sound_PlayGui("special_fx/frontend/frontend_menu_select", 1.0f, eSoundEntryType_Gui); 
				
				cLux_AddDebugMessage("Displaying stories");
			}

			if(ImGui_ActionTriggered(eImGuiAction_Right, false) && mCurrentEntryDisplay != eLuxModContentType_AddOn)
			{
				mCurrentEntryDisplay = eLuxModContentType_AddOn;
				mvModEntryListStates[eLuxModContentType_StandAlone].mlFocusedEntryRelativeIndex = 0;
				mvModEntryListStates[eLuxModContentType_AddOn].mlFocusedEntryRelativeIndex = 0;
				
				Sound_PlayGui("special_fx/frontend/frontend_menu_select", 1.0f, eSoundEntryType_Gui); 
				
				cLux_AddDebugMessage("Displaying add ons");
			}
				
			bMouseDown = ImGui_ActionIsDown(eImGuiAction_MouseLeft, false);
		}
		
		ImGui_SetAlignment(eImGuiAlign_TopLeft);

		tString sSelectedBtn;
		array<tString> vFocusableItems;
		
		//////////////////////////////////////////////////////////////////
		// HEADERS
		ImGui_SetTransCategory("ModMenu");
		
		vFocusableItems.push_back("ModHeaderButton");
		
		if(pListState.mlFocusedEntryRelativeIndex == vFocusableItems.size()-1)
		{
			sSelectedBtn = vFocusableItems[pListState.mlFocusedEntryRelativeIndex];
		}
		
		ImGui_LayoutBegin(eImGuiLayout_X, OptionMenu_GetTopLeftOffset(kModsBgPos + cVector2f(110, 70), 1.5f), cVector2f_MinusOne, cVector2f(20, 0));
		{	
			cImGuiButtonData headerButtonData = ImGui_GetDefaultButton();
			headerButtonData.mbUseBackgroundGfx = false;
			headerButtonData.mbUseInFocusColor = false;
			headerButtonData.mbUseTriggeredGfx = false;
			headerButtonData.mbUseInFocusGfx = false;
			headerButtonData.mFont.SetFile(FontHandler_GetFont(eFontType_MainMenu_InfoBox, 72));
			headerButtonData.mFont.mvSize = gfFontSize_MainMenu;
			headerButtonData.mFont.mColor = cColor(1.0, mfTransitionAlpha) * gOptionMenu_ModColor;
			headerButtonData.mFontAlign = eFontAlign_Left;
			cColor headerTextButtonBaseColor = headerButtonData.mFont.mColor;
			
			cImGuiButtonData headerWidgetButtonData = headerButtonData;
			headerWidgetButtonData.mbUseBackgroundGfx = true;
			headerWidgetButtonData.mColorBase = (sSelectedBtn == "ModHeaderButton" ? cColor(1, mfTransitionAlpha) * gHoverColor : cColor(1,mfTransitionAlpha)); 
			tString sHeaderButtonGfx = mCurrentEntryDisplay == eLuxModContentType_AddOn ? "ui_switch_on" : "ui_switch_off";
			headerWidgetButtonData.mGfxBackground = cImGuiGfx(sHeaderButtonGfx, eImGuiGfx_Image);			
			
			headerButtonData.mFont.mColor = mCurrentEntryDisplay == eLuxModContentType_StandAlone ? headerTextButtonBaseColor * gHoverColor : headerTextButtonBaseColor;
			cVector2f vStoriesButtonSize(GetFontLengthW(headerButtonData.mFont, 1.f, ImGui_TranslatePlatformSpecific("Stories")));
			vStoriesButtonSize.y = headerButtonData.mFont.mvSize.y;
			if (ImGui_DoButtonExt("Stories", "Stories", headerButtonData, cVector3f(0.f), vStoriesButtonSize))
			{
				if (mCurrentEntryDisplay != eLuxModContentType_StandAlone)
				{
					mCurrentEntryDisplay = eLuxModContentType_StandAlone;
					mvModEntryListStates[eLuxModContentType_StandAlone].mlFocusedEntryRelativeIndex = 0;
					mvModEntryListStates[eLuxModContentType_AddOn].mlFocusedEntryRelativeIndex = 0;
				
					Sound_PlayGui("special_fx/frontend/frontend_menu_select", 1.0f, eSoundEntryType_Gui);
				}
			}
			
			if (ImGui_DoButtonExt("ModHeaderButton", "", headerWidgetButtonData, cVector3f(0.f, -5.f, 0.f), OptionMenu_GetScaledSize(cVector2f(50.f, 25.f))))
			{
				mCurrentEntryDisplay = mCurrentEntryDisplay == eLuxModContentType_StandAlone ? eLuxModContentType_AddOn : eLuxModContentType_StandAlone;
				mvModEntryListStates[eLuxModContentType_StandAlone].mlFocusedEntryRelativeIndex = 0;
				mvModEntryListStates[eLuxModContentType_AddOn].mlFocusedEntryRelativeIndex = 0;
				
				Sound_PlayGui("special_fx/frontend/frontend_menu_select", 1.0f, eSoundEntryType_Gui); 
			}
			
			msSelectedModButton = OptionMenu_UpdateFocus("ModHeaderButton", msSelectedModButton);
			
			if(bIsUsingGamepad == false && bIsUsingKeys == false && bMouseDown == false && ImGui_PrevInFocus())
			{
				pListState.mlFocusedEntryRelativeIndex = vFocusableItems.size()-1;
			}
			
			headerButtonData.mFont.mColor = mCurrentEntryDisplay == eLuxModContentType_AddOn ? headerTextButtonBaseColor * gHoverColor : headerTextButtonBaseColor;
			cVector2f vAddOnsButtonSize(GetFontLengthW(headerButtonData.mFont, 1.f, ImGui_TranslatePlatformSpecific("AddOns")));
			vAddOnsButtonSize.y = headerButtonData.mFont.mvSize.y;
			if (ImGui_DoButtonExt("AddOns", "AddOns", headerButtonData, cVector3f(0.f), vAddOnsButtonSize))
			{
				if (mCurrentEntryDisplay != eLuxModContentType_AddOn)
				{
					mCurrentEntryDisplay = eLuxModContentType_AddOn;
					mvModEntryListStates[eLuxModContentType_StandAlone].mlFocusedEntryRelativeIndex = 0;
					mvModEntryListStates[eLuxModContentType_AddOn].mlFocusedEntryRelativeIndex = 0;
					
					Sound_PlayGui("special_fx/frontend/frontend_menu_select", 1.0f, eSoundEntryType_Gui); 
				}
			}
		}
		ImGui_LayoutEnd();
		
		//////////////////////////////////////////////////////////////////
		// SEPARATOR LINE
		cVector2f vLinePos = kModsBgPos + cVector2f(100, 105);
		ImGui_DrawGfx(cImGuiGfx(), OptionMenu_GetTopLeftOffset(vLinePos, 0.01), OptionMenu_GetScaledSize(cVector2f(kModsBgSize.x + 220,2)), cColor(1, mfTransitionAlpha) * gOptionMenu_ModColor * 0.5);
		
		//////////////////////////////////////////////////////////////////
		// DRAW MODS LIST		
		ImGui_SetTransCategory("ModMenu");

		GuiCustomStories_DoEntryList(mCurrentEntryDisplay, listScrollAction, bMouseDown, bIsUsingGamepad, bDrawWorkshopBtn, lMaxItems, sSelectedBtn, vFocusableItems);
		lLastModEntryIndex = vFocusableItems.size() - 1;
		mbModListVisibleItemsChanged = false;

		if(vFocusableItems.size()>0 && pListState.mlFocusedEntryRelativeIndex == -1)
		{
			pListState.mlFocusedEntryRelativeIndex = 0;
		}

		// Define the mod index for printing img and detail txt.
		int lFocusedModIndex = pListState.GetFocusedEntryIndex();
		const bool bShouldShowModDetails = lFocusedModIndex >= 0 && lFocusedModIndex < pListState.mlListSize;
		if (bShouldShowModDetails)
		{
			GuiCustomStories_DoModDetails(mCurrentEntryDisplay, lFocusedModIndex);
		}
		
		//////////////////////////////////////////////////////////////////
		// SEPARATOR LINE
		ImGui_DrawGfx(cImGuiGfx(), OptionMenu_GetTopLeftOffset(vLinePos + cVector2f(0.f, 402.f), 0.01), OptionMenu_GetScaledSize(cVector2f(kModsBgSize.x + 220,2)), cColor(1, mfTransitionAlpha) * gOptionMenu_ModColor * 0.5);
		
		//////////////////////////////////////////////////////////////////
		// LAUNCH BTN 
		ImGui_SetTransCategory("ModMenu");
		vFocusableItems.push_back("Launch");
		// Bit of a hack to make the ButtonModOptions focus work
		if(pListState.mlFocusedEntryRelativeIndex == vFocusableItems.size()-1)
		{
			sSelectedBtn = vFocusableItems[pListState.mlFocusedEntryRelativeIndex];
		}

		{
			float fLaunchAlpha = mfTransitionAlpha;
			bool bLaunchActive = mlSelectedStandAloneModID != -1 || m_setSelectedAddOnIDs.Size()>0;
			if(bLaunchActive==false)
				fLaunchAlpha *= 0.5f;

			if (OptionMenu_ButtonModOptions("Launch", kModsBgPos + cVector2f(110, 520), sSelectedBtn, false, fLaunchAlpha))
			{
				cLux_AddDebugMessage("LAUNCH PRESSED!!! - Active? " + bLaunchActive + " / StandAloneID: " + mlSelectedStandAloneModID + " / AddOnSet size: " + m_setSelectedAddOnIDs.Size());

				if (bLaunchActive)
				{
					mbShowSelectedModDialog = true;
					msMessageBoxFocus = "No";
					msFocusNextFrame="No";
					//cLux_AddDebugMessage("mlModEntryToLoad: " + mlModEntryToLoad);
				}
			}
			
			msSelectedModButton = OptionMenu_UpdateFocus("Launch", msSelectedModButton);
		}

		if(bIsUsingGamepad == false && bIsUsingKeys == false && bMouseDown == false && ImGui_PrevInFocus())
		{
			pListState.mlFocusedEntryRelativeIndex = vFocusableItems.size()-1;
		}


		//////////////////////////////////////////////////////////////////
		// WORKSHOP BTN 
		if (bDrawWorkshopBtn)
		{
			vFocusableItems.push_back("BrowseWorkshop");
			// Bit of a hack to make the ButtonModOptions focus work
			if(pListState.mlFocusedEntryRelativeIndex == vFocusableItems.size()-1)
			{
				sSelectedBtn = vFocusableItems[pListState.mlFocusedEntryRelativeIndex];
			}

			if (OptionMenu_ButtonModOptions("BrowseWorkshop", kModsBgPos + cVector2f(110, 550), sSelectedBtn, false, mfTransitionAlpha, true))
			{
				cLux_GetModHandler().OpenContentAcquisitionWindow("SteamWorkshop");
			}
			
			msSelectedModButton = OptionMenu_UpdateFocus("BrowseWorkshop", msSelectedModButton);
			
			if(bIsUsingGamepad == false && bIsUsingKeys == false && bMouseDown == false && ImGui_PrevInFocus())
			{
				pListState.mlFocusedEntryRelativeIndex = vFocusableItems.size()-1;
			}
		}
		
		ImGui_SetTransCategory("Menu");
		
		//////////////////////////////////////////////////////////////////
		// BACK BTN
		{
			bool bBackButton = false;

			if(bIsUsingGamepad == false)
			{
				vFocusableItems.push_back("Back");
				// Bit of a hack to make the ButtonModOptions focus work
				if(pListState.mlFocusedEntryRelativeIndex == vFocusableItems.size()-1)
				{
					sSelectedBtn = vFocusableItems[pListState.mlFocusedEntryRelativeIndex];
				}
				bBackButton = MainMenu_DoBackButton(sSelectedBtn, mfTransitionAlpha);
				
				msSelectedModButton = OptionMenu_UpdateFocus("Back", msSelectedModButton);
			}
			
			if(bIsUsingGamepad == false && bIsUsingKeys == false && bMouseDown == false && ImGui_PrevInFocus())
			{
				pListState.mlFocusedEntryRelativeIndex = vFocusableItems.size()-1;
			}
		
			bool bBackGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);
			
			if(bBackButton || bBackGamepad)
			{
				cLux_GetModHandler().CleanUpListing();
				
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				mTargetGroup = eMainMenuGroup_Main;
				msTargetFocus = msSelectedMainMenuButton;
				
				if (ImGui_TimerExists("TransitionOut") == false)
					ImGui_AddTimer("TransitionOut", 10);
			}
		}
		
		//////////////////////////////////////////////////////////////////
		// Handle UI nav (after the whole setup is laid out)
		switch(listScrollAction)
		{
		case eImGuiAction_Up:
		{
			pListState.mlFocusedEntryRelativeIndex--;
			if (pListState.mlFocusedEntryRelativeIndex < 1)
			{
				if (pListState.mlFirstVisibleEntryIndex > 0)
				{
					pListState.mlFirstVisibleEntryIndex--;
					pListState.mlFocusedEntryRelativeIndex = 1;
				}
				else if (pListState.mlFirstVisibleEntryIndex != 0 || pListState.mlFocusedEntryRelativeIndex != 0)
				{
					pListState.mlFocusedEntryRelativeIndex = vFocusableItems.size()-1;
				}
			}
		}
			break;
		case eImGuiAction_ScrollUp:
		{
			if(pListState.mlFirstVisibleEntryIndex > 0) 
				pListState.mlFirstVisibleEntryIndex--;
		}
		break;
		case eImGuiAction_Down:
		{
			bool bAdvanceFocusedItem = true;
			if(pListState.mlFocusedEntryRelativeIndex == lLastModEntryIndex)
			{
				// We got past the mod entry list, check if we should scroll down or move focus out of the list
				if(pListState.mlFirstVisibleEntryIndex < pListState.mlListSize - lMaxItems)
				{
					pListState.mlFirstVisibleEntryIndex++;
					bAdvanceFocusedItem = false;
				}
			}
			
			if(bAdvanceFocusedItem)
			{
				pListState.mlFocusedEntryRelativeIndex++;
				// If we go further than the focusable item list, wrap around
				if (pListState.mlFocusedEntryRelativeIndex >= vFocusableItems.size())
				{
					pListState.mlFocusedEntryRelativeIndex = 0;
				}
			}
		}
		break;
		case eImGuiAction_ScrollDown:
		{
			if(pListState.mlFirstVisibleEntryIndex < mvModIDs.size()-lMaxItems) 
				pListState.mlFirstVisibleEntryIndex++;
		}
		break;
		}

		if(lOldFirstVisibleItemIndex != pListState.mlFirstVisibleEntryIndex)
		{
			mbModListVisibleItemsChanged = true;
			
			// Clear focus so when the visible item list is rebuilt we don't keep the last focused item (would keep the focus on it otherwise)
			ImGui_SetFocus("");
		}

		if(lOldFocusedItemIndex != pListState.mlFocusedEntryRelativeIndex || lOldFirstVisibleItemIndex != pListState.mlFirstVisibleEntryIndex)
		{
			cLux_AddDebugMessage("Resulting focus: " + pListState.mlFocusedEntryRelativeIndex + " / FirstIndex: " + pListState.mlFirstVisibleEntryIndex + " --- (Old: " + lOldFocusedItemIndex + " / " + lOldFirstVisibleItemIndex + ")");
			mbModListFocusChanged = true;
		}
		
		if (mbShowSelectedModDialog == false && 
			mbModListVisibleItemsChanged == false && 
			cLux_GetInputHandler().GetLastDeviceUsed() != eInputDeviceType_Mouse)
		{
			if(pListState.mlFocusedEntryRelativeIndex >= 0 && pListState.mlFocusedEntryRelativeIndex < vFocusableItems.size())
			{
				msFocusNextFrame = vFocusableItems[pListState.mlFocusedEntryRelativeIndex];
			}
		}

		//////////////////////////////////////////////////////////////////
		// THE END
		GuiHandleTransition(mTargetGroup, msTargetFocus);
		
		if (mbShowSelectedModDialog==false)
			OptionMenu_ShowGamepadButtons(true);
	}
	
	//-------------------------------------------------------
	
	void LaunchModByName(tString asName)
	{
		cLux_GetModHandler().CleanUpListing();
		cLux_GetModHandler().PrepareListing();
	
		PrepareModEntries();

		Log("Launching mod " + asName + "\n");
		cLux_GetModHandler().LaunchMod(cString_To16Char(asName));
	}
	
	//-------------------------------------------------------
	
	void GuiPreMenu(float afTimeStep)
	{
		//cLux_AddDebugMessage("FIRST: "+mbFirstGameStart+ "SHOW PRE: "+mbShowPreMenu+" PREPHASE: "+mPreMenuPhase+" ");
		//cLux_AddDebugMessage("PHASE: "+mPreMenuPhase);
		///////////////////////
		// Init
		if(mbInitPreMenu)
		{
			mbInitPreMenu = false;
			mfPreMenuFadeAmount=1;
			mfPreMenuFadeDest=mfPreMenuFadeDestMin;
			
			mPreMenuPhase = ePreMenuPhase_None;
			mlPreMenuState=-1;
			
			mbBackgroundShowTitle = false;
		}
		
		///////////////////////
		// Fade in/out
		if(mfPreMenuFadeAmount<1 && mfPreMenuFadeDest<1 && mPreMenuPhase < ePreMenuPhase_Gamma)
			ImGui_SetModUseInput(false);
			
		float fMul;
		if (mfPreMenuFadeDest > mfPreMenuFadeDestMin)
		{
			// Fade in
			if (mPreMenuPhase == ePreMenuPhase_FrictionalLogo)
				fMul = 0.45;
			else if (mPreMenuPhase == ePreMenuPhase_FmodLogo)
				fMul = 0.5f;
			else
				fMul = 1.0f;
		}
		else
		{
			// Fade out
			if (mPreMenuPhase == ePreMenuPhase_FrictionalLogo)
				fMul = 0.6;
			else if (mPreMenuPhase == ePreMenuPhase_FmodLogo)
				fMul = 0.7f;
			else
				fMul = 0.6f;
		}

		mfPreMenuFadeAmount	= cMath_IncreaseTo(mfPreMenuFadeAmount, afTimeStep*fMul, mfPreMenuFadeDest);
		
		if(mfPreMenuFadeAmount<=mfPreMenuFadeDestMin && mfPreMenuFadeDest==mfPreMenuFadeDestMin)
		{
			mPreMenuPhase++;
			mlPreMenuState++;
			mfPreMenuFadeDest =1;	

			//cLux_AddDebugMessage("FIRST: "+mbFirstGameStart+ "SHOW PRE: "+mbShowPreMenu+" PREPHASE: "+mPreMenuPhase+" ");
			
			if(mPreMenuPhase==ePreMenuPhase_Init)
			{
			}

			if(mPreMenuPhase == ePreMenuPhase_PressToContinue)
			{
				if(mbShowPressX)
				{
					////////////
					// Display press to continue
					cLux_AddDebugMessage("[PRE-MENU] PRESS TO CONTINUE");
				}
				else
				{
					////////////
					// Skip this on PC
					mPreMenuPhase++;
					mlPreMenuState++;
				}
			}
			
			if(mPreMenuPhase==ePreMenuPhase_None)
			{
				
				cLux_AddDebugMessage("[PRE-MENU] INIT");
				cLux_AddTodoMessage("Sound: Menu stinger");
				//Sound_PlayGui("special_fx/frontend/FG_Menu_Sting", 1.0f, eSoundEntryType_Gui);
				//Music_PlayExt("IngameMenu_Music", true, 0.45f, 0.8f, 6.0f, 0.0f, eMusicPrio_OverrideAll, false);
				cLux_AddTodoMessage("Sound: Menu background noise");
				
			}
	
			if(mPreMenuPhase==ePreMenuPhase_FrictionalLogo)
			{
				cLux_AddDebugMessage("[PRE-MENU] LOGO");
				ImGui_AddTimer("FGLogoOver", 3.2f);
				mbMouseVisible = true;
				Sound_PlayGui("special_fx/frontend/FG_Menu_Sting", 1.0f, eSoundEntryType_Gui);
				/*
				if(mbShowPressX)
				{
					cLux_AddTodoMessage("Sound: Menu background noise");
					//Sound_CreateAtEntity("MenuBGNoise", "special_fx/frontend/main_menu_bg", "Player", 6.0f, false, 1.0f);
				}
				else
				{
					//mPreMenuPhase++;
					//mlPreMenuState++;
				}
				*/
			}
			
			if(mPreMenuPhase==ePreMenuPhase_FmodLogo)
			{
				cLux_AddDebugMessage("[PRE-MENU] FMOD LOGO");
				ImGui_AddTimer("FModLogoOver", 2.5f);
				mbMouseVisible = true;
			}
		
			if(mPreMenuPhase==ePreMenuPhase_Welcome) // WELCOME
			{
				cLux_AddDebugMessage("[PRE-MENU] WELCOME");
				if(mbFirstGameStart && mbShowPreMenu)
				{
					cLux_AddTodoMessage("Sound: Menu background noise");
					//Sound_CreateAtEntity("MenuBGNoise", "special_fx/frontend/main_menu_bg", "Player", 6.0f, false, 1.0f);
				}
				else
				{
					mPreMenuPhase = ePreMenuPhase_FinalFade;
                    
					//Music_PlayExt("Menu_Music", true, mfMenuMusicVol, 1.0f, 6.0f, 0.0f, eMusicPrio_OverrideAll, false);
					
					cLux_AddTodoMessage("Sound: Menu background noise");
					//Sound_CreateAtEntity("MenuBGNoise", "special_fx/frontend/main_menu_bg", "Player", 6.0f, false, 1.0f);
					
					//return;//So we do not show the gamma setup!
				}
			}
			
			if(mPreMenuPhase==ePreMenuPhase_Gamma)
			{
				cLux_AddDebugMessage("[PRE-MENU] GAMMA");

				mbFirstGameStart = false;
				mpConfig.SetBool("Main", "FirstGameStart", mbFirstGameStart);
				
				/*if(mbFirstGameStart && mbShowPreMenu)
				{
					mPreMenuPhase = ePreMenuPhase_FinalFade;
				}*/
				
				if(mbFirstGameStart && mbShowPreMenu)
				{
					//Music_PlayExt("IngameMenu_Music", true, 0.35f, 0.8f, 6.0f, 0.0f, eMusicPrio_OverrideAll, false);
					cLux_AddTodoMessage("Sound: Menu background noise");
					//Sound_CreateAtEntity("MenuBGNoise", "special_fx/frontend/main_menu_bg", "Player", 6.0f, false, 1.0f);
				}
				else
				{
					cLux_AddTodoMessage("IM GOING TO FINAL FADE");
					mPreMenuPhase = ePreMenuPhase_FinalFade;
					//Music_PlayExt("Menu_Music", true, mfMenuMusicVol, 1.0f, 6.0f, 0.0f, eMusicPrio_OverrideAll, false);
					msFocusNextFrame = msSelectedMainMenuButton;					
					//return;//So we do not show the gamma setup!
				}
			}
			
			if(mPreMenuPhase==ePreMenuPhase_FinalFade)
			{
				cLux_AddDebugMessage("[PRE-MENU] FINAL FADE");
				mfPreMenuFadeAmount = 1;
				//Music_PlayExt("Menu_Music", true, mfMenuMusicVol, 1.0f, 6.0f, 0.0f, eMusicPrio_OverrideAll, false);
				msFocusNextFrame = msSelectedMainMenuButton;
			}
			
			if(mPreMenuPhase==ePreMenuPhase_Done)
			{
				
				cLux_AddDebugMessage("[PRE-MENU] DONE ");
				
				if (mbFirstGameStart == false && mbPremenuActive == true && ImGui_TimerExists("TransitionIn") == false)
				{
					cLux_AddDebugMessage("I AM CREATING THIS FADE");
					ImGui_AddTimer("TransitionIn",10); // THIS CREATES A DOUBLE FADE ON START
				}
				cLux_AddTodoMessage("Sound: Menu background noise");
				
				
				mbPremenuActive = false;
				mbBackgroundShowTitle = true;
				mbPremenuActive = false;
				Sound_CreateAtEntity("MenuBGNoise", "special_fx/frontend/main_menu_bg", "Player", 6.0f, false, 1.0f);
				//Sound_CreateAtEntity("MenuBGNoise", "special_fx/frontend/main_menu_bg", "Player", 6.0f, false, 1.0f);
			}
		}
		
		///////////////////////
		// Black screen
		if(mPreMenuPhase==ePreMenuPhase_None)
		{
			cImGuiGfx gfxBlack;
			ImGui_DrawGfx(gfxBlack, ImGui_FullScreenPos(0.1), ImGui_FullScreenSize(), cColor(0,1));
		}
		
		///////////////////////
		// FG Logo
		if(mPreMenuPhase==ePreMenuPhase_FrictionalLogo)
		{			
			cImGuiGfx gfxBlack;
			ImGui_DrawGfx(gfxBlack, ImGui_FullScreenPos(0.1), ImGui_FullScreenSize(), cColor(0,1));
			//cImGuiGfx gfx("frictional_games_logo.dds", eImGuiGfx_Texture);
			//cVector2f vBgSize = OptionMenu_GetScaledSize(cVector2f(900, 351));
			cImGuiGfx gfxFG("frictional_games_logo_color.png", eImGuiGfx_Texture);
			cVector2f vBgSize = OptionMenu_GetScaledSize(cVector2f(1000, 343)*0.6f);
			cVector3f vBgPos = OptionMenu_GetCenterOffset(cVector2f(0), 10.2) - cVector3f(vBgSize.x * 0.5, vBgSize.y * 0.5, 0.0);
			ImGui_DrawGfx(gfxFG, vBgPos, vBgSize, cColor(1, mfPreMenuFadeAmount));
			
			/*cImGuiGfx gfxNewton("newton_logo.png", eImGuiGfx_Texture);
			cImGuiGfx gfxFMod("fmod_logo.png", eImGuiGfx_Texture);
			cImGuiGfx gfxAnnosoft("annosoft_logo.png", eImGuiGfx_Texture);
			cVector2f vLicenseLogoSize = OptionMenu_GetScaledSize(cVector2f(728, 192)*0.3f);
			cVector3f vLicenseLogoPos = OptionMenu_GetCenterOffset(cVector2f(0), 10.2) - cVector3f(vLicenseLogoSize.x * 0.5, vLicenseLogoSize.y * 0.5, 0.0);
			
			cLux_AddDebugMessage("CENTER: "+vLicenseLogoPos);
			
			ImGui_DrawGfx(gfxNewton, vLicenseLogoPos+cVector3f(-vLicenseLogoPos.x * 0.70f, vLicenseLogoPos.y*0.6f, 0), vLicenseLogoSize, cColor(1, mfPreMenuFadeAmount));
			ImGui_DrawGfx(gfxFMod, vLicenseLogoPos+cVector3f(0, vLicenseLogoPos.y*0.6f, 0), vLicenseLogoSize, cColor(1, mfPreMenuFadeAmount));
			ImGui_DrawGfx(gfxAnnosoft, vLicenseLogoPos+cVector3f(vLicenseLogoPos.x * 0.70f, vLicenseLogoPos.y*0.6f, 0), vLicenseLogoSize, cColor(1, mfPreMenuFadeAmount));*/
			
			//loadscreen_mask
			
			if(ImGui_TimerOver("FGLogoOver"))
			{
				mfPreMenuFadeDest = mfPreMenuFadeDestMin;
			}
		}
		///////////////////////
		// Fmod Logo
		if(mPreMenuPhase==ePreMenuPhase_FmodLogo)
		{			
			cImGuiGfx gfxBlack;
			ImGui_DrawGfx(gfxBlack, ImGui_FullScreenPos(0.1), ImGui_FullScreenSize(), cColor(0,1));
			
			/*cVector3f vBgCenter = cVector3f(kScreenCenter.x,kScreenCenter.y,0);
			cImGuiGfx gfx("fmod_logo.png", eImGuiGfx_Texture);
			cVector2f vBgSize = OptionMenu_GetScaledSize(cVector2f(728, 192) * 0.3f);
			cVector3f vBgPos = OptionMenu_GetCenterOffset(cVector2f(0), 10.2) - cVector3f(vBgSize.x * 0.5, vBgSize.y * 0.5, 0.0);
			ImGui_DrawGfx(gfx, vBgPos, vBgSize, cColor(1, mfPreMenuFadeAmount));*/
			//ImGui_DrawAlignedGfx(gfx, cVector3f(vBgCenter.x,vBgCenter.y,9990), eImGuiAlign_CenterCenter, cVector2f(300,300));
			
			cImGuiGfx gfxNewton("newton_logo.png", eImGuiGfx_Texture);
			cImGuiGfx gfxFMod("fmod_logo.png", eImGuiGfx_Texture);
			cImGuiGfx gfxAnnosoft("annosoft_logo.png", eImGuiGfx_Texture);
			cVector2f vLicenseLogoSize = OptionMenu_GetScaledSize(cVector2f(728, 192)*0.3f);
			cVector3f vLicenseLogoPos = OptionMenu_GetCenterOffset(cVector2f(0), 10.2) - cVector3f(vLicenseLogoSize.x * 0.5, vLicenseLogoSize.y * 0.5, 0.0);
			
			ImGui_DrawGfx(gfxNewton, vLicenseLogoPos+cVector3f(-vLicenseLogoPos.x * 0.70f, 0, 0), vLicenseLogoSize, cColor(1, mfPreMenuFadeAmount));
			ImGui_DrawGfx(gfxFMod, vLicenseLogoPos+cVector3f(0, 0, 0), vLicenseLogoSize, cColor(1, mfPreMenuFadeAmount));
			ImGui_DrawGfx(gfxAnnosoft, vLicenseLogoPos+cVector3f(vLicenseLogoPos.x * 0.70f, 0, 0), vLicenseLogoSize, cColor(1, mfPreMenuFadeAmount));
			
			if(ImGui_TimerOver("FModLogoOver"))
			{
				mfPreMenuFadeDest = mfPreMenuFadeDestMin;
			}
		}
		///////////////////////
		// Declaration of intent
		else if(mPreMenuPhase==ePreMenuPhase_Welcome)
		{
			//cLux_AddDebugMessage("WELCOME");
			GuiWelcomeMessages();
		}
		///////////////////
		// Press to continue
		else if(mPreMenuPhase == ePreMenuPhase_PressToContinue)
		{
			cImGuiGfx gfxBlack;
			ImGui_DrawGfx(gfxBlack, ImGui_FullScreenPos(0.1), ImGui_FullScreenSize(), cColor(0,1));
			
			cImGuiGfx gfxSide("insta_square.png", eImGuiGfx_Texture);
			cVector3f vFacePos = OptionMenu_GetTopLeftOffset(cVector2f(960, 360), 2.0f);
			ImGui_DrawAlignedGfx(gfxSide, vFacePos, eImGuiAlign_CenterCenter, OptionMenu_GetScaledSize(cVector2f(500, 500)), cColor(1, mfPreMenuFadeAmount));

			GuiPressX();
		}
		///////////////////////
		// Gamma
		else if(mPreMenuPhase==ePreMenuPhase_Gamma)
		{
			// Show profile save error
			if(msLoadSaveError.length() > 0)
			{
				MessageBoxLoadError();
				ImGui_SetModUseInput(false); 
			}
			
			cImGuiGfx gfxBlack;
			ImGui_DrawGfx(gfxBlack, ImGui_FullScreenPos(0.1), ImGui_FullScreenSize(), cColor(0,1));
			GuiOptionsGamma();		
		}
		else if(mPreMenuPhase==ePreMenuPhase_FinalFade)
		{
			mfPreMenuFadeDest = mfPreMenuFadeDestMin;
			cImGuiGfx gfxBlack;
			ImGui_DrawGfx(gfxBlack, ImGui_FullScreenPos(0.1), ImGui_FullScreenSize(), cColor(0,mfPreMenuFadeAmount));
			mfTransitionAlpha = 0;
		}
		else if(mPreMenuPhase==ePreMenuPhase_Done)
		{
		}
		
	}
	
	//------------------------------------------------------
		
	void GuiPressX()
	{
		cImGuiLabelData labelData;
		labelData.mFont.SetFile(FontHandler_GetFont(eFontType_MainMenu, 72));
		labelData.mFont.mvSize = cVector2f(46, 46);
		labelData.mFont.mColor = cColor(1, mfPreMenuFadeAmount);
		ImGui_SetTransCategory("Menu");
		ImGui_DoLabelExt("PressX",labelData, OptionMenu_GetTopLeftOffset(kOptionMenu_PressXPos, 4.0));
				
		////////////
		// Wait for keypress
		tString sKeyPressed = cLux_GetInputHandler().GetLatestKeyPressed();

		if(sKeyPressed.length() > 0)
		{
			int lPos = cString_GetFirstStringPos(sKeyPressed, "Gamepad");
			int lEndPos = cString_GetFirstStringPos(sKeyPressed, "Button.0");
			if(lPos != -1 && lEndPos != -1)
			{
				/////////////////
				// Get the device id from the gamepad that pressed the button
				tString sNum = cString_Sub(sKeyPressed, 8);
				int lDotPos = cString_GetFirstCharPos(sNum, '.');
				int lNum = cString_ToInt(cString_Sub(sNum, 0, lDotPos), 0 );

				/////////////
				// Set that gamepad as the primary one
				cLux_GetInputHandler().SetPrimaryGamepad(lNum);

				mfPreMenuFadeDest=mfPreMenuFadeDestMin;
			}
		}
		ImGui_SetTransCategory("");
	}
	
	//-------------------------------------------------------
	
	void GuiWelcomeMessages()
	{
		if (mbWelcomeScreen == false) return;
		
		mfPreMenuFadeAmount = 1;
		//cLux_AddDebugMessage("WELCOME phase: "+mlWelcomeMessageIndex+" TRANS "+mfWelcome1_Transparency);
		float fWaitTime;
		switch (mlWelcomeMessageIndex)
		{	
			case 0:
				mfWelcomeScreenTransparency = cMath_IncreaseTo(mfWelcomeScreenTransparency,0.02f,1);
				fWaitTime = 1.5f;
				break;
			case 1:
				fWaitTime = 3.5f;
				mfWelcome1_Transparency = cMath_IncreaseTo(mfWelcome1_Transparency,0.02f,1);
				break;
			case 2:
				fWaitTime = 2.8f;
				mfWelcome2_Transparency = cMath_IncreaseTo(mfWelcome2_Transparency,0.05f,1);
				break;
			case 3:
				if (mlSelectedGameMode == eGameMode_Normal)
				{
					mfWelcome3_Transparency = cMath_IncreaseTo(mfWelcome3_Transparency,0.05f,1);
					fWaitTime = 2.8f;
					break;
				}
				else
					mlWelcomeMessageIndex = 4;
			case 4:
				mfPreMenuFadeDest = mfPreMenuFadeDestMin;
				break;
		}
		
		if (ImGui_TimerExists("IncreaseIndex") == false)
			ImGui_AddTimer("IncreaseIndex",fWaitTime);

		//cLux_AddDebugMessage("MODE: "+mlSelectedGameMode+" INDEX: "+mlWelcomeMessageIndex);
			
		if (ImGui_TimerOver("IncreaseIndex"))
		{
			if (mlWelcomeMessageIndex < 4)
				mlWelcomeMessageIndex++;
			else if (mlWelcomeMessageIndex == 4)
			{
				if (mfWelcomeScreenTransparency > 0)
					mfWelcomeScreenTransparency -= 0.02f;
				else if(mfWelcomeScreenTransparency > -0.2f)
				{
					//////////////
					// Switch to corrent mod
					/*if (cLux_GetModHandler().GetIsRunningMod() == false || cLux_GetModHandler().GetMainModTitle() == kStandardMode)
					{
						if(mlSelectedGameMode != eGameMode_Normal)
							LaunchModByName(kAdventureModeLocator);
					}
					else if(cLux_GetModHandler().GetMainModTitle() == kAdventureMode)
					{
						if(mlSelectedGameMode == eGameMode_Normal)
							LaunchModByName(kStandardModeLocator);	
					}*/

					mfWelcomeScreenTransparency -= 0.02f;
				}
				else
				{
					StartNewGame();
					mbWelcomeScreen = false;
					mlWelcomeMessageIndex++;
				}
			}
		}
		
		/*if (mfPromptTransparency == 0 && ImGui_TimerExists("PromptTransparency") == false)
			ImGui_AddTimer("PromptTransparency", 2.5f);
			
		if (ImGui_TimerOver("PromptTransparency"))
			mfPromptTransparency = 1;*/
				
		cVector2f vSize = cVector2f(1600,768);
		cVector3f vBgCenter = cVector3f(kScreenCenter.x,kScreenCenter.y,0);
		
		cImGuiGfx gfxBlack;
		ImGui_DrawGfx(gfxBlack, ImGui_FullScreenPos(2), ImGui_FullScreenSize(), cColor(0,1));
		
		cImGuiGfx gfx("loadscreen_mask.dds", eImGuiGfx_Texture);
		cVector2f vBgSize = OptionMenu_GetScaledSize(cVector2f(2048, 1152)*0.6f);
		cVector3f vBgPos = OptionMenu_GetCenterOffset(cVector2f(0), -1) - cVector3f(vBgSize.x * 0.5f, vBgSize.y * 0.5f, 0.0f);
		ImGui_DrawGfx(gfx, vBgPos, vBgSize, cColor(1, mfWelcomeScreenTransparency));
		//ImGui_DrawAlignedGfx(gfx, cVector3f(vBgCenter.x,vBgCenter.y,1), eImGuiAlign_CenterCenter,vSize);
		
		ImGui_GroupBegin(cVector3f(0,0,10), cVector2f(kScreenCenter.x,600));
		
		cImGuiTextFrameData textData = ImGui_GetDefaultTextFrame();
		textData.mFont.SetFile(FontHandler_GetFont(eFontType_Credits, 56));
		textData.mFont.mvSize = cVector2f(24, 24);
		float fLineHeight = textData.mFont.mvSize.y*1.2f;
		
		textData.mFontAlign = eFontAlign_Center;
		textData.mbUseBackgroundGfx = false;
		
		ImGui_SetTransCategory("PreMenu");
		textData.mFont.mColor = cColor(1, mfWelcome1_Transparency*mfWelcomeScreenTransparency);
		ImGui_DoTextFrameExt("WelcomeMessage01", cVector2f_Zero, 6, 0, textData, ImGui_NrmPosGroup(cVector3f(0.5f,0.8f,20)), ImGui_NrmSizeGroup(1));
		textData.mFont.mColor = cColor(1, mfWelcome2_Transparency*mfWelcomeScreenTransparency);
		ImGui_DoTextFrameExt("WelcomeMessage02", cVector2f_Zero, 6, 0, textData, ImGui_NrmPosGroup(cVector3f(0.5f,0.8f,20))+cVector3f(0,fLineHeight,0), ImGui_NrmSizeGroup(1));
		textData.mFont.mColor = cColor(1, mfWelcome3_Transparency*mfWelcomeScreenTransparency);
		ImGui_DoTextFrameExt("WelcomeMessage03", cVector2f_Zero, 6, 0, textData, ImGui_NrmPosGroup(cVector3f(0.5f,0.8f,20))+cVector3f(0,fLineHeight*2.0f,0), ImGui_NrmSizeGroup(1));
		ImGui_SetTransCategory("");
			
		ImGui_GroupEnd();
		
		
		////////////
		// Wait for keypress
		/*tString sKeyPressed = cLux_GetInputHandler().GetLatestKeyPressed();

		if(sKeyPressed.length() > 0)
		{
			int lPos = cString_GetFirstStringPos(sKeyPressed, "Gamepad");
			int lEndPos = cString_GetFirstStringPos(sKeyPressed, "Button.0");
			if(lPos != -1 && lEndPos != -1)
			{
				/////////////////
				// Get the device id from the gamepad that pressed the button
				tString sNum = cString_Sub(sKeyPressed, 8);
				int lDotPos = cString_GetFirstCharPos(sNum, '.');
				int lNum = cString_ToInt(cString_Sub(sNum, 0, lDotPos), 0 );

				/////////////
				// Set that gamepad as the primary one
				cLux_GetInputHandler().SetPrimaryGamepad(lNum);
				
				if (mlWelcomeMessageIndex < 3)
					mlWelcomeMessageIndex++;
				else
					mfPreMenuFadeDest = mfPreMenuFadeDestMin;

				mfPromptTransparency = 0;
				ImGui_StopTimer("PromptTransparency");
			}
			else if (sKeyPressed == "MouseButton.LeftMouse")
			{
				if (mlWelcomeMessageIndex < 3)
					mlWelcomeMessageIndex++;
				else
					mfPreMenuFadeDest = mfPreMenuFadeDestMin;
					
				mfPromptTransparency = 0;
				ImGui_StopTimer("PromptTransparency");
			}
		}*/
		
		
	}

	//------------------------------------------------------
	
	void ApplySettings(bool abSave = true)
	{
		/////////////
		// Saves the config
		if(abSave && cLux_GetSaveConfigAtExit()) mpConfig.Save();

		/////////////
		// Applies the changes to the engine and displays a message box if restart is needed
		mbRestartWarning = cLux_ApplyUserConfig();
	}

	void DiscardSettings()
	{
		///////////
		// Load settings
		mpConfig.Load();
		cGraphics_GetLowLevel().SetBrightness(mpConfig.GetFloat("Graphics", "Brightness", 1.0));
		cGraphics_GetLowLevel().SetGammaCorrection(mpConfig.GetFloat("Graphics", "Gamma", 1.0));
	}

	//------------------------------------------------------
	
	void ApplyKeybinds()
	{
		/////////////
		// Saves the config
		mpKeyConfig.Save();		
		cLux_GetInputHandler().LoadKeyConfig();

		/////////////
		// Reloading keys will make actions trigger again, so ignore next frame
		mlIgnoreInput = 3;
		mbKeybindChanged = false;		
		mlFirstItemId = 0;
		mlLastInFocus = 0;
		mTargetGroup = eMainMenuGroup_Options_Controls;
		msTargetFocus = msSelectedInputButton;
		mbShowApplyKeyChanges = false;
	}

	void DiscardKeybinds()
	{
		///////////
		// Load settings
		mpKeyConfig.Load();
		mbKeybindChanged = false;
		mlFirstItemId = 0;
		mlLastInFocus = 0;
		mTargetGroup = eMainMenuGroup_Options_Controls;
		msTargetFocus = msSelectedInputButton;
		mbShowApplyKeyChanges = false;
	}

	//------------------------------------------------------------
	
	void OnDraw(float afFrameTime)
	{
		///////////////
		// Reset preview subtitles
		mbDrawPreviewSubtitles = true;
	}
	
	//------------------------------------------------------------
	
	void OnPostRender(float afFrameTime)
	{
	
	}
	
	//------------------------------------------------------------
	
	/////////////////////////////////////////
	// ACTIONS
	/////////////////////////////////////////
	
	//------------------------------------------------------------
	
	int mlBlurID = -1;
	
	bool mbPauseSoundDelay = false;
	
	void OnAction(int alAction, bool abPressed)
	{
		if(abPressed)
		{
			if(alAction == eAction_OpenMenu && LoadScreen_IsVisible() == false && Sketchbook_IsOpen() == false && GameStats_GetGuiActive()==false && mbPauseMenuEnabled && cLux_GetCurrentMap()!=null)
			{
				if(mbMenuActive == false)
				{
					// PAUSE
					mbMainMenuActive = false;
					mfTransitionAlpha = 1.f;
					SetMenuActive(true);
					mbPauseSoundDelay = true;					
					
					if (mlBlurID == -1)
						mlBlurID = Effect_Blur_Start(1,0);
						//mlBlurID = Effect_DoF_Start(0.f, 0.1f, 1.0f, 0.f);
				}
				else
				{
					// UNPAUSE
					mbMenuButtonPressed = true;
					msSelectedPauseMenuButton = "ReturnToGame";
					Sound_PlayGui("special_fx/frontend/unpause", 1.0f, eSoundEntryType_Gui);
					// This is duplicated when the player clicks on Return to game
					ResetBlur();
				}
			}
		}
		
		mbAnyButtonPressed = abPressed && alAction != eAction_OpenMenu;

		// Block all input
	}


	void OnAnalogInput(int alAnalogId, const cVector3f &in avAmount)
	{
	
	}
	
	//------------------------------------------------------------
	
	void OnExitPressed()
	{
	
	}
	
	//------------------------------------------------------------
	
	void AppGotInputFocus()
	{
	
	}
	void AppLostInputFocus()
	{
	
	}
	
	/////////////////////////////////////////
	// GLOBAL
	/////////////////////////////////////////
	
	//------------------------------------------------------------
	
	[nosave] bool mbGameCompletedOnce = false;
	[nosave] bool mbGameCompletedMsgSeen = false;
	bool mbShowGameCompleted = false;
	bool mbShowGameCompleted_02 = false;
	bool mbShowGameCompleted_03 = false;
	
	[nosave] bool mbNewGameSkipIntro = false;
	
	bool mbMainMenuActive = false;
	bool mbMenuActive = false;
	bool mbPauseMenuEnabled = true;
	bool mbMenuButtonPressed = false;
	bool mbCanContinue = false;
	bool mbGameOver = false;
	bool mbSaveLoadEnabled = true;
	
	//------------------------------------------------------------
	
	float mfBackgroundWidth = 0.f;
	float mfDesiredBackgroundWidth = 0.f;
	
	bool mbWelcomeScreen = false;
	float mfWelcomeScreenTransparency = 0;
	int mlWelcomeMessageIndex = 0;
	float mfPromptTransparency = 0;
	float mfWelcome1_Transparency = 0;
	float mfWelcome2_Transparency = 0;
	float mfWelcome3_Transparency = 0;
	float mfPreMenuFadeDestMin = -0.1f; // Negative value to have short pause between phases
		 
	bool mbRestartWarning = false;
	bool mbShowRestartWarning = false;
	bool mbShowApplyChanges = false;
	bool mbShowExit = false;
	bool mbShowPlayGo = false;
	bool mbShowOverwriteSaveSlot = false;
	bool mbShowNewGame = false;
	bool mbShowSkipIntro = false;
	bool mbShowCustomSettingsChangesWillBeLost = false;
	[nosave] uint mlCustomSettingsChangesWillBeLost = eCustomSettingsChangesWillBeLost_None;
	bool mbRandomizedOnce = false;
	bool mbShowLoadGame = false;
	bool mbShowApplyKeyChanges = false;
	bool mbShowPreMenu = false;
	bool mbPremenuActive=false;
	bool mbFirstGameStart = false;
	bool mbShowReset = false;
	bool mbShowDuplicateKeys = false;
	bool mbShowPressX = false;
	float mfKeepDisplaySetting = 0.0f;
	bool mbShowDetectSettings = false;
	bool mbShowNewGamePlusPopUpMsg = false;
	bool mbShowNewGamePlusSettingPopUp = false;
	
	float mfPlayGoTimer = 0.0f;
	
	cImGuiFrameGfx mGfxFrame;
	//cImGuiWindowData mWindowData;
	
	tString msMessageBoxFocus = "No";
	
	[volatile] cConfigFile@ mpConfig;
	[volatile] cConfigFile@ mpKeyConfig;

	int mlActionHorizontal;
		
	int mlClickedPauseMenuButton;
	int mlClickedMainMenuButton;

	int mlCurrentResolution;
	tString msCurrentDisplayMode;

	tString msSelectedMainMenuButton;
	tString msSelectedSaveSlotButton;
	tString msSelectedPauseMenuButton;
	tString msSelectedOptionsButton;
	tString msSelectedGammaButton;
	tString msSelectedInputButton;
	tString msSelectedAccessibilityButton;
	tString msSelectedAccessibilityGameButton;
	tString msSelectedAccessibilityInputButton;
	tString msSelectedGraphicsButton;
	tString msSelectedInputMouseButton;
	tString msSelectedInputGamepadButton;
	tString msSelectedInputMappingButton;
	tString msSelectedVideoButton;
	tString msSelectedDisplayButton;
	tString msSelectedVideoPostEffectButton;
	tString msSelectedVideoWorldButton;
	tString msSelectedVideoGammaButton;
	tString msSelectedAudioButton;
	tString msSelectedSubtitlesButton;
	tString msSelectedGameplayButton;
	tString msSelectedDebugButton;
	tString msSelectedModButton;
	int mlSelectedLoadButton = 0;
	int mlSelectedKeybindButton = 0;
	
	bool mbBackgroundTitleSounds =true;
	bool mbBackgroundShowTitle =false;
	float mfBackgroundTitleAlpha=0;
	
	float mfMainAlpha = gfMenuMainAlphaMax;
	
	bool mbMouseVisible=true;
	
	ePreMenuPhase mPreMenuPhase=ePreMenuPhase_Init;
	int mlPreMenuState=0;
	bool mbInitPreMenu = true;
	float mfPreMenuFadeAmount=0;
	float mfPreMenuFadeDest=0;

	int mlOptionChanges = 0;
	int mlCurrentOptionChange;

	float mfFadeOut = 0.0f;
	float mfFadeIn = 0.0f;
	
	float mfFadeLength = 1.f;
	float mfNewGameFadeLength = 8.f;
	float mfExitGameFadeLength = 1.0f;

	tString msFocusNextFrame;

	eMainMenuGroup mCurrentGroup;
	eMainMenuGroup mPrevGroup;

	cVector2f mvAspectRatio;
	cVector2f mvSize;
	cVector2f mvOffset;
	
	array<cVector2l> mvResolutionSizes;
	array<tString> mvResolutionValues;
	array<int> mvRefresh;
	array<tString> mvRefreshValues;
	int mlSelectedResolution;

	array<tWString> mvSaveNames;
	array<tString> mvSaveDates;
	array<tWString> mvSaveFiles;
	array<tWString> mvSaveSuffix;
	array<tWString> mvSaveModeSuffix;
	
	bool mbHasSaveFiles = false;
	int mlSaveFileOffset=0;
	bool mbScrollingSaveList=false;
	tString msLoadSaveError;
	bool mbProfileError;
	tWString msSaveSubFolder;
	tWString msPreviousSaveLoaded;
	tWString msContinueFile;
	//tWString msContinueSuffix;
	tWString msSaveFileToLoad;
	bool mbManualLoad = false;

	array<tString> mvLangFiles;
	
	bool mbScrolling=false;
	int mlMenuOffset=0;

	float mfDisableEscapeCount = 1.0;
	
	[nosave] float mfSubtitleOptionsBGAlpha = 1.f;
	[nosave] float mfSubtitleOptionsMenuPosOffsetY = 0.f;
	
	////////////////
	// Keybinding
	array<cBindableAction> mvActions;
	array<cBindableAction> mvGamepadActions;
	int mlActionToBind=0;
	tString msKeybindSlot = "Primary";
	bool mbScrollingKeybindList=false;
	int mlKeybindOffset=0;
	int mlKeybindFocusSlot = 0;
	tString msFocusAfterBind;
	bool mbKeybindChanged;
	int mlIgnoreInput = 0;
	tString msKeybindFirstState;
	bool mbBindingGamepad = false;
	[nosave] bool mbSavingGame = false;

	[nosave] bool mbClearTimersNextFrame = true;

	bool mbInitiated = false;
	
	[nosave] uint mlSelectedGameMode = eGameMode_Normal;
	[nosave] uint mlPrevSelectedGameMode = eGameMode_Normal;

	tString msSelectedGameModesBtn;
	tString msSelectedDisplayDIfficultySettingsBtn;
	
	[nosave] uint mlSelectedSaveSlot = 1;
	[nosave] uint mlPreviouslySelectedSaveSlot = 1;
	
	eMainMenuGroup mGamepadMappingBackDest = eMainMenuGroup_Options_Controls;
	
	eMainMenuGroup mKeyBindBackDest = eMainMenuGroup_Options_Input;
	tString msKeyBindBackFocus = msSelectedInputButton;
	
	array<cSaveSlot> mvSaveSlots;
	tString msSelectedLoadGameButton;
	int mlSelectedLoadSlot = -1;
	
	float mfCustomSettingsInputCount_Up = 0.f;
	float mfCustomSettingsInputCount_Down = 0.f;
	int mlCustomGameModeSettingsOffset = 0;
	bool mbScrollingCustomGameSettings = false;
	int mlNewGameModeToUse = eGameMode_Normal;
	array<int> mvInitialCustomDifficultySettingValueIDs;
	array<int> mvCustomSettings_Ids;
	array<tString> mvCustomSettings_Names;
	array<int> mvCustomSettings_ControlTypes;
	array<array<tString>> mvCustomSettings_ValueList;
	array<bool> mvCustomSettings_Active;
	array<int> mvReliesOn_SettingID;
	//array<int> mvReliesOn_DisablingValueID;
	array<array<int>> mvReliesOn_DisablingValueIDs;
	bool mbNewGamePlus = false;
	bool mbToggleNewGamePlus = false;
	
	[nosave] bool mbShowNewGamePlusButton = false;
	[nosave] float mfNewGamePlusCheatButtonTime = 0.f;
	[nosave] bool mbAnyButtonPressed = false;
	
	[nosave] bool mbDrawPreviewSubtitles = true;
	
	bool mbAccessibilityOptionsBackToNewGame = false;
	
	
	//------------------------------------------------------------
}
